--------------------------------------------------------
-- Archivo creado  - mi√©rcoles-diciembre-10-2025   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Type DETALLE_ESTADIA_REC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "UCM"."DETALLE_ESTADIA_REC" AS OBJECT (
    COD_HABITACION NUMBER,
    FECHA_ESTADIA DATE,
    DIAS NUMBER,
    PRECIO_HABITACION NUMBER
);

/
--------------------------------------------------------
--  DDL for Type DETALLE_ESTADIA_TAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "UCM"."DETALLE_ESTADIA_TAB" AS TABLE OF DETALLE_ESTADIA_REC;

/
--------------------------------------------------------
--  DDL for Type DETALLE_PEDIDO_REC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "UCM"."DETALLE_PEDIDO_REC" AS OBJECT (
    COD_PROVEEDOR NUMBER,
    COD_PRODUCTO NUMBER,
    NOMBRE_PRODUCTO VARCHAR2(50),
    CANTIDAD_PRODUCTO NUMBER,
    PRECIO_COMPRA NUMBER
);

/
--------------------------------------------------------
--  DDL for Type DETALLE_PEDIDO_TAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "UCM"."DETALLE_PEDIDO_TAB" AS TABLE OF DETALLE_PEDIDO_REC;

/
--------------------------------------------------------
--  DDL for Type DETALLE_VENTA_REC
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "UCM"."DETALLE_VENTA_REC" AS OBJECT (
    COD_PRODUCTO NUMBER,
    CANTIDAD NUMBER,
    PRECIO_PRODUCTO NUMBER
);

/
--------------------------------------------------------
--  DDL for Type DETALLE_VENTA_TAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE "UCM"."DETALLE_VENTA_TAB" AS TABLE OF DETALLE_VENTA_REC;

/
--------------------------------------------------------
--  DDL for Sequence GROUP_ID_SEQ
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."GROUP_ID_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_CAT_TIPO_HAB
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_CAT_TIPO_HAB"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_CAT_TIPO_SERV
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_CAT_TIPO_SERV"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_CLIENTE
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_CLIENTE"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_DEPARTAMENTO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_DEPARTAMENTO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 121 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_EMPLEADO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_EMPLEADO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 41 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_EVENTO_RESERVA
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_EVENTO_RESERVA"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_EXPERIENCIA
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_EXPERIENCIA"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_HABITACION
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_HABITACION"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_MOVIMIENTO_STOCK
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_MOVIMIENTO_STOCK"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_PAGO_HAB
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_PAGO_HAB"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_PAGO_VENTA
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_PAGO_VENTA"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_PEDIDO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_PEDIDO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_PRODUCTO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_PRODUCTO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_PROVEEDOR
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_PROVEEDOR"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 100 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_RESERVA
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_RESERVA"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_RESERVA_EXP
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_RESERVA_EXP"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_RESERVA_SERVICIO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_RESERVA_SERVICIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_ROL
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_ROL"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 4 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_SERVICIO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_SERVICIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 21 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_SERVICIO_HORARIO
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_SERVICIO_HORARIO"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_SOLICITUD_ADMIN
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_SOLICITUD_ADMIN"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Sequence SQ_PK_VENTA
--------------------------------------------------------

   CREATE SEQUENCE  "UCM"."SQ_PK_VENTA"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;
--------------------------------------------------------
--  DDL for Table ANNOTATIONS_GROUP_MEMBERS$
--------------------------------------------------------

  CREATE TABLE "UCM"."ANNOTATIONS_GROUP_MEMBERS$" 
   (	"GROUP_ID" NUMBER, 
	"OBJ#" NUMBER, 
	"OBJECT_OWNER" NUMBER, 
	"ANNOTATION_TYPE" NUMBER, 
	"COLUMN_NAME" VARCHAR2(128 BYTE), 
	"FUNCTION_NAME" VARCHAR2(128 BYTE), 
	"PROCEDURE_NAME" VARCHAR2(128 BYTE)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ANNOTATIONS_GROUPS$
--------------------------------------------------------

  CREATE TABLE "UCM"."ANNOTATIONS_GROUPS$" 
   (	"GROUP_ID" NUMBER, 
	"GROUP_NAME" VARCHAR2(255 BYTE), 
	"CREATION_TIME" TIMESTAMP (6) DEFAULT SYSTIMESTAMP
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ANNOTATIONS_PREBUILT$
--------------------------------------------------------

  CREATE TABLE "UCM"."ANNOTATIONS_PREBUILT$" 
   (	"ANNOTATION_NAME" VARCHAR2(1024 BYTE), 
	"DESCRIPTION" VARCHAR2(4000 BYTE), 
	"CATEGORY" VARCHAR2(4000 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table ANNOTATIONS_USAGE$
--------------------------------------------------------

  CREATE TABLE "UCM"."ANNOTATIONS_USAGE$" 
   (	"ANNOTATION_NAME" VARCHAR2(1024 BYTE), 
	"ANNOTATION_VALUE" VARCHAR2(4000 BYTE), 
	"ANNOTATION_TYPE" NUMBER, 
	"OBJ#" NUMBER, 
	"INTCOL_ID" NUMBER, 
	"SPARE1" NUMBER, 
	"SPARE2" NUMBER, 
	"SPARE3" VARCHAR2(4000 BYTE), 
	"SPARE4" VARCHAR2(4000 BYTE), 
	"SPARE5" DATE, 
	"ANNOTATION_OWNER" NUMBER, 
	"CREATION_TIME" TIMESTAMP (6), 
	"OBJECT_OWNER" NUMBER, 
	"COLUMN_NAME" VARCHAR2(128 BYTE), 
	"FUNCTION_NAME" VARCHAR2(128 BYTE), 
	"PROCEDURE_NAME" VARCHAR2(128 BYTE), 
	"GROUP_ID" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CALLE
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CALLE" 
   (	"COD_CALLE" NUMBER, 
	"CALLE" VARCHAR2(50 BYTE), 
	"NRO" NUMBER, 
	"COD_COMUNA" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_ESTADO_HABITACION
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_ESTADO_HABITACION" 
   (	"COD_ESTADO_HABITACION" NUMBER, 
	"ESTADO_HABITACION" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_ESTADO_LABORAL
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_ESTADO_LABORAL" 
   (	"COD_ESTADO_LABORAL" NUMBER, 
	"ESTADO_LABORAL" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_ESTADO_RESERVA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_ESTADO_RESERVA" 
   (	"COD_ESTADO_RESERVA" NUMBER, 
	"ESTADO_RESERVA" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_ESTADO_USUARIO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_ESTADO_USUARIO" 
   (	"COD_ESTADO_USUARIO" NUMBER, 
	"ESTADO_USUARIO" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_MODO_PAGO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_MODO_PAGO" 
   (	"COD_MODO_PAGO" NUMBER, 
	"MODO_PAGO" VARCHAR2(30 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_TIPO_HABITACION
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_TIPO_HABITACION" 
   (	"COD_TIPO_HABITACION" NUMBER, 
	"TIPO_HABITACION" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CAT_TIPO_SERVICIO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CAT_TIPO_SERVICIO" 
   (	"COD_TIPO_SERVICIO" NUMBER, 
	"NOMBRE" VARCHAR2(50 BYTE), 
	"DESCRIPCION" VARCHAR2(200 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CIUDAD
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CIUDAD" 
   (	"COD_CIUDAD" NUMBER, 
	"CIUDAD" VARCHAR2(50 BYTE), 
	"COD_REGION" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_CLIENTE
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_CLIENTE" 
   (	"COD_CLIENTE" NUMBER, 
	"COD_USUARIO" NUMBER, 
	"FECHA_ALTA" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_COMUNA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_COMUNA" 
   (	"COD_COMUNA" NUMBER, 
	"COMUNA" VARCHAR2(50 BYTE), 
	"COD_CIUDAD" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_DEPARTAMENTO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_DEPARTAMENTO" 
   (	"COD_DEPARTAMENTO" NUMBER, 
	"NOMBRE" VARCHAR2(100 BYTE), 
	"JEFE_EMPLEADO_ID" NUMBER, 
	"PRESUPUESTO" NUMBER, 
	"FECHA_CREACION" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_DEPARTAMENTO_EMPLEADO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_DEPARTAMENTO_EMPLEADO" 
   (	"COD_DEPARTAMENTO" NUMBER, 
	"COD_EMPLEADO" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_DETALLE_PAGO_HABITACION
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_DETALLE_PAGO_HABITACION" 
   (	"COD_PAGO_HABITACION" NUMBER, 
	"COD_HABITACION" NUMBER, 
	"FECHA_ESTADIA" DATE, 
	"PRECIO_HABITACION" NUMBER, 
	"DIAS" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_DETALLE_PEDIDO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_DETALLE_PEDIDO" 
   (	"COD_PEDIDO" NUMBER, 
	"COD_PROVEEDOR" NUMBER, 
	"COD_PRODUCTO" NUMBER, 
	"NOMBRE_PRODUCTO" VARCHAR2(50 BYTE), 
	"CANTIDAD_PRODUCTO" NUMBER, 
	"PRECIO_COMPRA" NUMBER, 
	"PRECIO_TOTAL" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_DETALLE_VENTA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_DETALLE_VENTA" 
   (	"COD_VENTA" NUMBER, 
	"COD_PRODUCTO" NUMBER, 
	"CANTIDAD" NUMBER, 
	"PRECIO_PRODUCTO" NUMBER, 
	"PRECIO_TOTAL" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_EMPLEADO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_EMPLEADO" 
   (	"COD_EMPLEADO" NUMBER, 
	"COD_USUARIO" NUMBER, 
	"COD_DEPARTAMENTO" NUMBER, 
	"CARGO" VARCHAR2(50 BYTE), 
	"FECHA_CONTRATACION" DATE, 
	"SALARIO" NUMBER, 
	"COMISION" NUMBER, 
	"COD_ESTADO_LABORAL" NUMBER, 
	"SUELDO_BASE" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_EMPLEADO_HABILIDAD
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_EMPLEADO_HABILIDAD" 
   (	"COD_EMPLEADO" NUMBER, 
	"CATEGORIA" VARCHAR2(50 BYTE), 
	"TIPO" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_EVENTO_RESERVA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_EVENTO_RESERVA" 
   (	"COD_EVENTO_RESERVA" NUMBER, 
	"COD_RESERVA" NUMBER, 
	"TIPO_EVENTO" VARCHAR2(50 BYTE), 
	"FECHA_EVENTO" DATE, 
	"NOTAS" VARCHAR2(500 BYTE), 
	"CREATED_AT" DATE DEFAULT SYSDATE, 
	"CREATED_BY" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_EXPERIENCIA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_EXPERIENCIA" 
   (	"COD_EXPERIENCIA" NUMBER, 
	"NOMBRE" VARCHAR2(100 BYTE), 
	"DESCRIPCION" VARCHAR2(255 BYTE), 
	"PRECIO" NUMBER, 
	"TAG" VARCHAR2(50 BYTE), 
	"ESTADO" VARCHAR2(20 BYTE)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_HABITACION
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_HABITACION" 
   (	"COD_HABITACION" NUMBER, 
	"NRO_HABITACION" NUMBER, 
	"CAPACIDAD" NUMBER, 
	"COD_TIPO_HABITACION" NUMBER, 
	"COD_ESTADO_HABITACION" NUMBER, 
	"PRECIO_BASE" NUMBER, 
	"COD_USUARIO_OCUPANTE" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_MOVIMIENTO_STOCK
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_MOVIMIENTO_STOCK" 
   (	"COD_MOVIMIENTO" NUMBER, 
	"COD_PRODUCTO" NUMBER, 
	"TIPO_MOVIMIENTO" VARCHAR2(20 BYTE), 
	"CANTIDAD" NUMBER, 
	"FECHA_MOVIMIENTO" DATE, 
	"MOTIVO" VARCHAR2(100 BYTE)
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_PAGO_HABITACION
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_PAGO_HABITACION" 
   (	"COD_PAGO_HABITACION" NUMBER, 
	"FECHA_PAGO" DATE, 
	"VALOR_TOTAL_PAGO" NUMBER, 
	"COD_USUARIO" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_PAGO_VENTA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_PAGO_VENTA" 
   (	"COD_PAGO" NUMBER, 
	"COD_VENTA" NUMBER, 
	"COD_MODO_PAGO" NUMBER, 
	"MONTO" NUMBER, 
	"FECHA_PAGO" DATE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_PEDIDO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_PEDIDO" 
   (	"COD_PEDIDO" NUMBER, 
	"VALOR_TOTAL" NUMBER, 
	"FECHA_PEDIDO" DATE, 
	"COD_EMPLEADO" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_PRODUCTO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_PRODUCTO" 
   (	"COD_PRODUCTO" NUMBER, 
	"NOMBRE_PRODUCTO" VARCHAR2(50 BYTE), 
	"COD_TIPO_SERVICIO" NUMBER, 
	"PRECIO_PRODUCTO" NUMBER, 
	"CANTIDAD_PRODUCTO" NUMBER, 
	"STOCK_PRODUCTO" NUMBER, 
	"UMBRAL_ALERTA" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_PROVEEDOR
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_PROVEEDOR" 
   (	"COD_PROVEEDOR" NUMBER, 
	"NOMBRE_PROVEEDOR" VARCHAR2(50 BYTE), 
	"DIRECCION_PROVEEDOR" VARCHAR2(100 BYTE), 
	"TELEFONO_PROVEEDOR" NUMBER, 
	"COD_REGION" NUMBER, 
	"COD_CIUDAD" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_REGION
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_REGION" 
   (	"COD_REGION" NUMBER, 
	"REGION" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_RESERVA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_RESERVA" 
   (	"COD_RESERVA" NUMBER, 
	"COD_USUARIO" NUMBER, 
	"COD_HABITACION" NUMBER, 
	"FECHA_INICIO" DATE, 
	"FECHA_FIN" DATE, 
	"HUESPEDES" NUMBER, 
	"TOTAL_HABITACION" NUMBER DEFAULT 0, 
	"TOTAL_SERVICIOS" NUMBER DEFAULT 0, 
	"TOTAL" NUMBER, 
	"COD_ESTADO_RESERVA" NUMBER, 
	"CREATED_AT" DATE DEFAULT SYSDATE, 
	"UPDATED_AT" DATE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_RESERVA_EXP
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_RESERVA_EXP" 
   (	"COD_RESERVA_EXP" NUMBER, 
	"COD_RESERVA" NUMBER, 
	"COD_EXPERIENCIA" NUMBER, 
	"CANTIDAD" NUMBER DEFAULT 1, 
	"PRECIO_UNITARIO" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_RESERVA_SERVICIO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_RESERVA_SERVICIO" 
   (	"COD_RESERVA_SERVICIO" NUMBER, 
	"COD_RESERVA" NUMBER, 
	"COD_SERVICIO" NUMBER, 
	"FECHA_SERVICIO" DATE, 
	"HORA" NUMBER(2,0), 
	"CANTIDAD" NUMBER DEFAULT 1, 
	"PRECIO_UNIT" NUMBER DEFAULT 0, 
	"TOTAL" NUMBER, 
	"NOTA" VARCHAR2(500 BYTE), 
	"ESTADO" VARCHAR2(20 BYTE) DEFAULT 'pendiente', 
	"CREATED_AT" DATE DEFAULT SYSDATE, 
	"UPDATED_AT" DATE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_ROL
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_ROL" 
   (	"COD_ROL" NUMBER, 
	"NOMBRE_ROL" VARCHAR2(50 BYTE)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_SERVICIO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_SERVICIO" 
   (	"COD_SERVICIO" NUMBER, 
	"NOMBRE" VARCHAR2(100 BYTE), 
	"DESCRIPCION" VARCHAR2(500 BYTE), 
	"PRECIO" NUMBER DEFAULT 0, 
	"COD_TIPO_SERVICIO" NUMBER, 
	"ESTADO" VARCHAR2(20 BYTE) DEFAULT 'activo', 
	"ES_DESTACADO" CHAR(1 BYTE) DEFAULT 'N', 
	"ORDEN" NUMBER, 
	"CREATED_AT" DATE DEFAULT SYSDATE, 
	"UPDATED_AT" DATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_SERVICIO_HORARIO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_SERVICIO_HORARIO" 
   (	"COD_HORARIO" NUMBER, 
	"COD_SERVICIO" NUMBER, 
	"HORA_INICIO" NUMBER(4,2), 
	"HORA_FIN" NUMBER(4,2)
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_SERVICIO_PAQUETE
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_SERVICIO_PAQUETE" 
   (	"COD_PAQUETE" NUMBER, 
	"COD_SERVICIO_INCL" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_SERVICIO_PRODUCTO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_SERVICIO_PRODUCTO" 
   (	"COD_SERVICIO" NUMBER, 
	"COD_PRODUCTO" NUMBER, 
	"CANTIDAD_BASE" NUMBER DEFAULT 1, 
	"PRECIO_EXTRA" NUMBER
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_SOLICITUD_ADMIN
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_SOLICITUD_ADMIN" 
   (	"COD_SOLICITUD" NUMBER, 
	"COD_USUARIO" NUMBER, 
	"ESTADO" VARCHAR2(20 BYTE), 
	"MOTIVO" VARCHAR2(255 BYTE), 
	"APROBADO_POR" NUMBER, 
	"FECHA_CREACION" DATE DEFAULT SYSDATE, 
	"FECHA_RESOLUCION" DATE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_USUARIO
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_USUARIO" 
   (	"COD_USUARIO" NUMBER(8,0), 
	"NOMBRE_USUARIO" VARCHAR2(50 BYTE), 
	"APELLIDO1_USUARIO" VARCHAR2(50 BYTE), 
	"APELLIDO2_USUARIO" VARCHAR2(50 BYTE), 
	"EMAIL_USUARIO" VARCHAR2(100 BYTE), 
	"TELEFONO_USUARIO" NUMBER, 
	"CONTRASENA_HASH" VARCHAR2(255 BYTE), 
	"COD_ESTADO_USUARIO" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_USUARIO_ROL
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_USUARIO_ROL" 
   (	"COD_USUARIO" NUMBER, 
	"COD_ROL" NUMBER
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table JRGY_VENTA
--------------------------------------------------------

  CREATE TABLE "UCM"."JRGY_VENTA" 
   (	"COD_VENTA" NUMBER, 
	"COD_USUARIO" NUMBER, 
	"COD_EMPLEADO" NUMBER, 
	"FECHA_VENTA" DATE
   ) SEGMENT CREATION DEFERRED 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Table TOKENS
--------------------------------------------------------

  CREATE TABLE "UCM"."TOKENS" 
   (	"TOKEN" VARCHAR2(128 BYTE), 
	"USER_ID" NUMBER, 
	"EXPIRES_AT" DATE, 
	"CREATED_AT" DATE DEFAULT SYSDATE
   ) SEGMENT CREATION IMMEDIATE 
  PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 
 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for View METADATA_ANNOTATIONS_GROUP_MEM
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "UCM"."METADATA_ANNOTATIONS_GROUP_MEM" ("GROUP_NAME", "ANNOTATION_TYPE", "USER_NAME", "OBJECT_NAME", "OBJECT_TYPE", "COLUMN_NAME", "PROCEDURE_NAME", "FUNCTION_NAME") AS 
  select ag.group_name,
  decode(annotation_type, 1, 'TABLE', 2, 'TABLE COLUMN', 3, 'TABLE PARTITION', 
              4, 'TABLE SUBPARTITION', 5, 'VIEW', 
              6, 'VIEW COLUMN', 7, 'PACKAGE', 8, 'PACKAGE PROCEDURE', 
              9, 'PACKAGE FUNCTION', 10, 'PROCEDURE', 11, 'FUNCTION', 12, 'SCHEMA', 13, 'DATABASE', 
              15, 'MATERIALIZED VIEW', 16, 'MATERIALIZED VIEW COLUMN'),
  user_name, object_name, object_type, column_name, procedure_name, function_name
from
(
/* Should work for all types with a base object */
select agm.group_id, agm.annotation_type, 
       o.owner as user_name, o.object_name, o.object_type,
       agm.column_name, agm.procedure_name, agm.function_name
from annotations_group_members$ agm, 
     sys.all_objects o 
where agm.obj# = o.object_id
union
/* Schema level annotations */
select agm.group_id, agm.annotation_type, 
       username, null, null, null, null, NULL
from annotations_group_members$ agm,
      sys.all_users us
  where agm.annotation_type = 12
    and agm.object_owner = us.user_id /* Verify valid user */
union
/* Database level annotations */
select agm.group_id, agm.annotation_type, null, null, null, null, null, null 
 from annotations_group_members$ agm
  where annotation_type = 13
) agm, annotations_groups$ ag
where agm.group_id = ag.group_id
;
--------------------------------------------------------
--  DDL for View METADATA_ANNOTATIONS_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "UCM"."METADATA_ANNOTATIONS_GROUPS" ("GROUP_NAME", "CREATION_TIME") AS 
  SELECT group_name, creation_time
FROM annotations_groups$
;
--------------------------------------------------------
--  DDL for View METADATA_ANNOTATIONS_USAGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "UCM"."METADATA_ANNOTATIONS_USAGE" ("ANNOTATION_TYPE", "USER_NAME", "OBJECT_NAME", "OBJECT_TYPE", "COLUMN_NAME", "PROCEDURE_NAME", "FUNCTION_NAME", "GROUP_NAME", "ANNOTATION_NAME", "ANNOTATION_VALUE") AS 
  select decode(annotation_type, 1, 'TABLE', 2, 'TABLE COLUMN', 3, 'TABLE PARTITION', 
              4, 'TABLE SUBPARTITION', 5, 'VIEW', 
              6, 'VIEW COLUMN', 7, 'PACKAGE', 8, 'PACKAGE PROCEDURE', 
              9, 'PACKAGE FUNCTION', 10, 'PROCEDURE', 11, 'FUNCTION', 12, 'SCHEMA', 13, 'DATABASE', 
              14, 'GROUP', 15, 'MATERIALIZED VIEW', 16, 'MATERIALIZED VIEW COLUMN'),
  user_name, object_name, object_type, column_name, procedure_name, function_name, group_name, 
  annotation_name, annotation_value
from
(
/* Should work for all types with a base object */
select annotation_type, o.owner as user_name, o.object_name, o.object_type,
  au.column_name, procedure_name, function_name, null as group_name,
  au.annotation_name as annotation_name, 
  au.annotation_value as annotation_value
from annotations_usage$ au, 
     sys.all_objects o 
where au.obj# = o.object_id
union
/* Schema level annotations */
select annotation_type, username, null, null, null, null, null, null,
       annotation_name, annotation_value
 from annotations_usage$ au,
      sys.all_users us
  where annotation_type = 12
    and au.object_owner = us.user_id /* Verify valid user */
union
/* Database level annotations */
select annotation_type, null, null, null, null, null, null, null,
       annotation_name, annotation_value
 from annotations_usage$ 
  where annotation_type = 13
union
/* Group level annotations */
select annotation_type, null, null, null, null, null, null, 
       ag.group_name as group_name,
       au.annotation_name, au.annotation_value
 from annotations_usage$ au, annotations_groups$ ag
  where au.annotation_type = 14 and
        au.group_id = ag.group_id
)
;
--------------------------------------------------------
--  DDL for View METADATA_PREBUILT_ANNOTATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "UCM"."METADATA_PREBUILT_ANNOTATIONS" ("ANNOTATION_NAME", "DESCRIPTION", "CATEGORY") AS 
  select "ANNOTATION_NAME","DESCRIPTION","CATEGORY" from annotations_prebuilt$
;
REM INSERTING into UCM.ANNOTATIONS_GROUP_MEMBERS$
SET DEFINE OFF;
REM INSERTING into UCM.ANNOTATIONS_GROUPS$
SET DEFINE OFF;
REM INSERTING into UCM.ANNOTATIONS_PREBUILT$
SET DEFINE OFF;
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_SECURITY_PII','Personally Identifiable Information','SECURITY');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_SECURITY_SENSITIVE','Sensitive personal information','SECURITY');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_SECURITY_LEVEL','Access level','SECURITY');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_ANALYTICS_DIMENSION','Dimension','ANALYTICS');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_ANALYTICS_AGG','Aggregation','ANALYTICS');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_RELATIONSHIP_FOREIGN_KEY','Foreign Key','RELATIONSHIP');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_RELATIONSHIP_PRIMARY_KEY','Primary Key','RELATIONSHIP');
Insert into UCM.ANNOTATIONS_PREBUILT$ (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_RELATIONSHIP_JOIN','Join column','RELATIONSHIP');
REM INSERTING into UCM.ANNOTATIONS_USAGE$
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_CALLE
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_CAT_ESTADO_HABITACION
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_ESTADO_HABITACION (COD_ESTADO_HABITACION,ESTADO_HABITACION) values ('1','LIBRE');
Insert into UCM.JRGY_CAT_ESTADO_HABITACION (COD_ESTADO_HABITACION,ESTADO_HABITACION) values ('2','OCUPADA');
Insert into UCM.JRGY_CAT_ESTADO_HABITACION (COD_ESTADO_HABITACION,ESTADO_HABITACION) values ('3','MANTENCION');
REM INSERTING into UCM.JRGY_CAT_ESTADO_LABORAL
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_ESTADO_LABORAL (COD_ESTADO_LABORAL,ESTADO_LABORAL) values ('1','ACTIVO');
Insert into UCM.JRGY_CAT_ESTADO_LABORAL (COD_ESTADO_LABORAL,ESTADO_LABORAL) values ('2','SUSPENDIDO');
Insert into UCM.JRGY_CAT_ESTADO_LABORAL (COD_ESTADO_LABORAL,ESTADO_LABORAL) values ('3','INACTIVO');
Insert into UCM.JRGY_CAT_ESTADO_LABORAL (COD_ESTADO_LABORAL,ESTADO_LABORAL) values ('4','DESPEDIDO');
Insert into UCM.JRGY_CAT_ESTADO_LABORAL (COD_ESTADO_LABORAL,ESTADO_LABORAL) values ('5','RENUNCIADO');
REM INSERTING into UCM.JRGY_CAT_ESTADO_RESERVA
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_ESTADO_RESERVA (COD_ESTADO_RESERVA,ESTADO_RESERVA) values ('1','CREADA');
Insert into UCM.JRGY_CAT_ESTADO_RESERVA (COD_ESTADO_RESERVA,ESTADO_RESERVA) values ('2','CONFIRMADA');
Insert into UCM.JRGY_CAT_ESTADO_RESERVA (COD_ESTADO_RESERVA,ESTADO_RESERVA) values ('3','EN_PROCESO');
Insert into UCM.JRGY_CAT_ESTADO_RESERVA (COD_ESTADO_RESERVA,ESTADO_RESERVA) values ('4','CHECKOUT_SOLICITADO');
Insert into UCM.JRGY_CAT_ESTADO_RESERVA (COD_ESTADO_RESERVA,ESTADO_RESERVA) values ('5','FINALIZADA');
Insert into UCM.JRGY_CAT_ESTADO_RESERVA (COD_ESTADO_RESERVA,ESTADO_RESERVA) values ('6','CANCELADA');
REM INSERTING into UCM.JRGY_CAT_ESTADO_USUARIO
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_ESTADO_USUARIO (COD_ESTADO_USUARIO,ESTADO_USUARIO) values ('1','ACTIVO');
Insert into UCM.JRGY_CAT_ESTADO_USUARIO (COD_ESTADO_USUARIO,ESTADO_USUARIO) values ('2','INACTIVO');
REM INSERTING into UCM.JRGY_CAT_MODO_PAGO
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_MODO_PAGO (COD_MODO_PAGO,MODO_PAGO) values ('1','EFECTIVO');
Insert into UCM.JRGY_CAT_MODO_PAGO (COD_MODO_PAGO,MODO_PAGO) values ('2','TARJETA');
Insert into UCM.JRGY_CAT_MODO_PAGO (COD_MODO_PAGO,MODO_PAGO) values ('3','TRANSFERENCIA');
REM INSERTING into UCM.JRGY_CAT_TIPO_HABITACION
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('1','SIMPLE');
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('2','DOBLE');
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('3','MATRIMONIAL');
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('4','PREMIUM');
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('5','CONFORT');
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('6','MATRIMONIAL_FAMILIAR');
Insert into UCM.JRGY_CAT_TIPO_HABITACION (COD_TIPO_HABITACION,TIPO_HABITACION) values ('7','SUITE');
REM INSERTING into UCM.JRGY_CAT_TIPO_SERVICIO
SET DEFINE OFF;
Insert into UCM.JRGY_CAT_TIPO_SERVICIO (COD_TIPO_SERVICIO,NOMBRE,DESCRIPCION) values ('1','SPA','Servicios de bienestar y spa');
Insert into UCM.JRGY_CAT_TIPO_SERVICIO (COD_TIPO_SERVICIO,NOMBRE,DESCRIPCION) values ('2','LIMPIEZA','Servicios de limpieza y housekeeping');
Insert into UCM.JRGY_CAT_TIPO_SERVICIO (COD_TIPO_SERVICIO,NOMBRE,DESCRIPCION) values ('3','TOUR','Tours y actividades externas');
Insert into UCM.JRGY_CAT_TIPO_SERVICIO (COD_TIPO_SERVICIO,NOMBRE,DESCRIPCION) values ('4','RESTAURANTE','Consumos de restaurante/bar');
Insert into UCM.JRGY_CAT_TIPO_SERVICIO (COD_TIPO_SERVICIO,NOMBRE,DESCRIPCION) values ('5','OTROS','Servicios generales');
REM INSERTING into UCM.JRGY_CIUDAD
SET DEFINE OFF;
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('100','TALCA','10');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('101','CURICO','10');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('102','LINARES','10');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('103','CAUQUENES','10');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('110','RANCAGUA','11');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('111','SAN FERNANDO','11');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('120','CHILLAN','12');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('121','SAN CARLOS','12');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('130','CONCEPCION','13');
Insert into UCM.JRGY_CIUDAD (COD_CIUDAD,CIUDAD,COD_REGION) values ('131','LOS ANGELES','13');
REM INSERTING into UCM.JRGY_CLIENTE
SET DEFINE OFF;
Insert into UCM.JRGY_CLIENTE (COD_CLIENTE,COD_USUARIO,FECHA_ALTA) values ('1','33333333',to_date('10/12/25','DD/MM/RR'));
REM INSERTING into UCM.JRGY_COMUNA
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_DEPARTAMENTO
SET DEFINE OFF;
Insert into UCM.JRGY_DEPARTAMENTO (COD_DEPARTAMENTO,NOMBRE,JEFE_EMPLEADO_ID,PRESUPUESTO,FECHA_CREACION) values ('107','Recepcion',null,'15000000',to_date('10/12/25','DD/MM/RR'));
Insert into UCM.JRGY_DEPARTAMENTO (COD_DEPARTAMENTO,NOMBRE,JEFE_EMPLEADO_ID,PRESUPUESTO,FECHA_CREACION) values ('108','Mantenimiento',null,'18000000',to_date('10/12/25','DD/MM/RR'));
Insert into UCM.JRGY_DEPARTAMENTO (COD_DEPARTAMENTO,NOMBRE,JEFE_EMPLEADO_ID,PRESUPUESTO,FECHA_CREACION) values ('109','Limpieza',null,'12000000',to_date('10/12/25','DD/MM/RR'));
Insert into UCM.JRGY_DEPARTAMENTO (COD_DEPARTAMENTO,NOMBRE,JEFE_EMPLEADO_ID,PRESUPUESTO,FECHA_CREACION) values ('110','Servicios',null,'14000000',to_date('10/12/25','DD/MM/RR'));
Insert into UCM.JRGY_DEPARTAMENTO (COD_DEPARTAMENTO,NOMBRE,JEFE_EMPLEADO_ID,PRESUPUESTO,FECHA_CREACION) values ('111','Seguridad',null,'13000000',to_date('10/12/25','DD/MM/RR'));
Insert into UCM.JRGY_DEPARTAMENTO (COD_DEPARTAMENTO,NOMBRE,JEFE_EMPLEADO_ID,PRESUPUESTO,FECHA_CREACION) values ('112','Cocina',null,'16000000',to_date('10/12/25','DD/MM/RR'));
REM INSERTING into UCM.JRGY_DEPARTAMENTO_EMPLEADO
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_DETALLE_PAGO_HABITACION
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_DETALLE_PEDIDO
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_DETALLE_VENTA
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_EMPLEADO
SET DEFINE OFF;
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('11','22222222',null,'Recepcionista',to_date('09/12/25','DD/MM/RR'),'850000','0','1','0');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('12','40000001','107','Recepcionista',to_date('09/12/25','DD/MM/RR'),null,null,'1','750000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('13','40000002','108','Tecnico',to_date('10/12/25','DD/MM/RR'),null,null,'1','820000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('14','40000003','109','Operador',to_date('10/12/25','DD/MM/RR'),null,null,'1','700000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('15','40000004','108','Tecnico',to_date('10/12/25','DD/MM/RR'),null,null,'1','820000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('16','40000005','107','Recepcionista',to_date('10/12/25','DD/MM/RR'),null,null,'1','750000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('17','40000006','110','Mozo',to_date('10/12/25','DD/MM/RR'),null,null,'1','680000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('18','40000007','110','Camarera',to_date('10/12/25','DD/MM/RR'),null,null,'1','680000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('19','40000008','111','Guardia',to_date('10/12/25','DD/MM/RR'),null,null,'1','800000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('20','40000009','109','Operador',to_date('10/12/25','DD/MM/RR'),null,null,'1','700000');
Insert into UCM.JRGY_EMPLEADO (COD_EMPLEADO,COD_USUARIO,COD_DEPARTAMENTO,CARGO,FECHA_CONTRATACION,SALARIO,COMISION,COD_ESTADO_LABORAL,SUELDO_BASE) values ('21','40000010','112','Cocinero',to_date('10/12/25','DD/MM/RR'),null,null,'1','850000');
REM INSERTING into UCM.JRGY_EMPLEADO_HABILIDAD
SET DEFINE OFF;
Insert into UCM.JRGY_EMPLEADO_HABILIDAD (COD_EMPLEADO,CATEGORIA,TIPO) values ('11','OTROS','PRODUCTO');
Insert into UCM.JRGY_EMPLEADO_HABILIDAD (COD_EMPLEADO,CATEGORIA,TIPO) values ('12','LIMPIEZA','PRODUCTO');
REM INSERTING into UCM.JRGY_EVENTO_RESERVA
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_EXPERIENCIA
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_HABITACION
SET DEFINE OFF;
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('1','101','1','1','1','45000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('2','102','1','1','1','45000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('3','103','1','1','1','45000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('4','201','2','3','1','60000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('5','202','2','3','1','60000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('6','203','2','3','1','60000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('7','301','2','5','1','70000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('8','302','2','5','1','70000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('9','303','2','5','1','70000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('10','401','4','6','1','90000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('11','402','4','6','1','90000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('12','403','4','6','1','90000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('13','501','3','7','1','85000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('14','502','3','7','1','85000',null);
Insert into UCM.JRGY_HABITACION (COD_HABITACION,NRO_HABITACION,CAPACIDAD,COD_TIPO_HABITACION,COD_ESTADO_HABITACION,PRECIO_BASE,COD_USUARIO_OCUPANTE) values ('15','503','3','7','1','85000',null);
REM INSERTING into UCM.JRGY_MOVIMIENTO_STOCK
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_PAGO_HABITACION
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_PAGO_VENTA
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_PEDIDO
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_PRODUCTO
SET DEFINE OFF;
Insert into UCM.JRGY_PRODUCTO (COD_PRODUCTO,NOMBRE_PRODUCTO,COD_TIPO_SERVICIO,PRECIO_PRODUCTO,CANTIDAD_PRODUCTO,STOCK_PRODUCTO,UMBRAL_ALERTA) values ('1','Toalla Blanca','1','5000','50','50',null);
Insert into UCM.JRGY_PRODUCTO (COD_PRODUCTO,NOMBRE_PRODUCTO,COD_TIPO_SERVICIO,PRECIO_PRODUCTO,CANTIDAD_PRODUCTO,STOCK_PRODUCTO,UMBRAL_ALERTA) values ('2','Set Amenity','2','4000','80','80',null);
Insert into UCM.JRGY_PRODUCTO (COD_PRODUCTO,NOMBRE_PRODUCTO,COD_TIPO_SERVICIO,PRECIO_PRODUCTO,CANTIDAD_PRODUCTO,STOCK_PRODUCTO,UMBRAL_ALERTA) values ('3','Linternaa',null,'6000','0','30',null);
REM INSERTING into UCM.JRGY_PROVEEDOR
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_REGION
SET DEFINE OFF;
Insert into UCM.JRGY_REGION (COD_REGION,REGION) values ('10','MAULE');
Insert into UCM.JRGY_REGION (COD_REGION,REGION) values ('11','OHIGGINS');
Insert into UCM.JRGY_REGION (COD_REGION,REGION) values ('12','NUBLE');
Insert into UCM.JRGY_REGION (COD_REGION,REGION) values ('13','BIOBIO');
REM INSERTING into UCM.JRGY_RESERVA
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_RESERVA_EXP
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_RESERVA_SERVICIO
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_ROL
SET DEFINE OFF;
Insert into UCM.JRGY_ROL (COD_ROL,NOMBRE_ROL) values ('1','ADMIN');
Insert into UCM.JRGY_ROL (COD_ROL,NOMBRE_ROL) values ('2','EMPLOYEE');
Insert into UCM.JRGY_ROL (COD_ROL,NOMBRE_ROL) values ('3','USER');
REM INSERTING into UCM.JRGY_SERVICIO
SET DEFINE OFF;
Insert into UCM.JRGY_SERVICIO (COD_SERVICIO,NOMBRE,DESCRIPCION,PRECIO,COD_TIPO_SERVICIO,ESTADO,ES_DESTACADO,ORDEN,CREATED_AT,UPDATED_AT) values ('2','Spa Relaxx','Acceso spa y sauna','25000',null,'activo','N','1',to_date('10/12/25','DD/MM/RR'),to_date('10/12/25','DD/MM/RR'));
Insert into UCM.JRGY_SERVICIO (COD_SERVICIO,NOMBRE,DESCRIPCION,PRECIO,COD_TIPO_SERVICIO,ESTADO,ES_DESTACADO,ORDEN,CREATED_AT,UPDATED_AT) values ('3','Room Clean','Limpieza completa','12000','2','activo','N','2',to_date('10/12/25','DD/MM/RR'),null);
Insert into UCM.JRGY_SERVICIO (COD_SERVICIO,NOMBRE,DESCRIPCION,PRECIO,COD_TIPO_SERVICIO,ESTADO,ES_DESTACADO,ORDEN,CREATED_AT,UPDATED_AT) values ('4','Exterior Tour','Tour guiado exterior','30000','3','activo','N','3',to_date('10/12/25','DD/MM/RR'),null);
REM INSERTING into UCM.JRGY_SERVICIO_HORARIO
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_SERVICIO_PAQUETE
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_SERVICIO_PRODUCTO
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_SOLICITUD_ADMIN
SET DEFINE OFF;
REM INSERTING into UCM.JRGY_USUARIO
SET DEFINE OFF;
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('11111111','Gustavo_admin_pagea','Gallegos','Harnisch','gustavo.admin@example.com','123456789','$2a$10$4PKlqEd.yqxq/sqPK3eyp.8oYpKpstmL3dK1R9X4pNkukuDMMAdu.','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('22222222','Gustavo','Empleado','Demo','gustavo.empleado@example.com','222333444','$2a$10$2Pz5XLwrm1waZtBePFgkcuI5AdkfDFaX8tLI33GRbbo8cCdtHv1BG','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('33333333','Gustavo','Cliente','Demo','gustavo.cliente@example.com','333444555','$2a$10$wZZfA4QNAE5CDfNlEByJ0eX8geyStz3R6NQzd.7UCrU08JMKjsyxu','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000001','Alex','Rivera','Demo','alex.rivera.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000002','Bruno','Lopez','Demo','bruno.lopez.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000003','Carla','Diaz','Demo','carla.diaz.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000004','Diego','Torres','Demo','diego.torres.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000005','Elena','Paz','Demo','elena.paz.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000006','Felipe','Lara','Demo','felipe.lara.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000007','Gabriela','Moya','Demo','gabriela.moya.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000008','Hugo','Salas','Demo','hugo.salas.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000009','Isabel','Campos','Demo','isabel.campos.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
Insert into UCM.JRGY_USUARIO (COD_USUARIO,NOMBRE_USUARIO,APELLIDO1_USUARIO,APELLIDO2_USUARIO,EMAIL_USUARIO,TELEFONO_USUARIO,CONTRASENA_HASH,COD_ESTADO_USUARIO) values ('40000010','Jorge','Fuentes','Demo','jorge.fuentes.demo@example.com','999999999','$2a$10$R4gAes1yY3W08LJi84SX2eHI1y19clorv1PelbHyML4lQxCalWZU6','1');
REM INSERTING into UCM.JRGY_USUARIO_ROL
SET DEFINE OFF;
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('11111111','1');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('22222222','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('33333333','3');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000001','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000002','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000003','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000004','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000005','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000006','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000007','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000008','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000009','2');
Insert into UCM.JRGY_USUARIO_ROL (COD_USUARIO,COD_ROL) values ('40000010','2');
REM INSERTING into UCM.JRGY_VENTA
SET DEFINE OFF;
REM INSERTING into UCM.TOKENS
SET DEFINE OFF;
Insert into UCM.TOKENS (TOKEN,USER_ID,EXPIRES_AT,CREATED_AT) values ('af76f3436d5e581402d58af2e49f2b7aa03677f61b14751ee7a913e4d35fb0e5','11111111',to_date('11/12/25','DD/MM/RR'),to_date('10/12/25','DD/MM/RR'));
REM INSERTING into UCM.METADATA_ANNOTATIONS_GROUP_MEM
SET DEFINE OFF;
REM INSERTING into UCM.METADATA_ANNOTATIONS_GROUPS
SET DEFINE OFF;
REM INSERTING into UCM.METADATA_ANNOTATIONS_USAGE
SET DEFINE OFF;
REM INSERTING into UCM.METADATA_PREBUILT_ANNOTATIONS
SET DEFINE OFF;
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_SECURITY_PII','Personally Identifiable Information','SECURITY');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_SECURITY_SENSITIVE','Sensitive personal information','SECURITY');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_SECURITY_LEVEL','Access level','SECURITY');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_ANALYTICS_DIMENSION','Dimension','ANALYTICS');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_ANALYTICS_AGG','Aggregation','ANALYTICS');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_RELATIONSHIP_FOREIGN_KEY','Foreign Key','RELATIONSHIP');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_RELATIONSHIP_PRIMARY_KEY','Primary Key','RELATIONSHIP');
Insert into UCM.METADATA_PREBUILT_ANNOTATIONS (ANNOTATION_NAME,DESCRIPTION,CATEGORY) values ('AI_RELATIONSHIP_JOIN','Join column','RELATIONSHIP');
--------------------------------------------------------
--  DDL for Index IDX_JRGY_EVENTO_RESERVA_RES
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_EVENTO_RESERVA_RES" ON "UCM"."JRGY_EVENTO_RESERVA" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_EXP_EXP
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_EXP_EXP" ON "UCM"."JRGY_RESERVA_EXP" ("COD_EXPERIENCIA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_EXP_RES
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_EXP_RES" ON "UCM"."JRGY_RESERVA_EXP" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_HAB
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_HAB" ON "UCM"."JRGY_RESERVA" ("COD_HABITACION", "FECHA_INICIO", "FECHA_FIN") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_USUARIO
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_USUARIO" ON "UCM"."JRGY_RESERVA" ("COD_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RES_SERV_RES
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RES_SERV_RES" ON "UCM"."JRGY_RESERVA_SERVICIO" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RES_SERV_SERV
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RES_SERV_SERV" ON "UCM"."JRGY_RESERVA_SERVICIO" ("COD_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_SOLICITUD_USUARIO
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_SOLICITUD_USUARIO" ON "UCM"."JRGY_SOLICITUD_ADMIN" ("COD_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_TOKENS_USER
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_TOKENS_USER" ON "UCM"."TOKENS" ("USER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CALLE
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CALLE" ON "UCM"."JRGY_CALLE" ("COD_CALLE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_HABITACION" ON "UCM"."JRGY_CAT_ESTADO_HABITACION" ("COD_ESTADO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_LABORAL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_LABORAL" ON "UCM"."JRGY_CAT_ESTADO_LABORAL" ("COD_ESTADO_LABORAL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_RESERVA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_RESERVA" ON "UCM"."JRGY_CAT_ESTADO_RESERVA" ("COD_ESTADO_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_USUARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_USUARIO" ON "UCM"."JRGY_CAT_ESTADO_USUARIO" ("COD_ESTADO_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_MODO_PAGO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_MODO_PAGO" ON "UCM"."JRGY_CAT_MODO_PAGO" ("COD_MODO_PAGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_TIPO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_TIPO_HABITACION" ON "UCM"."JRGY_CAT_TIPO_HABITACION" ("COD_TIPO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_TIPO_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_TIPO_SERVICIO" ON "UCM"."JRGY_CAT_TIPO_SERVICIO" ("COD_TIPO_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CIUDAD
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CIUDAD" ON "UCM"."JRGY_CIUDAD" ("COD_CIUDAD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CLIENTE
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CLIENTE" ON "UCM"."JRGY_CLIENTE" ("COD_CLIENTE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_COMUNA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_COMUNA" ON "UCM"."JRGY_COMUNA" ("COD_COMUNA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DEP_EMP
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DEP_EMP" ON "UCM"."JRGY_DEPARTAMENTO_EMPLEADO" ("COD_DEPARTAMENTO", "COD_EMPLEADO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DETALLE_PAGO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DETALLE_PAGO_HABITACION" ON "UCM"."JRGY_DETALLE_PAGO_HABITACION" ("COD_PAGO_HABITACION", "COD_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DETALLE_PEDIDO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DETALLE_PEDIDO" ON "UCM"."JRGY_DETALLE_PEDIDO" ("COD_PEDIDO", "COD_PROVEEDOR", "COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DETALLE_VENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DETALLE_VENTA" ON "UCM"."JRGY_DETALLE_VENTA" ("COD_VENTA", "COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EMP_HAB
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EMP_HAB" ON "UCM"."JRGY_EMPLEADO_HABILIDAD" ("COD_EMPLEADO", "CATEGORIA", "TIPO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EMPLEADO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EMPLEADO" ON "UCM"."JRGY_EMPLEADO" ("COD_EMPLEADO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EVENTO_RESERVA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EVENTO_RESERVA" ON "UCM"."JRGY_EVENTO_RESERVA" ("COD_EVENTO_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EXPERIENCIA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EXPERIENCIA" ON "UCM"."JRGY_EXPERIENCIA" ("COD_EXPERIENCIA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_HABITACION" ON "UCM"."JRGY_HABITACION" ("COD_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_MOVIMIENTO_STOCK
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_MOVIMIENTO_STOCK" ON "UCM"."JRGY_MOVIMIENTO_STOCK" ("COD_MOVIMIENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PAGO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PAGO_HABITACION" ON "UCM"."JRGY_PAGO_HABITACION" ("COD_PAGO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PAGO_VENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PAGO_VENTA" ON "UCM"."JRGY_PAGO_VENTA" ("COD_PAGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PEDIDO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PEDIDO" ON "UCM"."JRGY_PEDIDO" ("COD_PEDIDO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PRODUCTO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PRODUCTO" ON "UCM"."JRGY_PRODUCTO" ("COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PROVEEDOR
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PROVEEDOR" ON "UCM"."JRGY_PROVEEDOR" ("COD_PROVEEDOR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_REGION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_REGION" ON "UCM"."JRGY_REGION" ("COD_REGION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_RESERVA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_RESERVA" ON "UCM"."JRGY_RESERVA" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_RESERVA_EXP
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_RESERVA_EXP" ON "UCM"."JRGY_RESERVA_EXP" ("COD_RESERVA_EXP") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_RESERVA_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_RESERVA_SERVICIO" ON "UCM"."JRGY_RESERVA_SERVICIO" ("COD_RESERVA_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_ROL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_ROL" ON "UCM"."JRGY_ROL" ("COD_ROL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO" ON "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO_HORARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO_HORARIO" ON "UCM"."JRGY_SERVICIO_HORARIO" ("COD_HORARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO_PAQUETE
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO_PAQUETE" ON "UCM"."JRGY_SERVICIO_PAQUETE" ("COD_PAQUETE", "COD_SERVICIO_INCL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO_PRODUCTO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO_PRODUCTO" ON "UCM"."JRGY_SERVICIO_PRODUCTO" ("COD_SERVICIO", "COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SOLICITUD_ADMIN
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SOLICITUD_ADMIN" ON "UCM"."JRGY_SOLICITUD_ADMIN" ("COD_SOLICITUD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_USUARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_USUARIO" ON "UCM"."JRGY_USUARIO" ("COD_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_USUARIO_ROL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_USUARIO_ROL" ON "UCM"."JRGY_USUARIO_ROL" ("COD_USUARIO", "COD_ROL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_VENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_VENTA" ON "UCM"."JRGY_VENTA" ("COD_VENTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TOKENS
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_TOKENS" ON "UCM"."TOKENS" ("TOKEN") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C0012452
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."SYS_C0012452" ON "UCM"."ANNOTATIONS_GROUPS$" ("GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C0012784
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."SYS_C0012784" ON "UCM"."JRGY_DEPARTAMENTO" ("COD_DEPARTAMENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UC_GROUP_MEMBER
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UC_GROUP_MEMBER" ON "UCM"."ANNOTATIONS_GROUPS$" ("GROUP_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UNIQUE_ANNOTATION_ENFORCER
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UNIQUE_ANNOTATION_ENFORCER" ON "UCM"."ANNOTATIONS_USAGE$" ("OBJ#", "OBJECT_OWNER", "ANNOTATION_TYPE", "ANNOTATION_NAME", "COLUMN_NAME", "FUNCTION_NAME", "PROCEDURE_NAME", "GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UNIQUE_GROUP_MEMBER
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UNIQUE_GROUP_MEMBER" ON "UCM"."ANNOTATIONS_GROUP_MEMBERS$" ("GROUP_ID", "OBJ#", "OBJECT_OWNER", "ANNOTATION_TYPE", "COLUMN_NAME", "FUNCTION_NAME", "PROCEDURE_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UNIQUE_PREBUILT_ANNOTATIONS
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UNIQUE_PREBUILT_ANNOTATIONS" ON "UCM"."ANNOTATIONS_PREBUILT$" ("ANNOTATION_NAME", "CATEGORY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 125 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_JRGY_CAT_TIPO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UQ_JRGY_CAT_TIPO_HABITACION" ON "UCM"."JRGY_CAT_TIPO_HABITACION" ("TIPO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_JRGY_CAT_TIPO_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UQ_JRGY_CAT_TIPO_SERVICIO" ON "UCM"."JRGY_CAT_TIPO_SERVICIO" ("NOMBRE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UNIQUE_GROUP_MEMBER
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UNIQUE_GROUP_MEMBER" ON "UCM"."ANNOTATIONS_GROUP_MEMBERS$" ("GROUP_ID", "OBJ#", "OBJECT_OWNER", "ANNOTATION_TYPE", "COLUMN_NAME", "FUNCTION_NAME", "PROCEDURE_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C0012452
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."SYS_C0012452" ON "UCM"."ANNOTATIONS_GROUPS$" ("GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UC_GROUP_MEMBER
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UC_GROUP_MEMBER" ON "UCM"."ANNOTATIONS_GROUPS$" ("GROUP_NAME") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UNIQUE_PREBUILT_ANNOTATIONS
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UNIQUE_PREBUILT_ANNOTATIONS" ON "UCM"."ANNOTATIONS_PREBUILT$" ("ANNOTATION_NAME", "CATEGORY") 
  PCTFREE 10 INITRANS 2 MAXTRANS 125 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UNIQUE_ANNOTATION_ENFORCER
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UNIQUE_ANNOTATION_ENFORCER" ON "UCM"."ANNOTATIONS_USAGE$" ("OBJ#", "OBJECT_OWNER", "ANNOTATION_TYPE", "ANNOTATION_NAME", "COLUMN_NAME", "FUNCTION_NAME", "PROCEDURE_NAME", "GROUP_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CALLE
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CALLE" ON "UCM"."JRGY_CALLE" ("COD_CALLE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_HABITACION" ON "UCM"."JRGY_CAT_ESTADO_HABITACION" ("COD_ESTADO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_LABORAL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_LABORAL" ON "UCM"."JRGY_CAT_ESTADO_LABORAL" ("COD_ESTADO_LABORAL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_RESERVA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_RESERVA" ON "UCM"."JRGY_CAT_ESTADO_RESERVA" ("COD_ESTADO_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_ESTADO_USUARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_ESTADO_USUARIO" ON "UCM"."JRGY_CAT_ESTADO_USUARIO" ("COD_ESTADO_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_MODO_PAGO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_MODO_PAGO" ON "UCM"."JRGY_CAT_MODO_PAGO" ("COD_MODO_PAGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_TIPO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_TIPO_HABITACION" ON "UCM"."JRGY_CAT_TIPO_HABITACION" ("COD_TIPO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_JRGY_CAT_TIPO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UQ_JRGY_CAT_TIPO_HABITACION" ON "UCM"."JRGY_CAT_TIPO_HABITACION" ("TIPO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CAT_TIPO_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CAT_TIPO_SERVICIO" ON "UCM"."JRGY_CAT_TIPO_SERVICIO" ("COD_TIPO_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index UQ_JRGY_CAT_TIPO_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."UQ_JRGY_CAT_TIPO_SERVICIO" ON "UCM"."JRGY_CAT_TIPO_SERVICIO" ("NOMBRE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CIUDAD
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CIUDAD" ON "UCM"."JRGY_CIUDAD" ("COD_CIUDAD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_CLIENTE
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_CLIENTE" ON "UCM"."JRGY_CLIENTE" ("COD_CLIENTE") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_COMUNA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_COMUNA" ON "UCM"."JRGY_COMUNA" ("COD_COMUNA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index SYS_C0012784
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."SYS_C0012784" ON "UCM"."JRGY_DEPARTAMENTO" ("COD_DEPARTAMENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DEP_EMP
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DEP_EMP" ON "UCM"."JRGY_DEPARTAMENTO_EMPLEADO" ("COD_DEPARTAMENTO", "COD_EMPLEADO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DETALLE_PAGO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DETALLE_PAGO_HABITACION" ON "UCM"."JRGY_DETALLE_PAGO_HABITACION" ("COD_PAGO_HABITACION", "COD_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DETALLE_PEDIDO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DETALLE_PEDIDO" ON "UCM"."JRGY_DETALLE_PEDIDO" ("COD_PEDIDO", "COD_PROVEEDOR", "COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_DETALLE_VENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_DETALLE_VENTA" ON "UCM"."JRGY_DETALLE_VENTA" ("COD_VENTA", "COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EMPLEADO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EMPLEADO" ON "UCM"."JRGY_EMPLEADO" ("COD_EMPLEADO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EMP_HAB
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EMP_HAB" ON "UCM"."JRGY_EMPLEADO_HABILIDAD" ("COD_EMPLEADO", "CATEGORIA", "TIPO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_EVENTO_RESERVA_RES
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_EVENTO_RESERVA_RES" ON "UCM"."JRGY_EVENTO_RESERVA" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EVENTO_RESERVA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EVENTO_RESERVA" ON "UCM"."JRGY_EVENTO_RESERVA" ("COD_EVENTO_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_EXPERIENCIA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_EXPERIENCIA" ON "UCM"."JRGY_EXPERIENCIA" ("COD_EXPERIENCIA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_HABITACION" ON "UCM"."JRGY_HABITACION" ("COD_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_MOVIMIENTO_STOCK
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_MOVIMIENTO_STOCK" ON "UCM"."JRGY_MOVIMIENTO_STOCK" ("COD_MOVIMIENTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PAGO_HABITACION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PAGO_HABITACION" ON "UCM"."JRGY_PAGO_HABITACION" ("COD_PAGO_HABITACION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PAGO_VENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PAGO_VENTA" ON "UCM"."JRGY_PAGO_VENTA" ("COD_PAGO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PEDIDO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PEDIDO" ON "UCM"."JRGY_PEDIDO" ("COD_PEDIDO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PRODUCTO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PRODUCTO" ON "UCM"."JRGY_PRODUCTO" ("COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_PROVEEDOR
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_PROVEEDOR" ON "UCM"."JRGY_PROVEEDOR" ("COD_PROVEEDOR") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_REGION
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_REGION" ON "UCM"."JRGY_REGION" ("COD_REGION") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_RESERVA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_RESERVA" ON "UCM"."JRGY_RESERVA" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_USUARIO
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_USUARIO" ON "UCM"."JRGY_RESERVA" ("COD_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_HAB
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_HAB" ON "UCM"."JRGY_RESERVA" ("COD_HABITACION", "FECHA_INICIO", "FECHA_FIN") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_RESERVA_EXP
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_RESERVA_EXP" ON "UCM"."JRGY_RESERVA_EXP" ("COD_RESERVA_EXP") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_EXP_RES
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_EXP_RES" ON "UCM"."JRGY_RESERVA_EXP" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RESERVA_EXP_EXP
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RESERVA_EXP_EXP" ON "UCM"."JRGY_RESERVA_EXP" ("COD_EXPERIENCIA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_RESERVA_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_RESERVA_SERVICIO" ON "UCM"."JRGY_RESERVA_SERVICIO" ("COD_RESERVA_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RES_SERV_RES
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RES_SERV_RES" ON "UCM"."JRGY_RESERVA_SERVICIO" ("COD_RESERVA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_RES_SERV_SERV
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_RES_SERV_SERV" ON "UCM"."JRGY_RESERVA_SERVICIO" ("COD_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_ROL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_ROL" ON "UCM"."JRGY_ROL" ("COD_ROL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO" ON "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO_HORARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO_HORARIO" ON "UCM"."JRGY_SERVICIO_HORARIO" ("COD_HORARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO_PAQUETE
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO_PAQUETE" ON "UCM"."JRGY_SERVICIO_PAQUETE" ("COD_PAQUETE", "COD_SERVICIO_INCL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SERVICIO_PRODUCTO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SERVICIO_PRODUCTO" ON "UCM"."JRGY_SERVICIO_PRODUCTO" ("COD_SERVICIO", "COD_PRODUCTO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_SOLICITUD_ADMIN
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_SOLICITUD_ADMIN" ON "UCM"."JRGY_SOLICITUD_ADMIN" ("COD_SOLICITUD") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_JRGY_SOLICITUD_USUARIO
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_JRGY_SOLICITUD_USUARIO" ON "UCM"."JRGY_SOLICITUD_ADMIN" ("COD_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_USUARIO
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_USUARIO" ON "UCM"."JRGY_USUARIO" ("COD_USUARIO") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_USUARIO_ROL
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_USUARIO_ROL" ON "UCM"."JRGY_USUARIO_ROL" ("COD_USUARIO", "COD_ROL") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_JRGY_VENTA
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_JRGY_VENTA" ON "UCM"."JRGY_VENTA" ("COD_VENTA") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index PK_TOKENS
--------------------------------------------------------

  CREATE UNIQUE INDEX "UCM"."PK_TOKENS" ON "UCM"."TOKENS" ("TOKEN") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Index IDX_TOKENS_USER
--------------------------------------------------------

  CREATE INDEX "UCM"."IDX_TOKENS_USER" ON "UCM"."TOKENS" ("USER_ID") 
  PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS" ;
--------------------------------------------------------
--  DDL for Trigger TRG_CAT_TIPO_HAB_MAYUS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_CAT_TIPO_HAB_MAYUS" 
    BEFORE INSERT OR UPDATE ON JRGY_CAT_TIPO_HABITACION
    FOR EACH ROW
BEGIN
    :NEW.TIPO_HABITACION := UPPER(TRIM(:NEW.TIPO_HABITACION));
END;
/
ALTER TRIGGER "UCM"."TRG_CAT_TIPO_HAB_MAYUS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_HAB_LIBRE_ON_DETALLE_DEL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_HAB_LIBRE_ON_DETALLE_DEL" 
    AFTER DELETE ON JRGY_DETALLE_PAGO_HABITACION
    FOR EACH ROW
BEGIN
    UPDATE JRGY_HABITACION
    SET COD_ESTADO_HABITACION = (
        SELECT COD_ESTADO_HABITACION
        FROM JRGY_CAT_ESTADO_HABITACION
        WHERE UPPER(ESTADO_HABITACION) = 'LIBRE'
    )
    WHERE COD_HABITACION = :OLD.COD_HABITACION;
END;
/
ALTER TRIGGER "UCM"."TRG_HAB_LIBRE_ON_DETALLE_DEL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_HAB_OCUPADA_ON_DETALLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_HAB_OCUPADA_ON_DETALLE" 
    AFTER INSERT ON JRGY_DETALLE_PAGO_HABITACION
    FOR EACH ROW
BEGIN
    UPDATE JRGY_HABITACION
    SET COD_ESTADO_HABITACION = (
        SELECT COD_ESTADO_HABITACION
        FROM JRGY_CAT_ESTADO_HABITACION
        WHERE UPPER(ESTADO_HABITACION) = 'OCUPADA'
    )
    WHERE COD_HABITACION = :NEW.COD_HABITACION;
END;
/
ALTER TRIGGER "UCM"."TRG_HAB_OCUPADA_ON_DETALLE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_MISMA_PK_EMPLEADO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_MISMA_PK_EMPLEADO" BEFORE INSERT ON JRGY_EMPLEADO FOR EACH ROW
DECLARE V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_EMPLEADO WHERE COD_EMPLEADO = :NEW.COD_EMPLEADO;
    IF V_COUNT > 0 THEN RAISE_APPLICATION_ERROR(-2002, 'YA EXISTE EL EMPLEADO'); END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_MISMA_PK_EMPLEADO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_MISMA_PK_PRODUCTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_MISMA_PK_PRODUCTO" BEFORE INSERT ON JRGY_PRODUCTO FOR EACH ROW
DECLARE V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = :NEW.COD_PRODUCTO;
    IF V_COUNT > 0 THEN RAISE_APPLICATION_ERROR(-2003, 'YA EXISTE EL PRODUCTO'); END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_MISMA_PK_PRODUCTO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_CAT_TIPO_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_CAT_TIPO_HAB" BEFORE INSERT ON JRGY_CAT_TIPO_HABITACION FOR EACH ROW
BEGIN IF :NEW.COD_TIPO_HABITACION IS NULL THEN :NEW.COD_TIPO_HABITACION := SQ_PK_CAT_TIPO_HAB.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_CAT_TIPO_HAB" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_CAT_TIPO_SERV
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_CAT_TIPO_SERV" BEFORE INSERT ON JRGY_CAT_TIPO_SERVICIO FOR EACH ROW
BEGIN IF :NEW.COD_TIPO_SERVICIO IS NULL THEN :NEW.COD_TIPO_SERVICIO := SQ_PK_CAT_TIPO_SERV.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_CAT_TIPO_SERV" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_CLIENTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_CLIENTE" BEFORE INSERT ON JRGY_CLIENTE FOR EACH ROW
BEGIN IF :NEW.COD_CLIENTE IS NULL THEN :NEW.COD_CLIENTE := SQ_PK_CLIENTE.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_CLIENTE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_DEPARTAMENTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_DEPARTAMENTO" BEFORE INSERT ON JRGY_DEPARTAMENTO FOR EACH ROW
BEGIN
    IF :NEW.COD_DEPARTAMENTO IS NULL THEN
        :NEW.COD_DEPARTAMENTO := SQ_PK_DEPARTAMENTO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_DEPARTAMENTO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_EMPLEADO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_EMPLEADO" BEFORE INSERT ON JRGY_EMPLEADO FOR EACH ROW
BEGIN IF :NEW.COD_EMPLEADO IS NULL THEN :NEW.COD_EMPLEADO := SQ_PK_EMPLEADO.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_EMPLEADO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_EVENTO_RESERVA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_EVENTO_RESERVA" BEFORE INSERT ON JRGY_EVENTO_RESERVA FOR EACH ROW
BEGIN IF :NEW.COD_EVENTO_RESERVA IS NULL THEN :NEW.COD_EVENTO_RESERVA := SQ_PK_EVENTO_RESERVA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_EVENTO_RESERVA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_EXPERIENCIA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_EXPERIENCIA" BEFORE INSERT ON JRGY_EXPERIENCIA FOR EACH ROW
BEGIN
    IF :NEW.COD_EXPERIENCIA IS NULL THEN
        :NEW.COD_EXPERIENCIA := SQ_PK_EXPERIENCIA.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_EXPERIENCIA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_HABITACION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_HABITACION" BEFORE INSERT ON JRGY_HABITACION FOR EACH ROW
BEGIN IF :NEW.COD_HABITACION IS NULL THEN :NEW.COD_HABITACION := SQ_PK_HABITACION.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_HABITACION" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_MOVIMIENTO_STOCK
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_MOVIMIENTO_STOCK" BEFORE INSERT ON JRGY_MOVIMIENTO_STOCK FOR EACH ROW
BEGIN IF :NEW.COD_MOVIMIENTO IS NULL THEN :NEW.COD_MOVIMIENTO := SQ_PK_MOVIMIENTO_STOCK.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_MOVIMIENTO_STOCK" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PAGO_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PAGO_HAB" BEFORE INSERT ON JRGY_PAGO_HABITACION FOR EACH ROW
BEGIN IF :NEW.COD_PAGO_HABITACION IS NULL THEN :NEW.COD_PAGO_HABITACION := SQ_PK_PAGO_HAB.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_PAGO_HAB" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PAGO_VENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PAGO_VENTA" BEFORE INSERT ON JRGY_PAGO_VENTA FOR EACH ROW
BEGIN IF :NEW.COD_PAGO IS NULL THEN :NEW.COD_PAGO := SQ_PK_PAGO_VENTA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_PAGO_VENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PEDIDO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PEDIDO" BEFORE INSERT ON JRGY_PEDIDO FOR EACH ROW
BEGIN
    IF :NEW.COD_PEDIDO IS NULL THEN
        :NEW.COD_PEDIDO := SQ_PK_PEDIDO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_PEDIDO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PRODUCTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PRODUCTO" BEFORE INSERT ON JRGY_PRODUCTO FOR EACH ROW
BEGIN IF :NEW.COD_PRODUCTO IS NULL THEN :NEW.COD_PRODUCTO := SQ_PK_PRODUCTO.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_PRODUCTO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PROVEEDOR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PROVEEDOR" 
        BEFORE INSERT ON JRGY_PROVEEDOR
        FOR EACH ROW
        BEGIN
            IF :NEW.COD_PROVEEDOR IS NULL THEN
                :NEW.COD_PROVEEDOR := SQ_PK_PROVEEDOR.NEXTVAL;
            END IF;
        END;
/
ALTER TRIGGER "UCM"."TRG_PK_PROVEEDOR" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_RESERVA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_RESERVA" BEFORE INSERT ON JRGY_RESERVA FOR EACH ROW
BEGIN IF :NEW.COD_RESERVA IS NULL THEN :NEW.COD_RESERVA := SQ_PK_RESERVA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_RESERVA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_RESERVA_EXP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_RESERVA_EXP" BEFORE INSERT ON JRGY_RESERVA_EXP FOR EACH ROW
BEGIN
    IF :NEW.COD_RESERVA_EXP IS NULL THEN
        :NEW.COD_RESERVA_EXP := SQ_PK_RESERVA_EXP.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_RESERVA_EXP" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_RESERVA_SERVICIO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_RESERVA_SERVICIO" BEFORE INSERT ON JRGY_RESERVA_SERVICIO FOR EACH ROW
BEGIN
    IF :NEW.COD_RESERVA_SERVICIO IS NULL THEN
        :NEW.COD_RESERVA_SERVICIO := SQ_PK_RESERVA_SERVICIO.NEXTVAL;
    END IF;
    IF :NEW.TOTAL IS NULL THEN
        :NEW.TOTAL := NVL(:NEW.CANTIDAD, 0) * NVL(:NEW.PRECIO_UNIT, 0);
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_RESERVA_SERVICIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_ROL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_ROL" BEFORE INSERT ON JRGY_ROL FOR EACH ROW
BEGIN IF :NEW.COD_ROL IS NULL THEN :NEW.COD_ROL := SQ_PK_ROL.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_ROL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_SERVICIO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_SERVICIO" BEFORE INSERT ON JRGY_SERVICIO FOR EACH ROW
BEGIN
    IF :NEW.COD_SERVICIO IS NULL THEN
        :NEW.COD_SERVICIO := SQ_PK_SERVICIO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_SERVICIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_SERVICIO_HORARIO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_SERVICIO_HORARIO" BEFORE INSERT ON JRGY_SERVICIO_HORARIO FOR EACH ROW
BEGIN
    IF :NEW.COD_HORARIO IS NULL THEN
        :NEW.COD_HORARIO := SQ_PK_SERVICIO_HORARIO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_SERVICIO_HORARIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_SOLICITUD_ADMIN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_SOLICITUD_ADMIN" BEFORE INSERT ON JRGY_SOLICITUD_ADMIN FOR EACH ROW
BEGIN IF :NEW.COD_SOLICITUD IS NULL THEN :NEW.COD_SOLICITUD := SQ_PK_SOLICITUD_ADMIN.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_SOLICITUD_ADMIN" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_VENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_VENTA" BEFORE INSERT ON JRGY_VENTA FOR EACH ROW
BEGIN IF :NEW.COD_VENTA IS NULL THEN :NEW.COD_VENTA := SQ_PK_VENTA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_VENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_RESERVA_NO_OVERLAP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_RESERVA_NO_OVERLAP" 
    BEFORE INSERT OR UPDATE ON JRGY_RESERVA
    FOR EACH ROW
DECLARE
    v_current_id NUMBER := NVL(:NEW.COD_RESERVA, :OLD.COD_RESERVA);
    v_dummy NUMBER;
BEGIN
    -- Si solo cambia estado u otros campos sin modificar fechas ni habitaciÔøΩÔøΩn, omite validaciÔøΩÔøΩn.
    IF UPDATING
       AND :NEW.COD_HABITACION = :OLD.COD_HABITACION
       AND :NEW.FECHA_INICIO = :OLD.FECHA_INICIO
       AND :NEW.FECHA_FIN = :OLD.FECHA_FIN THEN
        RETURN;
    END IF;

    -- Validacion de fechas
    IF :NEW.FECHA_FIN < :NEW.FECHA_INICIO THEN
        RAISE_APPLICATION_ERROR(-20060, 'La fecha fin debe ser mayor o igual a la de inicio');
    END IF;

    -- Evita solapes de reservas en la misma habitacion
    BEGIN
        SELECT 1
        INTO v_dummy
        FROM JRGY_RESERVA
        WHERE COD_HABITACION = :NEW.COD_HABITACION
          AND (:NEW.FECHA_INICIO <= FECHA_FIN AND :NEW.FECHA_FIN >= FECHA_INICIO)
          AND (v_current_id IS NULL OR COD_RESERVA <> v_current_id)
        FOR UPDATE NOWAIT;

        RAISE_APPLICATION_ERROR(-20061, 'La habitacion ya esta reservada en ese rango de fechas');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
        WHEN OTHERS THEN
            IF SQLCODE = -54 THEN
                RAISE_APPLICATION_ERROR(-20062, 'Reserva en curso para esta habitacion, intenta de nuevo');
            ELSE
                RAISE;
            END IF;
    END;
END;
/
ALTER TRIGGER "UCM"."TRG_RESERVA_NO_OVERLAP" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_RESERVA_SERVICIO_TOTAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_RESERVA_SERVICIO_TOTAL" 
    BEFORE INSERT OR UPDATE ON JRGY_RESERVA_SERVICIO
    FOR EACH ROW
BEGIN
    :NEW.TOTAL := NVL(:NEW.CANTIDAD, 0) * NVL(:NEW.PRECIO_UNIT, 0);
    :NEW.UPDATED_AT := SYSDATE;
END;
/
ALTER TRIGGER "UCM"."TRG_RESERVA_SERVICIO_TOTAL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_RESERVA_SYNC_ESTADO_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_RESERVA_SYNC_ESTADO_HAB" 
    FOR INSERT OR UPDATE OF COD_ESTADO_RESERVA ON JRGY_RESERVA
COMPOUND TRIGGER
    TYPE t_row IS RECORD (
        cod_reserva    NUMBER,
        cod_habitacion NUMBER,
        cod_usuario    NUMBER,
        cod_estado     NUMBER
    );
    TYPE t_tab IS TABLE OF t_row INDEX BY PLS_INTEGER;
    g_rows t_tab;

    AFTER EACH ROW IS
    BEGIN
        g_rows(g_rows.COUNT + 1) := t_row(:NEW.COD_RESERVA, :NEW.COD_HABITACION, :NEW.COD_USUARIO, :NEW.COD_ESTADO_RESERVA);
    END AFTER EACH ROW;

    AFTER STATEMENT IS
        v_est_en_proceso   NUMBER;
        v_est_finalizada   NUMBER;
        v_est_cancelada    NUMBER;
        v_est_checkout_sol NUMBER;
        v_hab_ocupada      NUMBER;
        v_hab_libre        NUMBER;
    BEGIN
        IF g_rows.COUNT > 0 THEN
            SELECT COD_ESTADO_RESERVA INTO v_est_en_proceso
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'EN PROCESO';

            SELECT COD_ESTADO_RESERVA INTO v_est_finalizada
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'FINALIZADA';

            SELECT COD_ESTADO_RESERVA INTO v_est_cancelada
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CANCELADA';

            SELECT COD_ESTADO_RESERVA INTO v_est_checkout_sol
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CHECKOUT SOLICITADO';

            SELECT COD_ESTADO_HABITACION INTO v_hab_ocupada
            FROM JRGY_CAT_ESTADO_HABITACION
            WHERE REPLACE(UPPER(ESTADO_HABITACION), '_', ' ') = 'OCUPADA';

            SELECT COD_ESTADO_HABITACION INTO v_hab_libre
            FROM JRGY_CAT_ESTADO_HABITACION
            WHERE REPLACE(UPPER(ESTADO_HABITACION), '_', ' ') = 'LIBRE';

            FOR i IN g_rows.FIRST .. g_rows.LAST LOOP
                IF g_rows.EXISTS(i) THEN
                    IF g_rows(i).cod_estado = v_est_en_proceso THEN
                        UPDATE JRGY_HABITACION
                        SET COD_ESTADO_HABITACION = v_hab_ocupada,
                            COD_USUARIO_OCUPANTE = g_rows(i).cod_usuario
                        WHERE COD_HABITACION = g_rows(i).cod_habitacion;
                    ELSIF g_rows(i).cod_estado IN (v_est_finalizada, v_est_cancelada) THEN
                        DECLARE
                            v_activos NUMBER := FN_RESERVAS_ACTIVAS_HAB(
                                g_rows(i).cod_habitacion,
                                g_rows(i).cod_reserva,
                                v_est_en_proceso,
                                v_est_checkout_sol
                            );
                        BEGIN
                            IF v_activos = 0 THEN
                                UPDATE JRGY_HABITACION
                                SET COD_ESTADO_HABITACION = v_hab_libre,
                                    COD_USUARIO_OCUPANTE = NULL
                                WHERE COD_HABITACION = g_rows(i).cod_habitacion;
                            END IF;
                        END;
                    END IF;
                END IF;
            END LOOP;
        END IF;
    END AFTER STATEMENT;
END;
/
ALTER TRIGGER "UCM"."TRG_RESERVA_SYNC_ESTADO_HAB" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SERVICIO_UPDATED_AT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_SERVICIO_UPDATED_AT" 
    BEFORE UPDATE ON JRGY_SERVICIO
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := SYSDATE;
END;
/
ALTER TRIGGER "UCM"."TRG_SERVICIO_UPDATED_AT" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_VALIDA_STOCK_VENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_VALIDA_STOCK_VENTA" 
    BEFORE INSERT OR UPDATE ON JRGY_DETALLE_VENTA
    FOR EACH ROW
DECLARE
    V_STOCK NUMBER;
BEGIN
    SELECT NVL(STOCK_PRODUCTO,0) INTO V_STOCK FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = :NEW.COD_PRODUCTO;
    IF :NEW.CANTIDAD > V_STOCK THEN
        RAISE_APPLICATION_ERROR(-20050, 'STOCK INSUFICIENTE PARA PRODUCTO ' || :NEW.COD_PRODUCTO);
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_VALIDA_STOCK_VENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_CAT_TIPO_HAB_MAYUS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_CAT_TIPO_HAB_MAYUS" 
    BEFORE INSERT OR UPDATE ON JRGY_CAT_TIPO_HABITACION
    FOR EACH ROW
BEGIN
    :NEW.TIPO_HABITACION := UPPER(TRIM(:NEW.TIPO_HABITACION));
END;
/
ALTER TRIGGER "UCM"."TRG_CAT_TIPO_HAB_MAYUS" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_CAT_TIPO_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_CAT_TIPO_HAB" BEFORE INSERT ON JRGY_CAT_TIPO_HABITACION FOR EACH ROW
BEGIN IF :NEW.COD_TIPO_HABITACION IS NULL THEN :NEW.COD_TIPO_HABITACION := SQ_PK_CAT_TIPO_HAB.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_CAT_TIPO_HAB" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_CAT_TIPO_SERV
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_CAT_TIPO_SERV" BEFORE INSERT ON JRGY_CAT_TIPO_SERVICIO FOR EACH ROW
BEGIN IF :NEW.COD_TIPO_SERVICIO IS NULL THEN :NEW.COD_TIPO_SERVICIO := SQ_PK_CAT_TIPO_SERV.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_CAT_TIPO_SERV" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_CLIENTE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_CLIENTE" BEFORE INSERT ON JRGY_CLIENTE FOR EACH ROW
BEGIN IF :NEW.COD_CLIENTE IS NULL THEN :NEW.COD_CLIENTE := SQ_PK_CLIENTE.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_CLIENTE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_DEPARTAMENTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_DEPARTAMENTO" BEFORE INSERT ON JRGY_DEPARTAMENTO FOR EACH ROW
BEGIN
    IF :NEW.COD_DEPARTAMENTO IS NULL THEN
        :NEW.COD_DEPARTAMENTO := SQ_PK_DEPARTAMENTO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_DEPARTAMENTO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_HAB_OCUPADA_ON_DETALLE
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_HAB_OCUPADA_ON_DETALLE" 
    AFTER INSERT ON JRGY_DETALLE_PAGO_HABITACION
    FOR EACH ROW
BEGIN
    UPDATE JRGY_HABITACION
    SET COD_ESTADO_HABITACION = (
        SELECT COD_ESTADO_HABITACION
        FROM JRGY_CAT_ESTADO_HABITACION
        WHERE UPPER(ESTADO_HABITACION) = 'OCUPADA'
    )
    WHERE COD_HABITACION = :NEW.COD_HABITACION;
END;
/
ALTER TRIGGER "UCM"."TRG_HAB_OCUPADA_ON_DETALLE" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_HAB_LIBRE_ON_DETALLE_DEL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_HAB_LIBRE_ON_DETALLE_DEL" 
    AFTER DELETE ON JRGY_DETALLE_PAGO_HABITACION
    FOR EACH ROW
BEGIN
    UPDATE JRGY_HABITACION
    SET COD_ESTADO_HABITACION = (
        SELECT COD_ESTADO_HABITACION
        FROM JRGY_CAT_ESTADO_HABITACION
        WHERE UPPER(ESTADO_HABITACION) = 'LIBRE'
    )
    WHERE COD_HABITACION = :OLD.COD_HABITACION;
END;
/
ALTER TRIGGER "UCM"."TRG_HAB_LIBRE_ON_DETALLE_DEL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_VALIDA_STOCK_VENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_VALIDA_STOCK_VENTA" 
    BEFORE INSERT OR UPDATE ON JRGY_DETALLE_VENTA
    FOR EACH ROW
DECLARE
    V_STOCK NUMBER;
BEGIN
    SELECT NVL(STOCK_PRODUCTO,0) INTO V_STOCK FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = :NEW.COD_PRODUCTO;
    IF :NEW.CANTIDAD > V_STOCK THEN
        RAISE_APPLICATION_ERROR(-20050, 'STOCK INSUFICIENTE PARA PRODUCTO ' || :NEW.COD_PRODUCTO);
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_VALIDA_STOCK_VENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_EMPLEADO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_EMPLEADO" BEFORE INSERT ON JRGY_EMPLEADO FOR EACH ROW
BEGIN IF :NEW.COD_EMPLEADO IS NULL THEN :NEW.COD_EMPLEADO := SQ_PK_EMPLEADO.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_EMPLEADO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_MISMA_PK_EMPLEADO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_MISMA_PK_EMPLEADO" BEFORE INSERT ON JRGY_EMPLEADO FOR EACH ROW
DECLARE V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_EMPLEADO WHERE COD_EMPLEADO = :NEW.COD_EMPLEADO;
    IF V_COUNT > 0 THEN RAISE_APPLICATION_ERROR(-2002, 'YA EXISTE EL EMPLEADO'); END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_MISMA_PK_EMPLEADO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_EVENTO_RESERVA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_EVENTO_RESERVA" BEFORE INSERT ON JRGY_EVENTO_RESERVA FOR EACH ROW
BEGIN IF :NEW.COD_EVENTO_RESERVA IS NULL THEN :NEW.COD_EVENTO_RESERVA := SQ_PK_EVENTO_RESERVA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_EVENTO_RESERVA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_EXPERIENCIA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_EXPERIENCIA" BEFORE INSERT ON JRGY_EXPERIENCIA FOR EACH ROW
BEGIN
    IF :NEW.COD_EXPERIENCIA IS NULL THEN
        :NEW.COD_EXPERIENCIA := SQ_PK_EXPERIENCIA.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_EXPERIENCIA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_HABITACION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_HABITACION" BEFORE INSERT ON JRGY_HABITACION FOR EACH ROW
BEGIN IF :NEW.COD_HABITACION IS NULL THEN :NEW.COD_HABITACION := SQ_PK_HABITACION.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_HABITACION" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_MOVIMIENTO_STOCK
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_MOVIMIENTO_STOCK" BEFORE INSERT ON JRGY_MOVIMIENTO_STOCK FOR EACH ROW
BEGIN IF :NEW.COD_MOVIMIENTO IS NULL THEN :NEW.COD_MOVIMIENTO := SQ_PK_MOVIMIENTO_STOCK.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_MOVIMIENTO_STOCK" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PAGO_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PAGO_HAB" BEFORE INSERT ON JRGY_PAGO_HABITACION FOR EACH ROW
BEGIN IF :NEW.COD_PAGO_HABITACION IS NULL THEN :NEW.COD_PAGO_HABITACION := SQ_PK_PAGO_HAB.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_PAGO_HAB" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PAGO_VENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PAGO_VENTA" BEFORE INSERT ON JRGY_PAGO_VENTA FOR EACH ROW
BEGIN IF :NEW.COD_PAGO IS NULL THEN :NEW.COD_PAGO := SQ_PK_PAGO_VENTA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_PAGO_VENTA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PEDIDO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PEDIDO" BEFORE INSERT ON JRGY_PEDIDO FOR EACH ROW
BEGIN
    IF :NEW.COD_PEDIDO IS NULL THEN
        :NEW.COD_PEDIDO := SQ_PK_PEDIDO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_PEDIDO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PRODUCTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PRODUCTO" BEFORE INSERT ON JRGY_PRODUCTO FOR EACH ROW
BEGIN IF :NEW.COD_PRODUCTO IS NULL THEN :NEW.COD_PRODUCTO := SQ_PK_PRODUCTO.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_PRODUCTO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_MISMA_PK_PRODUCTO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_MISMA_PK_PRODUCTO" BEFORE INSERT ON JRGY_PRODUCTO FOR EACH ROW
DECLARE V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = :NEW.COD_PRODUCTO;
    IF V_COUNT > 0 THEN RAISE_APPLICATION_ERROR(-2003, 'YA EXISTE EL PRODUCTO'); END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_MISMA_PK_PRODUCTO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_PROVEEDOR
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_PROVEEDOR" 
        BEFORE INSERT ON JRGY_PROVEEDOR
        FOR EACH ROW
        BEGIN
            IF :NEW.COD_PROVEEDOR IS NULL THEN
                :NEW.COD_PROVEEDOR := SQ_PK_PROVEEDOR.NEXTVAL;
            END IF;
        END;
/
ALTER TRIGGER "UCM"."TRG_PK_PROVEEDOR" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_RESERVA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_RESERVA" BEFORE INSERT ON JRGY_RESERVA FOR EACH ROW
BEGIN IF :NEW.COD_RESERVA IS NULL THEN :NEW.COD_RESERVA := SQ_PK_RESERVA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_RESERVA" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_RESERVA_NO_OVERLAP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_RESERVA_NO_OVERLAP" 
    BEFORE INSERT OR UPDATE ON JRGY_RESERVA
    FOR EACH ROW
DECLARE
    v_current_id NUMBER := NVL(:NEW.COD_RESERVA, :OLD.COD_RESERVA);
    v_dummy NUMBER;
BEGIN
    -- Si solo cambia estado u otros campos sin modificar fechas ni habitaciÔøΩÔøΩn, omite validaciÔøΩÔøΩn.
    IF UPDATING
       AND :NEW.COD_HABITACION = :OLD.COD_HABITACION
       AND :NEW.FECHA_INICIO = :OLD.FECHA_INICIO
       AND :NEW.FECHA_FIN = :OLD.FECHA_FIN THEN
        RETURN;
    END IF;

    -- Validacion de fechas
    IF :NEW.FECHA_FIN < :NEW.FECHA_INICIO THEN
        RAISE_APPLICATION_ERROR(-20060, 'La fecha fin debe ser mayor o igual a la de inicio');
    END IF;

    -- Evita solapes de reservas en la misma habitacion
    BEGIN
        SELECT 1
        INTO v_dummy
        FROM JRGY_RESERVA
        WHERE COD_HABITACION = :NEW.COD_HABITACION
          AND (:NEW.FECHA_INICIO <= FECHA_FIN AND :NEW.FECHA_FIN >= FECHA_INICIO)
          AND (v_current_id IS NULL OR COD_RESERVA <> v_current_id)
        FOR UPDATE NOWAIT;

        RAISE_APPLICATION_ERROR(-20061, 'La habitacion ya esta reservada en ese rango de fechas');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
        WHEN OTHERS THEN
            IF SQLCODE = -54 THEN
                RAISE_APPLICATION_ERROR(-20062, 'Reserva en curso para esta habitacion, intenta de nuevo');
            ELSE
                RAISE;
            END IF;
    END;
END;
/
ALTER TRIGGER "UCM"."TRG_RESERVA_NO_OVERLAP" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_RESERVA_SYNC_ESTADO_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_RESERVA_SYNC_ESTADO_HAB" 
    FOR INSERT OR UPDATE OF COD_ESTADO_RESERVA ON JRGY_RESERVA
COMPOUND TRIGGER
    TYPE t_row IS RECORD (
        cod_reserva    NUMBER,
        cod_habitacion NUMBER,
        cod_usuario    NUMBER,
        cod_estado     NUMBER
    );
    TYPE t_tab IS TABLE OF t_row INDEX BY PLS_INTEGER;
    g_rows t_tab;

    AFTER EACH ROW IS
    BEGIN
        g_rows(g_rows.COUNT + 1) := t_row(:NEW.COD_RESERVA, :NEW.COD_HABITACION, :NEW.COD_USUARIO, :NEW.COD_ESTADO_RESERVA);
    END AFTER EACH ROW;

    AFTER STATEMENT IS
        v_est_en_proceso   NUMBER;
        v_est_finalizada   NUMBER;
        v_est_cancelada    NUMBER;
        v_est_checkout_sol NUMBER;
        v_hab_ocupada      NUMBER;
        v_hab_libre        NUMBER;
    BEGIN
        IF g_rows.COUNT > 0 THEN
            SELECT COD_ESTADO_RESERVA INTO v_est_en_proceso
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'EN PROCESO';

            SELECT COD_ESTADO_RESERVA INTO v_est_finalizada
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'FINALIZADA';

            SELECT COD_ESTADO_RESERVA INTO v_est_cancelada
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CANCELADA';

            SELECT COD_ESTADO_RESERVA INTO v_est_checkout_sol
            FROM JRGY_CAT_ESTADO_RESERVA
            WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CHECKOUT SOLICITADO';

            SELECT COD_ESTADO_HABITACION INTO v_hab_ocupada
            FROM JRGY_CAT_ESTADO_HABITACION
            WHERE REPLACE(UPPER(ESTADO_HABITACION), '_', ' ') = 'OCUPADA';

            SELECT COD_ESTADO_HABITACION INTO v_hab_libre
            FROM JRGY_CAT_ESTADO_HABITACION
            WHERE REPLACE(UPPER(ESTADO_HABITACION), '_', ' ') = 'LIBRE';

            FOR i IN g_rows.FIRST .. g_rows.LAST LOOP
                IF g_rows.EXISTS(i) THEN
                    IF g_rows(i).cod_estado = v_est_en_proceso THEN
                        UPDATE JRGY_HABITACION
                        SET COD_ESTADO_HABITACION = v_hab_ocupada,
                            COD_USUARIO_OCUPANTE = g_rows(i).cod_usuario
                        WHERE COD_HABITACION = g_rows(i).cod_habitacion;
                    ELSIF g_rows(i).cod_estado IN (v_est_finalizada, v_est_cancelada) THEN
                        DECLARE
                            v_activos NUMBER := FN_RESERVAS_ACTIVAS_HAB(
                                g_rows(i).cod_habitacion,
                                g_rows(i).cod_reserva,
                                v_est_en_proceso,
                                v_est_checkout_sol
                            );
                        BEGIN
                            IF v_activos = 0 THEN
                                UPDATE JRGY_HABITACION
                                SET COD_ESTADO_HABITACION = v_hab_libre,
                                    COD_USUARIO_OCUPANTE = NULL
                                WHERE COD_HABITACION = g_rows(i).cod_habitacion;
                            END IF;
                        END;
                    END IF;
                END IF;
            END LOOP;
        END IF;
    END AFTER STATEMENT;
END;
/
ALTER TRIGGER "UCM"."TRG_RESERVA_SYNC_ESTADO_HAB" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_RESERVA_EXP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_RESERVA_EXP" BEFORE INSERT ON JRGY_RESERVA_EXP FOR EACH ROW
BEGIN
    IF :NEW.COD_RESERVA_EXP IS NULL THEN
        :NEW.COD_RESERVA_EXP := SQ_PK_RESERVA_EXP.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_RESERVA_EXP" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_RESERVA_SERVICIO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_RESERVA_SERVICIO" BEFORE INSERT ON JRGY_RESERVA_SERVICIO FOR EACH ROW
BEGIN
    IF :NEW.COD_RESERVA_SERVICIO IS NULL THEN
        :NEW.COD_RESERVA_SERVICIO := SQ_PK_RESERVA_SERVICIO.NEXTVAL;
    END IF;
    IF :NEW.TOTAL IS NULL THEN
        :NEW.TOTAL := NVL(:NEW.CANTIDAD, 0) * NVL(:NEW.PRECIO_UNIT, 0);
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_RESERVA_SERVICIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_RESERVA_SERVICIO_TOTAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_RESERVA_SERVICIO_TOTAL" 
    BEFORE INSERT OR UPDATE ON JRGY_RESERVA_SERVICIO
    FOR EACH ROW
BEGIN
    :NEW.TOTAL := NVL(:NEW.CANTIDAD, 0) * NVL(:NEW.PRECIO_UNIT, 0);
    :NEW.UPDATED_AT := SYSDATE;
END;
/
ALTER TRIGGER "UCM"."TRG_RESERVA_SERVICIO_TOTAL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_ROL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_ROL" BEFORE INSERT ON JRGY_ROL FOR EACH ROW
BEGIN IF :NEW.COD_ROL IS NULL THEN :NEW.COD_ROL := SQ_PK_ROL.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_ROL" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_SERVICIO_UPDATED_AT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_SERVICIO_UPDATED_AT" 
    BEFORE UPDATE ON JRGY_SERVICIO
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := SYSDATE;
END;
/
ALTER TRIGGER "UCM"."TRG_SERVICIO_UPDATED_AT" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_SERVICIO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_SERVICIO" BEFORE INSERT ON JRGY_SERVICIO FOR EACH ROW
BEGIN
    IF :NEW.COD_SERVICIO IS NULL THEN
        :NEW.COD_SERVICIO := SQ_PK_SERVICIO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_SERVICIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_SERVICIO_HORARIO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_SERVICIO_HORARIO" BEFORE INSERT ON JRGY_SERVICIO_HORARIO FOR EACH ROW
BEGIN
    IF :NEW.COD_HORARIO IS NULL THEN
        :NEW.COD_HORARIO := SQ_PK_SERVICIO_HORARIO.NEXTVAL;
    END IF;
END;
/
ALTER TRIGGER "UCM"."TRG_PK_SERVICIO_HORARIO" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_SOLICITUD_ADMIN
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_SOLICITUD_ADMIN" BEFORE INSERT ON JRGY_SOLICITUD_ADMIN FOR EACH ROW
BEGIN IF :NEW.COD_SOLICITUD IS NULL THEN :NEW.COD_SOLICITUD := SQ_PK_SOLICITUD_ADMIN.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_SOLICITUD_ADMIN" ENABLE;
--------------------------------------------------------
--  DDL for Trigger TRG_PK_VENTA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TRIGGER "UCM"."TRG_PK_VENTA" BEFORE INSERT ON JRGY_VENTA FOR EACH ROW
BEGIN IF :NEW.COD_VENTA IS NULL THEN :NEW.COD_VENTA := SQ_PK_VENTA.NEXTVAL; END IF; END;
/
ALTER TRIGGER "UCM"."TRG_PK_VENTA" ENABLE;
--------------------------------------------------------
--  DDL for Procedure CRUD_CALLE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_CALLE" (
    OPCION_P IN VARCHAR2,
    COD_CALLE_P IN NUMBER,
    CALLE_P IN VARCHAR2,
    NRO_P IN NUMBER,
    COD_COMUNA_P IN NUMBER,
    CUR_CALLE OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_CALLE (COD_CALLE, CALLE, NRO, COD_COMUNA) VALUES (COD_CALLE_P, CALLE_P, NRO_P, COD_COMUNA_P);
        WHEN 'R' THEN
            OPEN CUR_CALLE FOR
                SELECT COD_CALLE, CALLE, NRO, COD_COMUNA FROM JRGY_CALLE WHERE COD_CALLE = COD_CALLE_P;
        WHEN 'U' THEN
            UPDATE JRGY_CALLE
            SET CALLE = CALLE_P,
                NRO = NRO_P,
                COD_COMUNA = COD_COMUNA_P
            WHERE COD_CALLE = COD_CALLE_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20025, 'CALLE NO ENCONTRADA');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_CALLE WHERE COD_CALLE = COD_CALLE_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20025, 'CALLE NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_CIUDAD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_CIUDAD" (
    OPCION_P IN VARCHAR2,
    COD_CIUDAD_P IN NUMBER,
    CIUDAD_P IN VARCHAR2,
    COD_REGION_P IN NUMBER,
    CUR_CIUDAD OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_CIUDAD (COD_CIUDAD, CIUDAD, COD_REGION) VALUES (COD_CIUDAD_P, CIUDAD_P, COD_REGION_P);
        WHEN 'R' THEN
            OPEN CUR_CIUDAD FOR
                SELECT COD_CIUDAD, CIUDAD, COD_REGION FROM JRGY_CIUDAD WHERE COD_CIUDAD = COD_CIUDAD_P;
        WHEN 'U' THEN
            UPDATE JRGY_CIUDAD
            SET CIUDAD = CIUDAD_P,
                COD_REGION = COD_REGION_P
            WHERE COD_CIUDAD = COD_CIUDAD_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20023, 'CIUDAD NO ENCONTRADA');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_CIUDAD WHERE COD_CIUDAD = COD_CIUDAD_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20023, 'CIUDAD NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_COMUNA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_COMUNA" (
    OPCION_P IN VARCHAR2,
    COD_COMUNA_P IN NUMBER,
    COMUNA_P IN VARCHAR2,
    COD_CIUDAD_P IN NUMBER,
    CUR_COMUNA OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_COMUNA (COD_COMUNA, COMUNA, COD_CIUDAD) VALUES (COD_COMUNA_P, COMUNA_P, COD_CIUDAD_P);
        WHEN 'R' THEN
            OPEN CUR_COMUNA FOR
                SELECT COD_COMUNA, COMUNA, COD_CIUDAD FROM JRGY_COMUNA WHERE COD_COMUNA = COD_COMUNA_P;
        WHEN 'U' THEN
            UPDATE JRGY_COMUNA
            SET COMUNA = COMUNA_P,
                COD_CIUDAD = COD_CIUDAD_P
            WHERE COD_COMUNA = COD_COMUNA_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20024, 'COMUNA NO ENCONTRADA');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_COMUNA WHERE COD_COMUNA = COD_COMUNA_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20024, 'COMUNA NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_DETALLE_PAGO_HABITACION
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_DETALLE_PAGO_HABITACION" (
    OPCION_P IN VARCHAR2,
    COD_PAGO_P IN NUMBER,
    COD_HABITACION_P IN NUMBER,
    FECHA_ESTADIA_P IN DATE,
    PRECIO_HABITACION_P IN NUMBER,
    DIAS_P IN NUMBER,
    CUR_DET_PAGO OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_DETALLE_PAGO_HABITACION (COD_PAGO_HABITACION, COD_HABITACION, FECHA_ESTADIA, PRECIO_HABITACION, DIAS)
            VALUES (COD_PAGO_P, COD_HABITACION_P, FECHA_ESTADIA_P, PRECIO_HABITACION_P, DIAS_P);
        WHEN 'R' THEN
            OPEN CUR_DET_PAGO FOR
                SELECT COD_PAGO_HABITACION, COD_HABITACION, FECHA_ESTADIA, PRECIO_HABITACION, DIAS
                FROM JRGY_DETALLE_PAGO_HABITACION
                WHERE COD_PAGO_HABITACION = COD_PAGO_P AND COD_HABITACION = COD_HABITACION_P;
        WHEN 'U' THEN
            UPDATE JRGY_DETALLE_PAGO_HABITACION
            SET FECHA_ESTADIA = FECHA_ESTADIA_P,
                PRECIO_HABITACION = PRECIO_HABITACION_P,
                DIAS = DIAS_P
            WHERE COD_PAGO_HABITACION = COD_PAGO_P AND COD_HABITACION = COD_HABITACION_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20029, 'DETALLE PAGO HAB NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_DETALLE_PAGO_HABITACION
            WHERE COD_PAGO_HABITACION = COD_PAGO_P AND COD_HABITACION = COD_HABITACION_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20029, 'DETALLE PAGO HAB NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_DETALLE_PEDIDO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_DETALLE_PEDIDO" (
    OPCION_P IN VARCHAR2,
    COD_PEDIDO_P IN NUMBER,
    COD_PROVEEDOR_P IN NUMBER,
    COD_PRODUCTO_P IN NUMBER,
    NOMBRE_PRODUCTO_P IN VARCHAR2,
    CANTIDAD_PRODUCTO_P IN NUMBER,
    PRECIO_COMPRA_P IN NUMBER,
    PRECIO_TOTAL_P IN NUMBER,
    CUR_DET_PEDIDO OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_DETALLE_PEDIDO (COD_PEDIDO, COD_PROVEEDOR, COD_PRODUCTO, NOMBRE_PRODUCTO, CANTIDAD_PRODUCTO, PRECIO_COMPRA, PRECIO_TOTAL)
            VALUES (COD_PEDIDO_P, COD_PROVEEDOR_P, COD_PRODUCTO_P, NOMBRE_PRODUCTO_P, CANTIDAD_PRODUCTO_P, PRECIO_COMPRA_P, PRECIO_TOTAL_P);
        WHEN 'R' THEN
            OPEN CUR_DET_PEDIDO FOR
                SELECT COD_PEDIDO, COD_PROVEEDOR, COD_PRODUCTO, NOMBRE_PRODUCTO, CANTIDAD_PRODUCTO, PRECIO_COMPRA, PRECIO_TOTAL
                FROM JRGY_DETALLE_PEDIDO
                WHERE COD_PEDIDO = COD_PEDIDO_P AND COD_PROVEEDOR = COD_PROVEEDOR_P AND COD_PRODUCTO = COD_PRODUCTO_P;
        WHEN 'U' THEN
            UPDATE JRGY_DETALLE_PEDIDO
            SET COD_PRODUCTO      = COD_PRODUCTO_P,
                NOMBRE_PRODUCTO   = NOMBRE_PRODUCTO_P,
                CANTIDAD_PRODUCTO = CANTIDAD_PRODUCTO_P,
                PRECIO_COMPRA     = PRECIO_COMPRA_P,
                PRECIO_TOTAL      = PRECIO_TOTAL_P
            WHERE COD_PEDIDO = COD_PEDIDO_P AND COD_PROVEEDOR = COD_PROVEEDOR_P AND COD_PRODUCTO = COD_PRODUCTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20031, 'DETALLE PEDIDO NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_DETALLE_PEDIDO WHERE COD_PEDIDO = COD_PEDIDO_P AND COD_PROVEEDOR = COD_PROVEEDOR_P AND COD_PRODUCTO = COD_PRODUCTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20031, 'DETALLE PEDIDO NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_DETALLE_VENTA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_DETALLE_VENTA" (
    OPCION_P IN VARCHAR2,
    COD_VENTA_P IN NUMBER,
    COD_PRODUCTO_P IN NUMBER,
    CANTIDAD_P IN NUMBER,
    PRECIO_PRODUCTO_P IN NUMBER,
    PRECIO_TOTAL_P IN NUMBER,
    CUR_DET_VENTA OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_DETALLE_VENTA (COD_VENTA, COD_PRODUCTO, CANTIDAD, PRECIO_PRODUCTO, PRECIO_TOTAL)
            VALUES (COD_VENTA_P, COD_PRODUCTO_P, CANTIDAD_P, PRECIO_PRODUCTO_P, PRECIO_TOTAL_P);
        WHEN 'R' THEN
            OPEN CUR_DET_VENTA FOR
                SELECT COD_VENTA, COD_PRODUCTO, CANTIDAD, PRECIO_PRODUCTO, PRECIO_TOTAL
                FROM JRGY_DETALLE_VENTA
                WHERE COD_VENTA = COD_VENTA_P AND COD_PRODUCTO = COD_PRODUCTO_P;
        WHEN 'U' THEN
            UPDATE JRGY_DETALLE_VENTA
            SET CANTIDAD = CANTIDAD_P,
                PRECIO_PRODUCTO = PRECIO_PRODUCTO_P,
                PRECIO_TOTAL = PRECIO_TOTAL_P
            WHERE COD_VENTA = COD_VENTA_P AND COD_PRODUCTO = COD_PRODUCTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20033, 'DETALLE VENTA NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_DETALLE_VENTA WHERE COD_VENTA = COD_VENTA_P AND COD_PRODUCTO = COD_PRODUCTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20033, 'DETALLE VENTA NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_EMPLEADO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_EMPLEADO" (
    OPCION_P IN VARCHAR2,
    COD_EMPLEADO_P IN NUMBER,
    CARGO_EMPLEADO_P IN VARCHAR2,
    FECHA_CONTRATACION_P IN DATE,
    SALARIO_P IN NUMBER,
    COMISION_P IN NUMBER,
    COD_USUARIO_P IN NUMBER,
    NOMBRE_USUARIO_P IN VARCHAR2,
    APELLIDO1_USUARIO_P IN VARCHAR2,
    APELLIDO2_USUARIO_P IN VARCHAR2,
    EMAIL_USUARIO_P IN VARCHAR2,
    TELEFONO_USUARIO_P IN NUMBER,
    CONTRASENA_HASH_P IN VARCHAR2,
    COD_ESTADO_USUARIO_P IN NUMBER,
    COD_DEPARTAMENTO_P IN NUMBER,
    COD_ESTADO_LABORAL_P IN NUMBER,
    CUR_EMPLEADO OUT SYS_REFCURSOR
)
IS
    V_COD_USUARIO NUMBER := COD_USUARIO_P;
    CUR_USUARIO SYS_REFCURSOR;
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            IF V_COD_USUARIO IS NULL THEN
                RAISE_APPLICATION_ERROR(-20001, 'COD_USUARIO requerido (RUT) sin autoincremento');
            END IF;

            CRUD_USUARIO(
                'C',
                V_COD_USUARIO,
                NOMBRE_USUARIO_P,
                APELLIDO1_USUARIO_P,
                APELLIDO2_USUARIO_P,
                EMAIL_USUARIO_P,
                TELEFONO_USUARIO_P,
                CONTRASENA_HASH_P,
                COD_ESTADO_USUARIO_P,
                CUR_USUARIO
            );

            INSERT INTO JRGY_EMPLEADO(COD_EMPLEADO, COD_USUARIO, COD_DEPARTAMENTO, CARGO, FECHA_CONTRATACION, SALARIO, COMISION, COD_ESTADO_LABORAL)
            VALUES (COD_EMPLEADO_P, V_COD_USUARIO, COD_DEPARTAMENTO_P, CARGO_EMPLEADO_P, FECHA_CONTRATACION_P, SALARIO_P, COMISION_P, COD_ESTADO_LABORAL_P);

        WHEN 'R' THEN
            OPEN CUR_EMPLEADO FOR
                SELECT E.COD_EMPLEADO,
                       E.CARGO,
                       E.FECHA_CONTRATACION,
                       E.SALARIO,
                       E.COMISION,
                       U.COD_USUARIO,
                       U.NOMBRE_USUARIO,
                       U.APELLIDO1_USUARIO,
                       U.APELLIDO2_USUARIO,
                       U.EMAIL_USUARIO,
                       U.TELEFONO_USUARIO
                FROM JRGY_EMPLEADO E
                JOIN JRGY_USUARIO U ON U.COD_USUARIO = E.COD_USUARIO
                WHERE E.COD_EMPLEADO = COD_EMPLEADO_P;

        WHEN 'U' THEN
            CRUD_USUARIO(
                'U',
                V_COD_USUARIO,
                NOMBRE_USUARIO_P,
                APELLIDO1_USUARIO_P,
                APELLIDO2_USUARIO_P,
                EMAIL_USUARIO_P,
                TELEFONO_USUARIO_P,
                CONTRASENA_HASH_P,
                COD_ESTADO_USUARIO_P,
                CUR_USUARIO
            );

            UPDATE JRGY_EMPLEADO
            SET CARGO             = CARGO_EMPLEADO_P,
                FECHA_CONTRATACION = FECHA_CONTRATACION_P,
                SALARIO            = SALARIO_P,
                COMISION           = COMISION_P,
                COD_DEPARTAMENTO   = COD_DEPARTAMENTO_P,
                COD_ESTADO_LABORAL = COD_ESTADO_LABORAL_P
            WHERE COD_EMPLEADO = COD_EMPLEADO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-342, 'NO SE ENCONTRO EL EMPLEADO');
            END IF;

        WHEN 'D' THEN
            DELETE FROM JRGY_EMPLEADO WHERE COD_EMPLEADO = COD_EMPLEADO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-342, 'NO SE ENCONTRO EL EMPLEADO');
            END IF;

            CRUD_USUARIO(
                'D',
                V_COD_USUARIO,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                CUR_USUARIO
            );

        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_HABITACION
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_HABITACION" (
    OPCION_P IN VARCHAR2,
    COD_HABITACION_P IN NUMBER,
    NRO_HABITACION_P IN NUMBER,
    CAPACIDAD_P IN NUMBER,
    COD_TIPO_HABITACION_P IN NUMBER,
    COD_ESTADO_HABITACION_P IN NUMBER,
    PRECIO_BASE_P IN NUMBER,
    CUR_HABITACION OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_HABITACION (COD_HABITACION, NRO_HABITACION, CAPACIDAD, COD_TIPO_HABITACION, COD_ESTADO_HABITACION, PRECIO_BASE)
            VALUES (COD_HABITACION_P, NRO_HABITACION_P, CAPACIDAD_P, COD_TIPO_HABITACION_P, COD_ESTADO_HABITACION_P, PRECIO_BASE_P);
        WHEN 'R' THEN
            OPEN CUR_HABITACION FOR
                SELECT COD_HABITACION, NRO_HABITACION, CAPACIDAD, COD_TIPO_HABITACION, COD_ESTADO_HABITACION, PRECIO_BASE
                FROM JRGY_HABITACION
                WHERE COD_HABITACION = COD_HABITACION_P;
        WHEN 'U' THEN
            UPDATE JRGY_HABITACION
            SET NRO_HABITACION      = NRO_HABITACION_P,
                CAPACIDAD           = CAPACIDAD_P,
                COD_TIPO_HABITACION = COD_TIPO_HABITACION_P,
                COD_ESTADO_HABITACION = COD_ESTADO_HABITACION_P,
                PRECIO_BASE         = PRECIO_BASE_P
            WHERE COD_HABITACION = COD_HABITACION_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20027, 'HABITACION NO ENCONTRADA');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_HABITACION WHERE COD_HABITACION = COD_HABITACION_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20027, 'HABITACION NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_MOVIMIENTO_STOCK
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_MOVIMIENTO_STOCK" (
    OPCION_P IN VARCHAR2,
    COD_MOVIMIENTO_P IN NUMBER,
    COD_PRODUCTO_P IN NUMBER,
    TIPO_MOVIMIENTO_P IN VARCHAR2,
    CANTIDAD_P IN NUMBER,
    FECHA_MOVIMIENTO_P IN DATE,
    MOTIVO_P IN VARCHAR2,
    CUR_MOV OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_MOVIMIENTO_STOCK (COD_MOVIMIENTO, COD_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA_MOVIMIENTO, MOTIVO)
            VALUES (COD_MOVIMIENTO_P, COD_PRODUCTO_P, TIPO_MOVIMIENTO_P, CANTIDAD_P, FECHA_MOVIMIENTO_P, MOTIVO_P);
        WHEN 'R' THEN
            OPEN CUR_MOV FOR
                SELECT COD_MOVIMIENTO, COD_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA_MOVIMIENTO, MOTIVO
                FROM JRGY_MOVIMIENTO_STOCK
                WHERE COD_MOVIMIENTO = COD_MOVIMIENTO_P;
        WHEN 'U' THEN
            UPDATE JRGY_MOVIMIENTO_STOCK
            SET COD_PRODUCTO = COD_PRODUCTO_P,
                TIPO_MOVIMIENTO = TIPO_MOVIMIENTO_P,
                CANTIDAD = CANTIDAD_P,
                FECHA_MOVIMIENTO = FECHA_MOVIMIENTO_P,
                MOTIVO = MOTIVO_P
            WHERE COD_MOVIMIENTO = COD_MOVIMIENTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20034, 'MOVIMIENTO NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_MOVIMIENTO_STOCK WHERE COD_MOVIMIENTO = COD_MOVIMIENTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20034, 'MOVIMIENTO NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_PAGO_HABITACION
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_PAGO_HABITACION" (
    OPCION_P IN VARCHAR2,
    COD_PAGO_P IN NUMBER,
    FECHA_PAGO_P IN DATE,
    VALOR_TOTAL_P IN NUMBER,
    COD_USUARIO_P IN NUMBER,
    CUR_PAGO OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_PAGO_HABITACION (COD_PAGO_HABITACION, FECHA_PAGO, VALOR_TOTAL_PAGO, COD_USUARIO)
            VALUES (COD_PAGO_P, FECHA_PAGO_P, VALOR_TOTAL_P, COD_USUARIO_P);
        WHEN 'R' THEN
            OPEN CUR_PAGO FOR
                SELECT COD_PAGO_HABITACION, FECHA_PAGO, VALOR_TOTAL_PAGO, COD_USUARIO
                FROM JRGY_PAGO_HABITACION
                WHERE COD_PAGO_HABITACION = COD_PAGO_P;
        WHEN 'U' THEN
            UPDATE JRGY_PAGO_HABITACION
            SET FECHA_PAGO = FECHA_PAGO_P,
                VALOR_TOTAL_PAGO = VALOR_TOTAL_P,
                COD_USUARIO = COD_USUARIO_P
            WHERE COD_PAGO_HABITACION = COD_PAGO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20028, 'PAGO HABITACION NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_PAGO_HABITACION WHERE COD_PAGO_HABITACION = COD_PAGO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20028, 'PAGO HABITACION NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_PAGO_VENTA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_PAGO_VENTA" (
    OPCION_P IN VARCHAR2,
    COD_PAGO_P IN NUMBER,
    COD_VENTA_P IN NUMBER,
    COD_MODO_PAGO_P IN NUMBER,
    MONTO_P IN NUMBER,
    FECHA_PAGO_P IN DATE,
    CUR_PAGO_VENTA OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_PAGO_VENTA (COD_PAGO, COD_VENTA, COD_MODO_PAGO, MONTO, FECHA_PAGO)
            VALUES (COD_PAGO_P, COD_VENTA_P, COD_MODO_PAGO_P, MONTO_P, FECHA_PAGO_P);
        WHEN 'R' THEN
            OPEN CUR_PAGO_VENTA FOR
                SELECT COD_PAGO, COD_VENTA, COD_MODO_PAGO, MONTO, FECHA_PAGO
                FROM JRGY_PAGO_VENTA
                WHERE COD_PAGO = COD_PAGO_P;
        WHEN 'U' THEN
            UPDATE JRGY_PAGO_VENTA
            SET COD_VENTA = COD_VENTA_P,
                COD_MODO_PAGO = COD_MODO_PAGO_P,
                MONTO = MONTO_P,
                FECHA_PAGO = FECHA_PAGO_P
            WHERE COD_PAGO = COD_PAGO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20035, 'PAGO VENTA NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_PAGO_VENTA WHERE COD_PAGO = COD_PAGO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20035, 'PAGO VENTA NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_PEDIDO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_PEDIDO" (
    OPCION_P IN VARCHAR2,
    COD_PEDIDO_P IN NUMBER,
    VALOR_TOTAL_P IN NUMBER,
    FECHA_PEDIDO_P IN DATE,
    COD_EMPLEADO_P IN NUMBER,
    CUR_PEDIDO OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_PEDIDO (COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO)
            VALUES (COD_PEDIDO_P, VALOR_TOTAL_P, FECHA_PEDIDO_P, COD_EMPLEADO_P);
        WHEN 'R' THEN
            OPEN CUR_PEDIDO FOR
                SELECT COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO
                FROM JRGY_PEDIDO
                WHERE COD_PEDIDO = COD_PEDIDO_P;
        WHEN 'U' THEN
            UPDATE JRGY_PEDIDO
            SET VALOR_TOTAL = VALOR_TOTAL_P,
                FECHA_PEDIDO = FECHA_PEDIDO_P,
                COD_EMPLEADO = COD_EMPLEADO_P
            WHERE COD_PEDIDO = COD_PEDIDO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20030, 'PEDIDO NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_PEDIDO WHERE COD_PEDIDO = COD_PEDIDO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20030, 'PEDIDO NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_PRODUCTO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_PRODUCTO" (
    OPCION_P IN VARCHAR2,
    COD_PRODUCTO_P IN NUMBER,
    NOMBRE_PRODUCTO_P IN VARCHAR2,
    COD_TIPO_SERVICIO_P IN NUMBER,
    PRECIO_PRODUCTO_P IN NUMBER,
    CANTIDAD_PRODUCTO_P IN NUMBER,
    STOCK_PRODUCTO_P IN NUMBER,
    CUR_PRODUCTO OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_PRODUCTO(COD_PRODUCTO, NOMBRE_PRODUCTO, COD_TIPO_SERVICIO, PRECIO_PRODUCTO, CANTIDAD_PRODUCTO, STOCK_PRODUCTO)
            VALUES (COD_PRODUCTO_P, NOMBRE_PRODUCTO_P, COD_TIPO_SERVICIO_P, PRECIO_PRODUCTO_P, CANTIDAD_PRODUCTO_P, STOCK_PRODUCTO_P);

        WHEN 'R' THEN
            OPEN CUR_PRODUCTO FOR
                SELECT COD_PRODUCTO, NOMBRE_PRODUCTO, COD_TIPO_SERVICIO, PRECIO_PRODUCTO, CANTIDAD_PRODUCTO, STOCK_PRODUCTO
                FROM JRGY_PRODUCTO
                WHERE COD_PRODUCTO = COD_PRODUCTO_P;

        WHEN 'U' THEN
            UPDATE JRGY_PRODUCTO
            SET NOMBRE_PRODUCTO   = NOMBRE_PRODUCTO_P,
                COD_TIPO_SERVICIO = COD_TIPO_SERVICIO_P,
                PRECIO_PRODUCTO   = PRECIO_PRODUCTO_P,
                CANTIDAD_PRODUCTO = CANTIDAD_PRODUCTO_P,
                STOCK_PRODUCTO    = STOCK_PRODUCTO_P
            WHERE COD_PRODUCTO = COD_PRODUCTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-343, 'NO SE ENCONTRO EL PRODUCTO');
            END IF;

        WHEN 'D' THEN
            DELETE FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = COD_PRODUCTO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-343, 'NO SE ENCONTRO EL PRODUCTO');
            END IF;

        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_PROVEEDOR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_PROVEEDOR" (
    OPCION_P IN VARCHAR2,
    COD_PROVEEDOR_P IN NUMBER,
    NOMBRE_PROVEEDOR_P IN VARCHAR2,
    DIRECCION_PROVEEDOR_P IN VARCHAR2,
    TELEFONO_PROVEEDOR_P IN NUMBER,
    COD_REGION_P IN NUMBER,
    CUR_PROVEEDOR OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_PROVEEDOR (COD_PROVEEDOR, NOMBRE_PROVEEDOR, DIRECCION_PROVEEDOR, TELEFONO_PROVEEDOR, COD_REGION)
            VALUES (COD_PROVEEDOR_P, NOMBRE_PROVEEDOR_P, DIRECCION_PROVEEDOR_P, TELEFONO_PROVEEDOR_P, COD_REGION_P);
        WHEN 'R' THEN
            OPEN CUR_PROVEEDOR FOR
                SELECT COD_PROVEEDOR, NOMBRE_PROVEEDOR, DIRECCION_PROVEEDOR, TELEFONO_PROVEEDOR, COD_REGION
                FROM JRGY_PROVEEDOR
                WHERE COD_PROVEEDOR = COD_PROVEEDOR_P;
        WHEN 'U' THEN
            UPDATE JRGY_PROVEEDOR
            SET NOMBRE_PROVEEDOR   = NOMBRE_PROVEEDOR_P,
                DIRECCION_PROVEEDOR = DIRECCION_PROVEEDOR_P,
                TELEFONO_PROVEEDOR  = TELEFONO_PROVEEDOR_P,
                COD_REGION          = COD_REGION_P
            WHERE COD_PROVEEDOR = COD_PROVEEDOR_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20026, 'PROVEEDOR NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_PROVEEDOR WHERE COD_PROVEEDOR = COD_PROVEEDOR_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20026, 'PROVEEDOR NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_REGION
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_REGION" (
    OPCION_P IN VARCHAR2,
    COD_REGION_P IN NUMBER,
    REGION_P IN VARCHAR2,
    CUR_REGION OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_REGION (COD_REGION, REGION) VALUES (COD_REGION_P, REGION_P);
        WHEN 'R' THEN
            OPEN CUR_REGION FOR
                SELECT COD_REGION, REGION FROM JRGY_REGION WHERE COD_REGION = COD_REGION_P;
        WHEN 'U' THEN
            UPDATE JRGY_REGION SET REGION = REGION_P WHERE COD_REGION = COD_REGION_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20022, 'REGION NO ENCONTRADA');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_REGION WHERE COD_REGION = COD_REGION_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20022, 'REGION NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_ROL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_ROL" (
    OPCION_P IN VARCHAR2,
    COD_ROL_P IN NUMBER,
    NOMBRE_ROL_P IN VARCHAR2,
    CUR_ROL OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_ROL (COD_ROL, NOMBRE_ROL)
            VALUES (COD_ROL_P, NOMBRE_ROL_P);
        WHEN 'R' THEN
            OPEN CUR_ROL FOR
                SELECT COD_ROL, NOMBRE_ROL
                FROM JRGY_ROL
                WHERE COD_ROL = COD_ROL_P;
        WHEN 'U' THEN
            UPDATE JRGY_ROL
            SET NOMBRE_ROL = NOMBRE_ROL_P
            WHERE COD_ROL = COD_ROL_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20020, 'ROL NO ENCONTRADO');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_ROL WHERE COD_ROL = COD_ROL_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20020, 'ROL NO ENCONTRADO');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_USUARIO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_USUARIO" (
    OPCION_P IN VARCHAR2,
    COD_USUARIO_P IN NUMBER,
    NOMBRE_USUARIO_P IN VARCHAR2,
    APELLIDO1_USUARIO_P IN VARCHAR2,
    APELLIDO2_USUARIO_P IN VARCHAR2,
    EMAIL_USUARIO_P IN VARCHAR2,
    TELEFONO_USUARIO_P IN NUMBER,
    CONTRASENA_HASH_P IN VARCHAR2,
    COD_ESTADO_USUARIO_P IN NUMBER,
    CUR_USUARIO OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_USUARIO(COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO, EMAIL_USUARIO, TELEFONO_USUARIO, CONTRASENA_HASH, COD_ESTADO_USUARIO)
            VALUES (COD_USUARIO_P, NOMBRE_USUARIO_P, APELLIDO1_USUARIO_P, APELLIDO2_USUARIO_P, EMAIL_USUARIO_P, TELEFONO_USUARIO_P, CONTRASENA_HASH_P, COD_ESTADO_USUARIO_P);

        WHEN 'R' THEN
            OPEN CUR_USUARIO FOR
                SELECT COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO, EMAIL_USUARIO, TELEFONO_USUARIO, CONTRASENA_HASH, COD_ESTADO_USUARIO
                FROM JRGY_USUARIO
                WHERE COD_USUARIO = COD_USUARIO_P;

        WHEN 'U' THEN
            UPDATE JRGY_USUARIO
            SET NOMBRE_USUARIO      = NOMBRE_USUARIO_P,
                APELLIDO1_USUARIO   = APELLIDO1_USUARIO_P,
                APELLIDO2_USUARIO   = APELLIDO2_USUARIO_P,
                EMAIL_USUARIO       = EMAIL_USUARIO_P,
                TELEFONO_USUARIO    = TELEFONO_USUARIO_P,
                CONTRASENA_HASH     = CONTRASENA_HASH_P,
                COD_ESTADO_USUARIO  = COD_ESTADO_USUARIO_P
            WHERE COD_USUARIO = COD_USUARIO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-343, 'NO SE ENCONTRO EL CLIENTE');
            END IF;

        WHEN 'D' THEN
            DELETE FROM JRGY_USUARIO WHERE COD_USUARIO = COD_USUARIO_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-343, 'NO SE ENCONTRO EL CLIENTE');
            END IF;

        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_USUARIO_ROL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_USUARIO_ROL" (
    OPCION_P IN VARCHAR2,
    COD_USUARIO_P IN NUMBER,
    COD_ROL_P IN NUMBER,
    CUR_USUARIO_ROL OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_USUARIO_ROL (COD_USUARIO, COD_ROL)
            VALUES (COD_USUARIO_P, COD_ROL_P);
        WHEN 'R' THEN
            OPEN CUR_USUARIO_ROL FOR
                SELECT COD_USUARIO, COD_ROL
                FROM JRGY_USUARIO_ROL
                WHERE COD_USUARIO = COD_USUARIO_P AND COD_ROL = COD_ROL_P;
        WHEN 'U' THEN
            RAISE_APPLICATION_ERROR(-20021, 'UPDATE NO SOPORTADO, ELIMINE Y CREE NUEVO');
        WHEN 'D' THEN
            DELETE FROM JRGY_USUARIO_ROL
            WHERE COD_USUARIO = COD_USUARIO_P AND COD_ROL = COD_ROL_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20021, 'ASIGNACION NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure CRUD_VENTA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."CRUD_VENTA" (
    OPCION_P IN VARCHAR2,
    COD_VENTA_P IN NUMBER,
    COD_USUARIO_P IN NUMBER,
    COD_EMPLEADO_P IN NUMBER,
    FECHA_VENTA_P IN DATE,
    CUR_VENTA OUT SYS_REFCURSOR
)
IS
BEGIN
    CASE UPPER(OPCION_P)
        WHEN 'C' THEN
            INSERT INTO JRGY_VENTA (COD_VENTA, COD_USUARIO, COD_EMPLEADO, FECHA_VENTA)
            VALUES (COD_VENTA_P, COD_USUARIO_P, COD_EMPLEADO_P, FECHA_VENTA_P);
        WHEN 'R' THEN
            OPEN CUR_VENTA FOR
                SELECT COD_VENTA, COD_USUARIO, COD_EMPLEADO, FECHA_VENTA
                FROM JRGY_VENTA
                WHERE COD_VENTA = COD_VENTA_P;
        WHEN 'U' THEN
            UPDATE JRGY_VENTA
            SET COD_USUARIO = COD_USUARIO_P,
                COD_EMPLEADO = COD_EMPLEADO_P,
                FECHA_VENTA = FECHA_VENTA_P
            WHERE COD_VENTA = COD_VENTA_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20032, 'VENTA NO ENCONTRADA');
            END IF;
        WHEN 'D' THEN
            DELETE FROM JRGY_VENTA WHERE COD_VENTA = COD_VENTA_P;
            IF SQL%ROWCOUNT = 0 THEN
                RAISE_APPLICATION_ERROR(-20032, 'VENTA NO ENCONTRADA');
            END IF;
        ELSE
            RAISE_APPLICATION_ERROR(-2003, 'INGRESE C R U D');
    END CASE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_ASIGNAR_ROL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_ASIGNAR_ROL" (
    COD_USUARIO_P IN NUMBER,
    COD_ROL_P IN NUMBER
)
IS
    CURR SYS_REFCURSOR;
BEGIN
    CRUD_USUARIO_ROL('C', COD_USUARIO_P, COD_ROL_P, CURR);
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_AUTH_LOGIN
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_AUTH_LOGIN" (
    P_EMAIL IN VARCHAR2,
    CUR_USER OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_USER FOR
        SELECT
            COD_USUARIO,
            NOMBRE_USUARIO,
            APELLIDO1_USUARIO,
            APELLIDO2_USUARIO,
            EMAIL_USUARIO,
            TELEFONO_USUARIO,
            CONTRASENA_HASH
        FROM JRGY_USUARIO
        WHERE LOWER(EMAIL_USUARIO) = LOWER(P_EMAIL)
        FETCH FIRST 1 ROWS ONLY;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_CAT_SERVPROD_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_CAT_SERVPROD_LISTAR" (
    CUR_CATS OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_CATS FOR
        SELECT
            ts.NOMBRE AS TIPO,
            (SELECT COUNT(*) FROM JRGY_SERVICIO s WHERE s.COD_TIPO_SERVICIO = ts.COD_TIPO_SERVICIO) AS SERVICIOS,
            (SELECT COUNT(*) FROM JRGY_PRODUCTO p WHERE p.COD_TIPO_SERVICIO = ts.COD_TIPO_SERVICIO) AS PRODUCTOS
        FROM JRGY_CAT_TIPO_SERVICIO ts
        ORDER BY ts.NOMBRE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DELETE_PEDIDO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DELETE_PEDIDO" (
    COD_PEDIDO_P IN JRGY_PEDIDO.COD_PEDIDO%TYPE
)
IS
    PEDIDOS_ELIMINADOS NUMBER;
BEGIN
    DELETE FROM JRGY_PEDIDO WHERE COD_PEDIDO = COD_PEDIDO_P;
    PEDIDOS_ELIMINADOS := SQL%ROWCOUNT;

    IF PEDIDOS_ELIMINADOS = 0 THEN
        RAISE_APPLICATION_ERROR(-20014, 'Pedido con cÔøΩÔøΩdigo ' || COD_PEDIDO_P || ' no encontrado para eliminar.');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20015, 'Error al eliminar el pedido: ' || SQLERRM);
END JRGY_PRO_DELETE_PEDIDO;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DEP_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DEP_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_JEFE_ID IN NUMBER,
    P_PRESUPUESTO IN NUMBER
)
IS
BEGIN
    UPDATE JRGY_DEPARTAMENTO
    SET NOMBRE = P_NOMBRE,
        JEFE_EMPLEADO_ID = P_JEFE_ID,
        PRESUPUESTO = P_PRESUPUESTO
    WHERE COD_DEPARTAMENTO = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'DEPARTAMENTO NO ENCONTRADO');
    END IF;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DEP_ASIGNAR_EMPLEADOS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DEP_ASIGNAR_EMPLEADOS" (
    P_DEP_ID IN NUMBER,
    P_EMPLEADOS_JSON IN CLOB
)
IS
BEGIN
    DELETE FROM JRGY_DEPARTAMENTO_EMPLEADO WHERE COD_DEPARTAMENTO = P_DEP_ID;

    FOR rec IN (
        SELECT jt.empId AS COD_EMPLEADO
        FROM JSON_TABLE(P_EMPLEADOS_JSON, '$[*]'
            COLUMNS (
                empId NUMBER PATH '$'
            )
        ) jt
    ) LOOP
        INSERT INTO JRGY_DEPARTAMENTO_EMPLEADO (COD_DEPARTAMENTO, COD_EMPLEADO)
        VALUES (P_DEP_ID, rec.COD_EMPLEADO);
    END LOOP;

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DEP_BORRAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DEP_BORRAR" (
    P_ID IN NUMBER
)
IS
BEGIN
    DELETE FROM JRGY_DEPARTAMENTO_EMPLEADO WHERE COD_DEPARTAMENTO = P_ID;
    DELETE FROM JRGY_DEPARTAMENTO WHERE COD_DEPARTAMENTO = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'DEPARTAMENTO NO ENCONTRADO');
    END IF;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DEP_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DEP_CREAR" (
    P_NOMBRE IN VARCHAR2,
    P_JEFE_ID IN NUMBER,
    P_PRESUPUESTO IN NUMBER,
    P_ID OUT NUMBER
)
IS
BEGIN
    INSERT INTO JRGY_DEPARTAMENTO (NOMBRE, JEFE_EMPLEADO_ID, PRESUPUESTO)
    VALUES (P_NOMBRE, P_JEFE_ID, P_PRESUPUESTO)
    RETURNING COD_DEPARTAMENTO INTO P_ID;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DEP_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DEP_LISTAR" (
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT d.COD_DEPARTAMENTO,
               d.NOMBRE,
               d.JEFE_EMPLEADO_ID,
               u.COD_USUARIO AS JEFE_RUT,
               d.PRESUPUESTO,
               JRGY_FUN_DEP_SUELDO_TOTAL(d.COD_DEPARTAMENTO) AS SUELDO_TOTAL,
               NVL(COUNT(DISTINCT e2.COD_EMPLEADO), 0) AS EMPLEADOS_ASIGNADOS
        FROM JRGY_DEPARTAMENTO d
        LEFT JOIN JRGY_EMPLEADO e ON e.COD_EMPLEADO = d.JEFE_EMPLEADO_ID
        LEFT JOIN JRGY_USUARIO u ON u.COD_USUARIO = e.COD_USUARIO
        LEFT JOIN JRGY_EMPLEADO e2 ON e2.COD_DEPARTAMENTO = d.COD_DEPARTAMENTO
        GROUP BY d.COD_DEPARTAMENTO, d.NOMBRE, d.JEFE_EMPLEADO_ID, u.COD_USUARIO, d.PRESUPUESTO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_DEP_OBTENER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_DEP_OBTENER" (
    P_ID IN NUMBER,
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT COD_DEPARTAMENTO, NOMBRE, JEFE_EMPLEADO_ID, PRESUPUESTO, FECHA_CREACION
        FROM JRGY_DEPARTAMENTO
        WHERE COD_DEPARTAMENTO = P_ID;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EMP_HAB_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EMP_HAB_LISTAR" (
    P_EMP_ID IN NUMBER,
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT COD_EMPLEADO, CATEGORIA, TIPO
        FROM JRGY_EMPLEADO_HABILIDAD
        WHERE COD_EMPLEADO = P_EMP_ID
        ORDER BY TIPO, CATEGORIA;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EMP_HAB_REEMPLAZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EMP_HAB_REEMPLAZAR" (
    P_EMP_ID IN NUMBER,
    P_ITEMS_JSON IN CLOB
)
IS
BEGIN
    DELETE FROM JRGY_EMPLEADO_HABILIDAD WHERE COD_EMPLEADO = P_EMP_ID;

    FOR rec IN (
        SELECT
            NVL(TRIM(UPPER(jt.categoria)), 'SIN_CATEGORIA') AS CATEGORIA,
            NVL(TRIM(UPPER(jt.tipo)), 'SERVICIO') AS TIPO
        FROM JSON_TABLE(P_ITEMS_JSON, '$[*]'
            COLUMNS (
                categoria VARCHAR2(50) PATH '$.categoria',
                tipo       VARCHAR2(20) PATH '$.tipo'
            )
        ) jt
    ) LOOP
        INSERT INTO JRGY_EMPLEADO_HABILIDAD (COD_EMPLEADO, CATEGORIA, TIPO)
        VALUES (P_EMP_ID, rec.CATEGORIA, rec.TIPO);
    END LOOP;

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EMPLEADO_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EMPLEADO_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_CARGO IN VARCHAR2,
    P_SUELDO_BASE IN NUMBER,
    P_FECHA_CONTRATO IN DATE,
    P_DEP_ID IN NUMBER,
    P_ESTADO_NOMBRE IN VARCHAR2
)
IS
    V_ESTADO_ID NUMBER;
BEGIN
    SELECT COD_ESTADO_LABORAL INTO V_ESTADO_ID FROM JRGY_CAT_ESTADO_LABORAL WHERE UPPER(ESTADO_LABORAL) = UPPER(P_ESTADO_NOMBRE);

    UPDATE JRGY_EMPLEADO
    SET CARGO = P_CARGO,
        SUELDO_BASE = P_SUELDO_BASE,
        FECHA_CONTRATACION = P_FECHA_CONTRATO,
        COD_DEPARTAMENTO = P_DEP_ID,
        COD_ESTADO_LABORAL = V_ESTADO_ID
    WHERE COD_EMPLEADO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'EMPLEADO NO ENCONTRADO');
    END IF;
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20052, 'ESTADO LABORAL NO ENCONTRADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EMPLEADO_BORRAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EMPLEADO_BORRAR" (
    P_ID IN NUMBER
)
IS
BEGIN
    DELETE FROM JRGY_EMPLEADO WHERE COD_EMPLEADO = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'EMPLEADO NO ENCONTRADO');
    END IF;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EMPLEADO_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EMPLEADO_CREAR" (
    P_USUARIO_ID IN NUMBER,
    P_CARGO IN VARCHAR2,
    P_SUELDO_BASE IN NUMBER,
    P_FECHA_CONTRATO IN DATE,
    P_DEP_ID IN NUMBER,
    P_ESTADO_NOMBRE IN VARCHAR2,
    P_ID OUT NUMBER
)
IS
    V_ESTADO_ID NUMBER;
BEGIN
    SELECT COD_ESTADO_LABORAL INTO V_ESTADO_ID FROM JRGY_CAT_ESTADO_LABORAL WHERE UPPER(ESTADO_LABORAL) = UPPER(P_ESTADO_NOMBRE);

    INSERT INTO JRGY_EMPLEADO (COD_EMPLEADO, COD_USUARIO, COD_DEPARTAMENTO, CARGO, SUELDO_BASE, FECHA_CONTRATACION, COD_ESTADO_LABORAL)
    VALUES (SQ_PK_EMPLEADO.NEXTVAL, P_USUARIO_ID, P_DEP_ID, P_CARGO, P_SUELDO_BASE, P_FECHA_CONTRATO, V_ESTADO_ID)
    RETURNING COD_EMPLEADO INTO P_ID;
    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20052, 'ESTADO LABORAL NO ENCONTRADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EMPLEADO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EMPLEADO_LISTAR" (
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        WITH EMP AS (
            SELECT e.COD_EMPLEADO,
                   e.COD_USUARIO,
                   u.NOMBRE_USUARIO || ' ' || NVL(u.APELLIDO1_USUARIO, '') || ' ' || NVL(u.APELLIDO2_USUARIO, '') AS NOMBRE_COMPLETO,
                   u.EMAIL_USUARIO,
                    e.COD_DEPARTAMENTO,
                   NVL(d.NOMBRE, 'NONE') AS DEPARTAMENTO,
                   e.CARGO,
                   e.SUELDO_BASE,
                   e.FECHA_CONTRATACION,
                   e.COD_ESTADO_LABORAL,
                   el.ESTADO_LABORAL,
                   CASE
                       WHEN e.CARGO IS NULL OR e.SUELDO_BASE IS NULL OR e.COD_DEPARTAMENTO IS NULL OR e.COD_ESTADO_LABORAL IS NULL THEN 1
                       ELSE 0
                   END AS INCOMPLETO
            FROM JRGY_EMPLEADO e
            LEFT JOIN JRGY_USUARIO u ON u.COD_USUARIO = e.COD_USUARIO
            LEFT JOIN JRGY_DEPARTAMENTO d ON d.COD_DEPARTAMENTO = e.COD_DEPARTAMENTO
            LEFT JOIN JRGY_CAT_ESTADO_LABORAL el ON el.COD_ESTADO_LABORAL = e.COD_ESTADO_LABORAL
        ), EMP_ROLE AS (
            SELECT
                NULL AS COD_EMPLEADO,
                u.COD_USUARIO,
                u.NOMBRE_USUARIO || ' ' || NVL(u.APELLIDO1_USUARIO, '') || ' ' || NVL(u.APELLIDO2_USUARIO, '') AS NOMBRE_COMPLETO,
                u.EMAIL_USUARIO,
                NULL AS COD_DEPARTAMENTO,
                'NONE' AS DEPARTAMENTO,
                NULL AS CARGO,
                NULL AS SUELDO_BASE,
                NULL AS FECHA_CONTRATACION,
                NULL AS COD_ESTADO_LABORAL,
                NULL AS ESTADO_LABORAL,
                1 AS INCOMPLETO
            FROM JRGY_USUARIO u
            INNER JOIN JRGY_USUARIO_ROL ur ON ur.COD_USUARIO = u.COD_USUARIO
            INNER JOIN JRGY_ROL r ON r.COD_ROL = ur.COD_ROL
            LEFT JOIN JRGY_EMPLEADO e ON e.COD_USUARIO = u.COD_USUARIO
            WHERE UPPER(r.NOMBRE_ROL) = 'EMPLOYEE'
              AND e.COD_EMPLEADO IS NULL
        )
        SELECT *
        FROM (
            SELECT * FROM EMP
            UNION ALL
            SELECT * FROM EMP_ROLE
        )
        ORDER BY COD_EMPLEADO NULLS LAST, COD_USUARIO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_EXPERIENCIA_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_EXPERIENCIA_LISTAR" (
    CUR_EXP OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_EXP FOR
        SELECT
            COD_EXPERIENCIA AS ID,
            NOMBRE,
            DESCRIPCION,
            PRECIO,
            TAG,
            ESTADO
        FROM JRGY_EXPERIENCIA
        ORDER BY COD_EXPERIENCIA;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_HAB_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_HAB_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_NUMERO IN NUMBER,
    P_CAPACIDAD IN NUMBER,
    P_PRECIO_BASE IN NUMBER,
    P_TIPO_NOMBRE IN VARCHAR2,
    P_ESTADO_NOMBRE IN VARCHAR2,
    P_USUARIO_ID IN NUMBER
)
IS
    V_TIPO_ID NUMBER;
    V_ESTADO_ID NUMBER;
    V_DUP NUMBER;
    V_USUARIO_ID NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_DUP FROM JRGY_HABITACION WHERE NRO_HABITACION = P_NUMERO AND COD_HABITACION <> P_ID;
    IF V_DUP > 0 THEN
        RAISE_APPLICATION_ERROR(-20100, 'NUMERO DE HABITACION YA EXISTE');
    END IF;

    SELECT COD_TIPO_HABITACION INTO V_TIPO_ID
    FROM JRGY_CAT_TIPO_HABITACION
    WHERE UPPER(TIPO_HABITACION) = UPPER(P_TIPO_NOMBRE);

    SELECT COD_ESTADO_HABITACION INTO V_ESTADO_ID
    FROM JRGY_CAT_ESTADO_HABITACION
    WHERE UPPER(ESTADO_HABITACION) = UPPER(P_ESTADO_NOMBRE);

    IF P_USUARIO_ID IS NOT NULL THEN
        SELECT COUNT(*) INTO V_USUARIO_ID FROM JRGY_USUARIO WHERE COD_USUARIO = P_USUARIO_ID;
        IF V_USUARIO_ID = 0 THEN
            RAISE_APPLICATION_ERROR(-20105, 'USUARIO NO ENCONTRADO');
        END IF;
    END IF;

    UPDATE JRGY_HABITACION
    SET NRO_HABITACION = P_NUMERO,
        CAPACIDAD = P_CAPACIDAD,
        PRECIO_BASE = P_PRECIO_BASE,
        COD_TIPO_HABITACION = V_TIPO_ID,
        COD_ESTADO_HABITACION = V_ESTADO_ID,
        COD_USUARIO_OCUPANTE = P_USUARIO_ID
    WHERE COD_HABITACION = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'HABITACION NO ENCONTRADA');
    END IF;

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20102, 'TIPO O ESTADO DE HABITACION NO ENCONTRADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_HAB_BORRAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_HAB_BORRAR" (
    P_ID IN NUMBER
)
IS
    V_COUNT_RES NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO V_COUNT_RES FROM JRGY_RESERVA WHERE COD_HABITACION = P_ID;
    IF V_COUNT_RES > 0 THEN
        RAISE_APPLICATION_ERROR(-20104, 'NO SE PUEDE ELIMINAR: HABITACION TIENE RESERVAS');
    END IF;

    DELETE FROM JRGY_HABITACION WHERE COD_HABITACION = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'HABITACION NO ENCONTRADA');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_HAB_CAMBIAR_ESTADO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_HAB_CAMBIAR_ESTADO" (
    P_ID IN NUMBER,
    P_ESTADO_NOMBRE IN VARCHAR2
)
IS
    V_ESTADO_ID NUMBER;
BEGIN
    SELECT COD_ESTADO_HABITACION INTO V_ESTADO_ID
    FROM JRGY_CAT_ESTADO_HABITACION
    WHERE UPPER(ESTADO_HABITACION) = UPPER(P_ESTADO_NOMBRE);

    UPDATE JRGY_HABITACION
    SET COD_ESTADO_HABITACION = V_ESTADO_ID
    WHERE COD_HABITACION = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20103, 'HABITACION NO ENCONTRADA');
    END IF;

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20102, 'ESTADO DE HABITACION NO ENCONTRADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_HAB_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_HAB_CREAR" (
    P_NUMERO IN NUMBER,
    P_CAPACIDAD IN NUMBER,
    P_PRECIO_BASE IN NUMBER,
    P_TIPO_NOMBRE IN VARCHAR2,
    P_ESTADO_NOMBRE IN VARCHAR2,
    P_USUARIO_ID IN NUMBER,
    P_ID OUT NUMBER
)
IS
    V_TIPO_ID NUMBER;
    V_ESTADO_ID NUMBER;
    V_DUP NUMBER;
    V_USUARIO_ID NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_DUP FROM JRGY_HABITACION WHERE NRO_HABITACION = P_NUMERO;
    IF V_DUP > 0 THEN
        RAISE_APPLICATION_ERROR(-20100, 'NUMERO DE HABITACION YA EXISTE');
    END IF;

    SELECT COD_TIPO_HABITACION INTO V_TIPO_ID
    FROM JRGY_CAT_TIPO_HABITACION
    WHERE UPPER(TIPO_HABITACION) = UPPER(P_TIPO_NOMBRE);

    SELECT COD_ESTADO_HABITACION INTO V_ESTADO_ID
    FROM JRGY_CAT_ESTADO_HABITACION
    WHERE UPPER(ESTADO_HABITACION) = UPPER(P_ESTADO_NOMBRE);

    IF P_USUARIO_ID IS NOT NULL THEN
        SELECT COUNT(*) INTO V_USUARIO_ID FROM JRGY_USUARIO WHERE COD_USUARIO = P_USUARIO_ID;
        IF V_USUARIO_ID = 0 THEN
            RAISE_APPLICATION_ERROR(-20105, 'USUARIO NO ENCONTRADO');
        END IF;
    END IF;

    INSERT INTO JRGY_HABITACION (
        NRO_HABITACION, CAPACIDAD, PRECIO_BASE, COD_TIPO_HABITACION, COD_ESTADO_HABITACION, COD_USUARIO_OCUPANTE
    ) VALUES (
        P_NUMERO, P_CAPACIDAD, P_PRECIO_BASE, V_TIPO_ID, V_ESTADO_ID, P_USUARIO_ID
    )
    RETURNING COD_HABITACION INTO P_ID;

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20102, 'TIPO O ESTADO DE HABITACION NO ENCONTRADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_HABITACION_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_HABITACION_LISTAR" (
    CUR_HAB OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_HAB FOR
        WITH RES_LATEST AS (
            SELECT r.*,
                   ROW_NUMBER() OVER(PARTITION BY r.COD_HABITACION ORDER BY r.FECHA_INICIO DESC, r.COD_RESERVA DESC) rn
            FROM JRGY_RESERVA r
        )
        SELECT
            h.COD_HABITACION AS ID,
            h.NRO_HABITACION AS NUMERO,
            h.CAPACIDAD,
            h.PRECIO_BASE,
            th.TIPO_HABITACION AS TIPO,
            eh.ESTADO_HABITACION AS ESTADO,
            h.COD_USUARIO_OCUPANTE AS OCUPANTE_ID,
            u.NOMBRE_USUARIO || ' ' || NVL(u.APELLIDO1_USUARIO, '') AS OCUPANTE_NOMBRE,
            u.EMAIL_USUARIO AS OCUPANTE_EMAIL,
            lr.COD_RESERVA AS RES_ID,
            lr.COD_USUARIO AS RES_USUARIO_ID,
            lr.FECHA_INICIO AS RES_FECHA_INICIO,
            lr.FECHA_FIN AS RES_FECHA_FIN,
            lr.HUESPEDES AS RES_HUESPEDES,
            er.ESTADO_RESERVA AS RES_ESTADO,
            u2.NOMBRE_USUARIO || ' ' || NVL(u2.APELLIDO1_USUARIO,'') AS RES_USUARIO_NOMBRE,
            u2.EMAIL_USUARIO AS RES_USUARIO_EMAIL
        FROM JRGY_HABITACION h
        LEFT JOIN JRGY_CAT_TIPO_HABITACION th ON th.COD_TIPO_HABITACION = h.COD_TIPO_HABITACION
        LEFT JOIN JRGY_CAT_ESTADO_HABITACION eh ON eh.COD_ESTADO_HABITACION = h.COD_ESTADO_HABITACION
        LEFT JOIN JRGY_USUARIO u ON u.COD_USUARIO = h.COD_USUARIO_OCUPANTE
        LEFT JOIN RES_LATEST lr ON lr.COD_HABITACION = h.COD_HABITACION AND lr.rn = 1
        LEFT JOIN JRGY_CAT_ESTADO_RESERVA er ON er.COD_ESTADO_RESERVA = lr.COD_ESTADO_RESERVA
        LEFT JOIN JRGY_USUARIO u2 ON u2.COD_USUARIO = lr.COD_USUARIO
        ORDER BY h.NRO_HABITACION;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_HAB_OBTENER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_HAB_OBTENER" (
    P_ID IN NUMBER,
    CUR_HAB OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_HAB FOR
        WITH RES_LATEST AS (
            SELECT r.*,
                   ROW_NUMBER() OVER(PARTITION BY r.COD_HABITACION ORDER BY r.FECHA_INICIO DESC, r.COD_RESERVA DESC) rn
            FROM JRGY_RESERVA r
        )
        SELECT
            h.COD_HABITACION AS ID,
            h.NRO_HABITACION AS NUMERO,
            h.CAPACIDAD,
            h.PRECIO_BASE,
            th.TIPO_HABITACION AS TIPO,
            eh.ESTADO_HABITACION AS ESTADO,
            h.COD_USUARIO_OCUPANTE AS OCUPANTE_ID,
            u.NOMBRE_USUARIO || ' ' || NVL(u.APELLIDO1_USUARIO, '') AS OCUPANTE_NOMBRE,
            u.EMAIL_USUARIO AS OCUPANTE_EMAIL,
            lr.COD_RESERVA AS RES_ID,
            lr.COD_USUARIO AS RES_USUARIO_ID,
            lr.FECHA_INICIO AS RES_FECHA_INICIO,
            lr.FECHA_FIN AS RES_FECHA_FIN,
            lr.HUESPEDES AS RES_HUESPEDES,
            er.ESTADO_RESERVA AS RES_ESTADO,
            u2.NOMBRE_USUARIO || ' ' || NVL(u2.APELLIDO1_USUARIO,'') AS RES_USUARIO_NOMBRE,
            u2.EMAIL_USUARIO AS RES_USUARIO_EMAIL
        FROM JRGY_HABITACION h
        LEFT JOIN JRGY_CAT_TIPO_HABITACION th ON th.COD_TIPO_HABITACION = h.COD_TIPO_HABITACION
        LEFT JOIN JRGY_CAT_ESTADO_HABITACION eh ON eh.COD_ESTADO_HABITACION = h.COD_ESTADO_HABITACION
        LEFT JOIN JRGY_USUARIO u ON u.COD_USUARIO = h.COD_USUARIO_OCUPANTE
        LEFT JOIN RES_LATEST lr ON lr.COD_HABITACION = h.COD_HABITACION AND lr.rn = 1
        LEFT JOIN JRGY_CAT_ESTADO_RESERVA er ON er.COD_ESTADO_RESERVA = lr.COD_ESTADO_RESERVA
        LEFT JOIN JRGY_USUARIO u2 ON u2.COD_USUARIO = lr.COD_USUARIO
        WHERE h.COD_HABITACION = P_ID;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_INSERT_PEDIDO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_INSERT_PEDIDO" (
    COD_EMPLEADO_P IN JRGY_PEDIDO.COD_EMPLEADO%TYPE,
    DETALLES_P IN DETALLE_PEDIDO_TAB,
    COD_PEDIDO_OUT OUT JRGY_PEDIDO.COD_PEDIDO%TYPE
)
IS
    V_COD_PEDIDO JRGY_PEDIDO.COD_PEDIDO%TYPE;
    V_VALOR_TOTAL JRGY_PEDIDO.VALOR_TOTAL%TYPE := 0;
BEGIN
    V_COD_PEDIDO := SQ_PK_PEDIDO.NEXTVAL;

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        V_VALOR_TOTAL := V_VALOR_TOTAL + (DETALLES_P(I).CANTIDAD_PRODUCTO * DETALLES_P(I).PRECIO_COMPRA);
    END LOOP;

    INSERT INTO JRGY_PEDIDO (COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO)
    VALUES (V_COD_PEDIDO, V_VALOR_TOTAL, SYSDATE, COD_EMPLEADO_P);

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        INSERT INTO JRGY_DETALLE_PEDIDO (COD_PEDIDO, COD_PROVEEDOR, COD_PRODUCTO, NOMBRE_PRODUCTO, CANTIDAD_PRODUCTO, PRECIO_COMPRA, PRECIO_TOTAL)
        VALUES (
            V_COD_PEDIDO,
            DETALLES_P(I).COD_PROVEEDOR,
            DETALLES_P(I).COD_PRODUCTO,
            DETALLES_P(I).NOMBRE_PRODUCTO,
            DETALLES_P(I).CANTIDAD_PRODUCTO,
            DETALLES_P(I).PRECIO_COMPRA,
            DETALLES_P(I).CANTIDAD_PRODUCTO * DETALLES_P(I).PRECIO_COMPRA
        );

    END LOOP;

    COD_PEDIDO_OUT := V_COD_PEDIDO;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20011, 'Error al insertar el pedido: ' || SQLERRM);
END JRGY_PRO_INSERT_PEDIDO;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_LOGIN
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_LOGIN" (
    EMAIL_P IN VARCHAR2,
    CONTRASENA_P IN VARCHAR2,
    CUR_LOGIN OUT SYS_REFCURSOR
)
IS
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT
    FROM JRGY_USUARIO
    WHERE EMAIL_USUARIO = EMAIL_P
      AND CONTRASENA_HASH = CONTRASENA_P;

    IF V_COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20060, 'CREDENCIALES INVALIDAS');
    END IF;

    OPEN CUR_LOGIN FOR
        SELECT U.COD_USUARIO,
               U.NOMBRE_USUARIO,
               U.APELLIDO1_USUARIO,
               U.APELLIDO2_USUARIO,
               U.EMAIL_USUARIO,
               UR.COD_ROL
        FROM JRGY_USUARIO U
        LEFT JOIN JRGY_USUARIO_ROL UR ON UR.COD_USUARIO = U.COD_USUARIO
        WHERE U.EMAIL_USUARIO = EMAIL_P
          AND U.CONTRASENA_HASH = CONTRASENA_P;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PAGO_HABITACION
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PAGO_HABITACION" (
    COD_USUARIO_P IN NUMBER,
    DETALLES_P IN DETALLE_ESTADIA_TAB,
    COD_PAGO_OUT OUT NUMBER,
    TOTAL_OUT OUT NUMBER
)
IS
    V_COD_PAGO NUMBER;
    V_TOTAL NUMBER := 0;
BEGIN
    IF DETALLES_P IS NULL OR DETALLES_P.COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20043, 'DEBE ENVIAR DETALLES DE ESTADIA');
    END IF;

    V_COD_PAGO := SQ_PK_PAGO_HAB.NEXTVAL;

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        V_TOTAL := V_TOTAL + (DETALLES_P(I).PRECIO_HABITACION * DETALLES_P(I).DIAS);
    END LOOP;

    INSERT INTO JRGY_PAGO_HABITACION (COD_PAGO_HABITACION, FECHA_PAGO, VALOR_TOTAL_PAGO, COD_USUARIO)
    VALUES (V_COD_PAGO, SYSDATE, V_TOTAL, COD_USUARIO_P);

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        INSERT INTO JRGY_DETALLE_PAGO_HABITACION (COD_PAGO_HABITACION, COD_HABITACION, FECHA_ESTADIA, PRECIO_HABITACION, DIAS)
        VALUES (V_COD_PAGO, DETALLES_P(I).COD_HABITACION, DETALLES_P(I).FECHA_ESTADIA, DETALLES_P(I).PRECIO_HABITACION, DETALLES_P(I).DIAS);

        UPDATE JRGY_HABITACION
        SET COD_ESTADO_HABITACION = (
            SELECT COD_ESTADO_HABITACION
            FROM JRGY_CAT_ESTADO_HABITACION
            WHERE UPPER(ESTADO_HABITACION) = 'OCUPADA'
        )
        WHERE COD_HABITACION = DETALLES_P(I).COD_HABITACION;
    END LOOP;

    COD_PAGO_OUT := V_COD_PAGO;
    TOTAL_OUT := V_TOTAL;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PAQ_SERV_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PAQ_SERV_LISTAR" (
    P_PAQUETE_ID IN NUMBER,
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT
            sp.COD_PAQUETE,
            sp.COD_SERVICIO_INCL,
            s.NOMBRE,
            s.PRECIO,
            s.COD_TIPO_SERVICIO,
            ts.NOMBRE AS TIPO_SERVICIO
        FROM JRGY_SERVICIO_PAQUETE sp
        JOIN JRGY_SERVICIO s ON s.COD_SERVICIO = sp.COD_SERVICIO_INCL
        LEFT JOIN JRGY_CAT_TIPO_SERVICIO ts ON ts.COD_TIPO_SERVICIO = s.COD_TIPO_SERVICIO
        WHERE sp.COD_PAQUETE = P_PAQUETE_ID;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PAQ_SERV_REEMPLAZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PAQ_SERV_REEMPLAZAR" (
    P_PAQUETE_ID IN NUMBER,
    P_ITEMS_JSON IN CLOB
)
IS
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_SERVICIO WHERE COD_SERVICIO = P_PAQUETE_ID;
    IF V_COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'SERVICIO PAQUETE NO ENCONTRADO');
    END IF;

    DELETE FROM JRGY_SERVICIO_PAQUETE WHERE COD_PAQUETE = P_PAQUETE_ID;

    FOR rec IN (
        SELECT
            jt.servicioId AS COD_SERVICIO
        FROM JSON_TABLE(P_ITEMS_JSON, '$[*]'
            COLUMNS (
                servicioId NUMBER PATH '$.servicioId'
            )
        ) jt
    ) LOOP
        SELECT COUNT(*) INTO V_COUNT FROM JRGY_SERVICIO WHERE COD_SERVICIO = rec.COD_SERVICIO;
        IF V_COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20082, 'SERVICIO INCLUIDO NO ENCONTRADO');
        END IF;

        INSERT INTO JRGY_SERVICIO_PAQUETE (COD_PAQUETE, COD_SERVICIO_INCL)
        VALUES (P_PAQUETE_ID, rec.COD_SERVICIO);
    END LOOP;

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PEDIDO_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PEDIDO_CREAR" (
    P_EMPLEADO_ID IN NUMBER,
    P_DETALLE_JSON IN CLOB,
    P_PEDIDO_ID OUT NUMBER
)
IS
    V_TOTAL NUMBER := 0;
BEGIN
    INSERT INTO JRGY_PEDIDO (COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO)
    VALUES (SQ_PK_PEDIDO.NEXTVAL, 0, SYSDATE, P_EMPLEADO_ID)
    RETURNING COD_PEDIDO INTO P_PEDIDO_ID;

    FOR rec IN (
        SELECT
            jt.proveedorId AS COD_PROVEEDOR,
            jt.productoId AS COD_PRODUCTO,
            jt.nombreProducto AS NOMBRE_PRODUCTO,
            jt.cantidad AS CANTIDAD,
            jt.precioCompra AS PRECIO_COMPRA
        FROM JSON_TABLE(P_DETALLE_JSON, '$[*]'
            COLUMNS (
                proveedorId NUMBER PATH '$.proveedorId',
                productoId NUMBER PATH '$.productoId',
                nombreProducto VARCHAR2(50) PATH '$.nombreProducto',
                cantidad NUMBER PATH '$.cantidad',
                precioCompra NUMBER PATH '$.precioCompra'
            )
        ) jt
    ) LOOP
        INSERT INTO JRGY_DETALLE_PEDIDO (COD_PEDIDO, COD_PROVEEDOR, COD_PRODUCTO, NOMBRE_PRODUCTO, CANTIDAD_PRODUCTO, PRECIO_COMPRA, PRECIO_TOTAL)
        VALUES (P_PEDIDO_ID, rec.COD_PROVEEDOR, rec.COD_PRODUCTO, rec.NOMBRE_PRODUCTO, rec.CANTIDAD, rec.PRECIO_COMPRA, rec.CANTIDAD * rec.PRECIO_COMPRA);

        UPDATE JRGY_PRODUCTO
        SET STOCK_PRODUCTO = NVL(STOCK_PRODUCTO,0) + rec.CANTIDAD
        WHERE COD_PRODUCTO = rec.COD_PRODUCTO;

        INSERT INTO JRGY_MOVIMIENTO_STOCK (COD_MOVIMIENTO, COD_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA_MOVIMIENTO, MOTIVO)
        VALUES (SQ_PK_MOVIMIENTO_STOCK.NEXTVAL, rec.COD_PRODUCTO, 'ENTRADA', rec.CANTIDAD, SYSDATE, 'PEDIDO ' || P_PEDIDO_ID);

        V_TOTAL := V_TOTAL + (rec.CANTIDAD * rec.PRECIO_COMPRA);
    END LOOP;

    UPDATE JRGY_PEDIDO SET VALOR_TOTAL = V_TOTAL WHERE COD_PEDIDO = P_PEDIDO_ID;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PEDIDO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PEDIDO_LISTAR" (
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO
        FROM JRGY_PEDIDO
        ORDER BY FECHA_PEDIDO DESC;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PEDIDO_OBTENER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PEDIDO_OBTENER" (
    P_ID IN NUMBER,
    CUR_PED OUT SYS_REFCURSOR,
    CUR_DET OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_PED FOR
        SELECT COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO
        FROM JRGY_PEDIDO
        WHERE COD_PEDIDO = P_ID;

    OPEN CUR_DET FOR
        SELECT COD_PEDIDO, COD_PROVEEDOR, COD_PRODUCTO, NOMBRE_PRODUCTO, CANTIDAD_PRODUCTO, PRECIO_COMPRA, PRECIO_TOTAL
        FROM JRGY_DETALLE_PEDIDO
        WHERE COD_PEDIDO = P_ID;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PRODUCTO_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PRODUCTO_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_TIPO_ID IN NUMBER,
    P_PRECIO IN NUMBER,
    P_CANTIDAD IN NUMBER,
    P_STOCK IN NUMBER,
    P_UMBRAL IN NUMBER
)
IS
BEGIN
    UPDATE JRGY_PRODUCTO
    SET NOMBRE_PRODUCTO = P_NOMBRE,
        COD_TIPO_SERVICIO = P_TIPO_ID,
        PRECIO_PRODUCTO = P_PRECIO,
        CANTIDAD_PRODUCTO = P_CANTIDAD,
        STOCK_PRODUCTO = P_STOCK,
        UMBRAL_ALERTA = P_UMBRAL
    WHERE COD_PRODUCTO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'PRODUCTO NO ENCONTRADO');
    END IF;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PRODUCTO_BORRAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PRODUCTO_BORRAR" (
    P_ID IN NUMBER
)
IS
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_DETALLE_PEDIDO WHERE COD_PRODUCTO = P_ID;
    IF V_COUNT > 0 THEN
        RAISE_APPLICATION_ERROR(-20104, 'NO SE PUEDE ELIMINAR: TIENE PEDIDOS');
    END IF;
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_DETALLE_VENTA WHERE COD_PRODUCTO = P_ID;
    IF V_COUNT > 0 THEN
        RAISE_APPLICATION_ERROR(-20104, 'NO SE PUEDE ELIMINAR: TIENE VENTAS');
    END IF;

    DELETE FROM JRGY_SERVICIO_PRODUCTO WHERE COD_PRODUCTO = P_ID;
    DELETE FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'PRODUCTO NO ENCONTRADO');
    END IF;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PRODUCTO_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PRODUCTO_CREAR" (
    P_NOMBRE IN VARCHAR2,
    P_TIPO_ID IN NUMBER,
    P_PRECIO IN NUMBER,
    P_CANTIDAD IN NUMBER,
    P_STOCK IN NUMBER,
    P_UMBRAL IN NUMBER,
    P_ID OUT NUMBER
)
IS
BEGIN
    IF P_TIPO_ID IS NOT NULL THEN
        DECLARE
            v_exists NUMBER;
        BEGIN
            SELECT COUNT(*) INTO v_exists FROM JRGY_CAT_TIPO_SERVICIO WHERE COD_TIPO_SERVICIO = P_TIPO_ID;
            IF v_exists = 0 THEN
                RAISE_APPLICATION_ERROR(-20016, 'CATEGORIA DE SERVICIO/PRODUCTO NO EXISTE');
            END IF;
        END;
    END IF;

    INSERT INTO JRGY_PRODUCTO (NOMBRE_PRODUCTO, COD_TIPO_SERVICIO, PRECIO_PRODUCTO, CANTIDAD_PRODUCTO, STOCK_PRODUCTO, UMBRAL_ALERTA)
    VALUES (P_NOMBRE, P_TIPO_ID, P_PRECIO, P_CANTIDAD, P_STOCK, P_UMBRAL)
    RETURNING COD_PRODUCTO INTO P_ID;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PRODUCTO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PRODUCTO_LISTAR" (
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT
            p.COD_PRODUCTO,
            p.NOMBRE_PRODUCTO,
            p.COD_TIPO_SERVICIO,
            ts.NOMBRE AS TIPO_SERVICIO,
            p.PRECIO_PRODUCTO,
            p.CANTIDAD_PRODUCTO,
            p.STOCK_PRODUCTO,
            p.UMBRAL_ALERTA,
            CASE WHEN p.UMBRAL_ALERTA IS NOT NULL AND NVL(p.STOCK_PRODUCTO,0) <= p.UMBRAL_ALERTA THEN 1 ELSE 0 END AS ALERTA_ACTIVA
        FROM JRGY_PRODUCTO p
        LEFT JOIN JRGY_CAT_TIPO_SERVICIO ts ON ts.COD_TIPO_SERVICIO = p.COD_TIPO_SERVICIO
        ORDER BY p.NOMBRE_PRODUCTO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PROVEEDOR_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PROVEEDOR_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_DIRECCION IN VARCHAR2,
    P_TELEFONO IN NUMBER,
    P_REGION IN NUMBER,
    P_CIUDAD IN NUMBER
)
IS
BEGIN
    UPDATE JRGY_PROVEEDOR
    SET NOMBRE_PROVEEDOR = P_NOMBRE,
        DIRECCION_PROVEEDOR = P_DIRECCION,
        TELEFONO_PROVEEDOR = P_TELEFONO,
        COD_REGION = P_REGION,
        COD_CIUDAD = P_CIUDAD
    WHERE COD_PROVEEDOR = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20026, 'PROVEEDOR NO ENCONTRADO');
    END IF;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PROVEEDOR_BORRAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PROVEEDOR_BORRAR" (
    P_ID IN NUMBER
)
IS
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_DETALLE_PEDIDO WHERE COD_PROVEEDOR = P_ID;
    IF V_COUNT > 0 THEN
        RAISE_APPLICATION_ERROR(-20104, 'NO SE PUEDE ELIMINAR: TIENE PEDIDOS');
    END IF;

    DELETE FROM JRGY_PROVEEDOR WHERE COD_PROVEEDOR = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20026, 'PROVEEDOR NO ENCONTRADO');
    END IF;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PROVEEDOR_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PROVEEDOR_CREAR" (
    P_NOMBRE IN VARCHAR2,
    P_DIRECCION IN VARCHAR2,
    P_TELEFONO IN NUMBER,
    P_REGION IN NUMBER,
    P_CIUDAD IN NUMBER,
    P_ID OUT NUMBER
)
IS
BEGIN
    INSERT INTO JRGY_PROVEEDOR (COD_PROVEEDOR, NOMBRE_PROVEEDOR, DIRECCION_PROVEEDOR, TELEFONO_PROVEEDOR, COD_REGION, COD_CIUDAD)
    VALUES (SQ_PK_PROVEEDOR.NEXTVAL, P_NOMBRE, P_DIRECCION, P_TELEFONO, P_REGION, P_CIUDAD)
    RETURNING COD_PROVEEDOR INTO P_ID;
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_PROVEEDOR_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_PROVEEDOR_LISTAR" (
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT p.COD_PROVEEDOR,
               p.NOMBRE_PROVEEDOR,
               p.DIRECCION_PROVEEDOR,
               p.TELEFONO_PROVEEDOR,
               p.COD_REGION,
               p.COD_CIUDAD,
               r.REGION AS REGION_NOMBRE,
               c.CIUDAD AS CIUDAD_NOMBRE
        FROM JRGY_PROVEEDOR p
        LEFT JOIN JRGY_REGION r ON r.COD_REGION = p.COD_REGION
        LEFT JOIN JRGY_CIUDAD c ON c.COD_CIUDAD = p.COD_CIUDAD
        ORDER BY p.NOMBRE_PROVEEDOR;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RECALC_STOCK
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RECALC_STOCK" (
    COD_PRODUCTO_P IN NUMBER
)
IS
    V_STOCK NUMBER := 0;
BEGIN
    SELECT NVL(SUM(CASE WHEN TIPO_MOVIMIENTO = 'ENTRADA' THEN CANTIDAD WHEN TIPO_MOVIMIENTO = 'SALIDA' THEN -CANTIDAD ELSE 0 END), 0)
    INTO V_STOCK
    FROM JRGY_MOVIMIENTO_STOCK
    WHERE COD_PRODUCTO = COD_PRODUCTO_P;

    UPDATE JRGY_PRODUCTO SET STOCK_PRODUCTO = V_STOCK WHERE COD_PRODUCTO = COD_PRODUCTO_P;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20044, 'PRODUCTO NO ENCONTRADO');
    END IF;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_REGISTRAR_PEDIDO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_REGISTRAR_PEDIDO" (
    COD_EMPLEADO_P IN NUMBER,
    DETALLES_P IN DETALLE_PEDIDO_TAB,
    COD_PEDIDO_OUT OUT NUMBER,
    TOTAL_OUT OUT NUMBER
)
IS
    V_COD_PEDIDO NUMBER;
    V_TOTAL NUMBER := 0;
BEGIN
    IF DETALLES_P IS NULL OR DETALLES_P.COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20042, 'DEBE ENVIAR DETALLES DE PEDIDO');
    END IF;

    V_COD_PEDIDO := SQ_PK_PEDIDO.NEXTVAL;

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        V_TOTAL := V_TOTAL + (DETALLES_P(I).CANTIDAD_PRODUCTO * DETALLES_P(I).PRECIO_COMPRA);
    END LOOP;

    INSERT INTO JRGY_PEDIDO (COD_PEDIDO, VALOR_TOTAL, FECHA_PEDIDO, COD_EMPLEADO)
    VALUES (V_COD_PEDIDO, V_TOTAL, SYSDATE, COD_EMPLEADO_P);

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        INSERT INTO JRGY_DETALLE_PEDIDO (COD_PEDIDO, COD_PROVEEDOR, COD_PRODUCTO, NOMBRE_PRODUCTO, CANTIDAD_PRODUCTO, PRECIO_COMPRA, PRECIO_TOTAL)
        VALUES (
            V_COD_PEDIDO,
            DETALLES_P(I).COD_PROVEEDOR,
            DETALLES_P(I).COD_PRODUCTO,
            DETALLES_P(I).NOMBRE_PRODUCTO,
            DETALLES_P(I).CANTIDAD_PRODUCTO,
            DETALLES_P(I).PRECIO_COMPRA,
            DETALLES_P(I).CANTIDAD_PRODUCTO * DETALLES_P(I).PRECIO_COMPRA
        );

        UPDATE JRGY_PRODUCTO
        SET STOCK_PRODUCTO = NVL(STOCK_PRODUCTO, 0) + DETALLES_P(I).CANTIDAD_PRODUCTO
        WHERE COD_PRODUCTO = DETALLES_P(I).COD_PRODUCTO;

        INSERT INTO JRGY_MOVIMIENTO_STOCK (COD_MOVIMIENTO, COD_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA_MOVIMIENTO, MOTIVO)
        VALUES (SQ_PK_MOVIMIENTO_STOCK.NEXTVAL, DETALLES_P(I).COD_PRODUCTO, 'ENTRADA', DETALLES_P(I).CANTIDAD_PRODUCTO, SYSDATE, 'PEDIDO ' || V_COD_PEDIDO);
    END LOOP;

    COD_PEDIDO_OUT := V_COD_PEDIDO;
    TOTAL_OUT := V_TOTAL;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_REGISTRAR_VENTA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_REGISTRAR_VENTA" (
    COD_USUARIO_P IN NUMBER,
    COD_EMPLEADO_P IN NUMBER,
    DETALLES_P IN DETALLE_VENTA_TAB,
    COD_VENTA_OUT OUT NUMBER,
    TOTAL_OUT OUT NUMBER
)
IS
    V_COD_VENTA NUMBER;
    V_TOTAL NUMBER := 0;
BEGIN
    IF DETALLES_P IS NULL OR DETALLES_P.COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20040, 'DEBE ENVIAR DETALLES DE VENTA');
    END IF;

    V_COD_VENTA := SQ_PK_VENTA.NEXTVAL;

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        IF FN_STOCK_DISP(DETALLES_P(I).COD_PRODUCTO) < DETALLES_P(I).CANTIDAD THEN
            RAISE_APPLICATION_ERROR(-20041, 'STOCK INSUFICIENTE PARA PRODUCTO ' || DETALLES_P(I).COD_PRODUCTO);
        END IF;
        V_TOTAL := V_TOTAL + (DETALLES_P(I).CANTIDAD * DETALLES_P(I).PRECIO_PRODUCTO);
    END LOOP;

    INSERT INTO JRGY_VENTA (COD_VENTA, COD_USUARIO, COD_EMPLEADO, FECHA_VENTA)
    VALUES (V_COD_VENTA, COD_USUARIO_P, COD_EMPLEADO_P, SYSDATE);

    FOR I IN 1 .. DETALLES_P.COUNT LOOP
        INSERT INTO JRGY_DETALLE_VENTA (COD_VENTA, COD_PRODUCTO, CANTIDAD, PRECIO_PRODUCTO, PRECIO_TOTAL)
        VALUES (V_COD_VENTA, DETALLES_P(I).COD_PRODUCTO, DETALLES_P(I).CANTIDAD, DETALLES_P(I).PRECIO_PRODUCTO, DETALLES_P(I).CANTIDAD * DETALLES_P(I).PRECIO_PRODUCTO);

        UPDATE JRGY_PRODUCTO
        SET STOCK_PRODUCTO = STOCK_PRODUCTO - DETALLES_P(I).CANTIDAD
        WHERE COD_PRODUCTO = DETALLES_P(I).COD_PRODUCTO;

        INSERT INTO JRGY_MOVIMIENTO_STOCK (COD_MOVIMIENTO, COD_PRODUCTO, TIPO_MOVIMIENTO, CANTIDAD, FECHA_MOVIMIENTO, MOTIVO)
        VALUES (SQ_PK_MOVIMIENTO_STOCK.NEXTVAL, DETALLES_P(I).COD_PRODUCTO, 'SALIDA', DETALLES_P(I).CANTIDAD, SYSDATE, 'VENTA ' || V_COD_VENTA);
    END LOOP;

    COD_VENTA_OUT := V_COD_VENTA;
    TOTAL_OUT := V_TOTAL;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_REPORTE_BALANCE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_REPORTE_BALANCE" (
    P_FECHA_DESDE IN DATE,
    P_FECHA_HASTA IN DATE,
    CUR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN CUR FOR
        WITH ING_RES AS (
            SELECT NVL(SUM(NVL(R.TOTAL_HABITACION, 0) + NVL(R.TOTAL_SERVICIOS, 0)), 0) AS TOTAL
            FROM JRGY_RESERVA R
            WHERE (P_FECHA_DESDE IS NULL OR R.FECHA_INICIO >= P_FECHA_DESDE)
              AND (P_FECHA_HASTA IS NULL OR R.FECHA_FIN <= P_FECHA_HASTA)
        ),
        ING_VEN AS (
            SELECT NVL(SUM(NVL(DV.PRECIO_TOTAL, NVL(DV.CANTIDAD, 0) * NVL(DV.PRECIO_PRODUCTO, 0))), 0) AS TOTAL
            FROM JRGY_VENTA V
            JOIN JRGY_DETALLE_VENTA DV ON DV.COD_VENTA = V.COD_VENTA
            WHERE (P_FECHA_DESDE IS NULL OR V.FECHA_VENTA >= P_FECHA_DESDE)
              AND (P_FECHA_HASTA IS NULL OR V.FECHA_VENTA <= P_FECHA_HASTA)
        ),
        EGR_COM AS (
            SELECT NVL(SUM(NVL(DP.PRECIO_TOTAL, NVL(DP.CANTIDAD_PRODUCTO, 0) * NVL(DP.PRECIO_COMPRA, 0))), 0) AS TOTAL
            FROM JRGY_PEDIDO P
            JOIN JRGY_DETALLE_PEDIDO DP ON DP.COD_PEDIDO = P.COD_PEDIDO
            WHERE (P_FECHA_DESDE IS NULL OR P.FECHA_PEDIDO >= P_FECHA_DESDE)
              AND (P_FECHA_HASTA IS NULL OR P.FECHA_PEDIDO <= P_FECHA_HASTA)
        )
        SELECT IR.TOTAL AS INGRESOS_RESERVAS,
               IV.TOTAL AS INGRESOS_VENTAS,
               EC.TOTAL AS EGRESOS_COMPRAS,
               (IR.TOTAL + IV.TOTAL - EC.TOTAL) AS UTILIDAD
        FROM ING_RES IR, ING_VEN IV, EGR_COM EC;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_REPORTE_EGRESOS_COMPRAS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_REPORTE_EGRESOS_COMPRAS" (
    P_FECHA_DESDE IN DATE,
    P_FECHA_HASTA IN DATE,
    CUR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN CUR FOR
        SELECT TRUNC(P.FECHA_PEDIDO) AS FECHA,
               SUM(NVL(DP.PRECIO_TOTAL, NVL(DP.CANTIDAD_PRODUCTO, 0) * NVL(DP.PRECIO_COMPRA, 0))) AS MONTO
        FROM JRGY_PEDIDO P
        JOIN JRGY_DETALLE_PEDIDO DP ON DP.COD_PEDIDO = P.COD_PEDIDO
        WHERE (P_FECHA_DESDE IS NULL OR P.FECHA_PEDIDO >= P_FECHA_DESDE)
          AND (P_FECHA_HASTA IS NULL OR P.FECHA_PEDIDO <= P_FECHA_HASTA)
        GROUP BY TRUNC(P.FECHA_PEDIDO)
        ORDER BY TRUNC(P.FECHA_PEDIDO);
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_REPORTE_INGRESOS_RESERVAS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_REPORTE_INGRESOS_RESERVAS" (
    P_FECHA_DESDE IN DATE,
    P_FECHA_HASTA IN DATE,
    CUR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN CUR FOR
        SELECT TRUNC(R.FECHA_INICIO) AS FECHA,
               SUM(NVL(R.TOTAL_HABITACION, 0) + NVL(R.TOTAL_SERVICIOS, 0)) AS MONTO
        FROM JRGY_RESERVA R
        WHERE (P_FECHA_DESDE IS NULL OR R.FECHA_INICIO >= P_FECHA_DESDE)
          AND (P_FECHA_HASTA IS NULL OR R.FECHA_FIN <= P_FECHA_HASTA)
        GROUP BY TRUNC(R.FECHA_INICIO)
        ORDER BY TRUNC(R.FECHA_INICIO);
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_REPORTE_INGRESOS_VENTAS
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_REPORTE_INGRESOS_VENTAS" (
    P_FECHA_DESDE IN DATE,
    P_FECHA_HASTA IN DATE,
    CUR OUT SYS_REFCURSOR
) AS
BEGIN
    OPEN CUR FOR
        SELECT TRUNC(V.FECHA_VENTA) AS FECHA,
               SUM(NVL(DV.PRECIO_TOTAL, NVL(DV.CANTIDAD, 0) * NVL(DV.PRECIO_PRODUCTO, 0))) AS MONTO
        FROM JRGY_VENTA V
        JOIN JRGY_DETALLE_VENTA DV ON DV.COD_VENTA = V.COD_VENTA
        WHERE (P_FECHA_DESDE IS NULL OR V.FECHA_VENTA >= P_FECHA_DESDE)
          AND (P_FECHA_HASTA IS NULL OR V.FECHA_VENTA <= P_FECHA_HASTA)
        GROUP BY TRUNC(V.FECHA_VENTA)
        ORDER BY TRUNC(V.FECHA_VENTA);
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_CANCELAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_CANCELAR" (
    P_RESERVA_ID IN NUMBER,
    P_USER_ID IN NUMBER
)
IS
    V_RESERVA              JRGY_RESERVA%ROWTYPE;
    V_EST_CREADA           NUMBER;
    V_EST_CANCELADA        NUMBER;
    V_EST_EN_PROCESO       NUMBER;
    V_EST_CHECKOUT_SOL     NUMBER;
    V_HAB_LIBRE            NUMBER;
    V_ACTIVOS              NUMBER := 0;
BEGIN
    IF P_RESERVA_ID IS NULL THEN
        RAISE_APPLICATION_ERROR(-20022, 'ID RESERVA REQUERIDO');
    END IF;

    BEGIN
        SELECT * INTO V_RESERVA FROM JRGY_RESERVA WHERE COD_RESERVA = P_RESERVA_ID FOR UPDATE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20020, 'Reserva no encontrada');
    END;

    SELECT COD_ESTADO_RESERVA INTO V_EST_CREADA
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CREADA';

    SELECT COD_ESTADO_RESERVA INTO V_EST_CANCELADA
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CANCELADA';

    SELECT COD_ESTADO_RESERVA INTO V_EST_EN_PROCESO
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'EN PROCESO';

    SELECT COD_ESTADO_RESERVA INTO V_EST_CHECKOUT_SOL
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CHECKOUT SOLICITADO';

    SELECT COD_ESTADO_HABITACION INTO V_HAB_LIBRE
    FROM JRGY_CAT_ESTADO_HABITACION
    WHERE REPLACE(UPPER(ESTADO_HABITACION), '_', ' ') = 'LIBRE';

    IF V_RESERVA.COD_ESTADO_RESERVA <> V_EST_CREADA THEN
        RAISE_APPLICATION_ERROR(-20072, 'Solo puedes cancelar reservas en estado CREADA');
    END IF;

    UPDATE JRGY_RESERVA
    SET COD_ESTADO_RESERVA = V_EST_CANCELADA,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    INSERT INTO JRGY_EVENTO_RESERVA (COD_RESERVA, TIPO_EVENTO, FECHA_EVENTO, NOTAS, CREATED_BY)
    VALUES (P_RESERVA_ID, 'CANCELADA', SYSDATE, 'Reserva cancelada', P_USER_ID);

    SELECT COUNT(*) INTO V_ACTIVOS
    FROM JRGY_RESERVA r
    WHERE r.COD_HABITACION = V_RESERVA.COD_HABITACION
      AND r.COD_RESERVA <> P_RESERVA_ID
      AND r.COD_ESTADO_RESERVA IN (V_EST_EN_PROCESO, V_EST_CHECKOUT_SOL);

    IF V_ACTIVOS = 0 THEN
        UPDATE JRGY_HABITACION
        SET COD_ESTADO_HABITACION = V_HAB_LIBRE
        WHERE COD_HABITACION = V_RESERVA.COD_HABITACION;
    END IF;

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_CHECKIN
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_CHECKIN" (
    P_RESERVA_ID IN NUMBER,
    P_RUT IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_EMAIL IN VARCHAR2,
    P_USER_ID IN NUMBER
)
IS
    V_COD_ESTADO_EN_PROCESO NUMBER;
    V_RESERVA JRGY_RESERVA%ROWTYPE;
    V_NOMBRE_DB VARCHAR2(200);
    V_EMAIL_DB VARCHAR2(200);
    V_RUT_DB NUMBER;
    V_ESTADO_OCUPADA NUMBER;
BEGIN
    IF P_RESERVA_ID IS NULL OR P_RUT IS NULL OR P_NOMBRE IS NULL OR P_EMAIL IS NULL THEN
        RAISE_APPLICATION_ERROR(-20022, 'Datos obligatorios faltantes para check-in');
    END IF;

    BEGIN
        SELECT * INTO V_RESERVA FROM JRGY_RESERVA WHERE COD_RESERVA = P_RESERVA_ID FOR UPDATE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20020, 'Reserva no encontrada');
    END;

    IF V_RESERVA.COD_USUARIO IS NULL THEN
        RAISE_APPLICATION_ERROR(-20021, 'Cliente de la reserva no encontrado');
    END IF;

    SELECT (NOMBRE_USUARIO || ' ' || NVL(APELLIDO1_USUARIO, '') || ' ' || NVL(APELLIDO2_USUARIO, '')) AS NOMBRE_COMPLETO,
           LOWER(TRIM(EMAIL_USUARIO)),
           COD_USUARIO
    INTO V_NOMBRE_DB, V_EMAIL_DB, V_RUT_DB
    FROM JRGY_USUARIO
    WHERE COD_USUARIO = V_RESERVA.COD_USUARIO;

    -- Normaliza nombre: compara solo primer nombre para evitar rechazos por apellidos/caso.
    V_NOMBRE_DB := LOWER(TRIM(REGEXP_REPLACE(V_NOMBRE_DB, '\\s+', ' ')));
    DECLARE
        v_input_name VARCHAR2(200) := LOWER(TRIM(REGEXP_REPLACE(P_NOMBRE, '\\s+', ' ')));
        v_input_first VARCHAR2(100);
        v_db_first VARCHAR2(100);
    BEGIN
        v_input_first := REGEXP_SUBSTR(v_input_name, '^[^ ]+');
        v_db_first := REGEXP_SUBSTR(V_NOMBRE_DB, '^[^ ]+');
        IF V_RUT_DB <> P_RUT THEN
            RAISE_APPLICATION_ERROR(-20022, 'Los datos ingresados no coinciden con el titular de la reserva');
        END IF;
        IF v_input_first IS NOT NULL AND v_db_first IS NOT NULL AND v_input_first <> v_db_first THEN
            RAISE_APPLICATION_ERROR(-20022, 'Los datos ingresados no coinciden con el titular de la reserva');
        END IF;
        IF LOWER(TRIM(P_EMAIL)) <> V_EMAIL_DB THEN
            RAISE_APPLICATION_ERROR(-20022, 'Los datos ingresados no coinciden con el titular de la reserva');
        END IF;
    END;

    SELECT COD_ESTADO_RESERVA INTO V_COD_ESTADO_EN_PROCESO
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'EN PROCESO';

    SELECT COD_ESTADO_HABITACION INTO V_ESTADO_OCUPADA
    FROM JRGY_CAT_ESTADO_HABITACION
    WHERE UPPER(ESTADO_HABITACION) = 'OCUPADA';

    UPDATE JRGY_RESERVA
    SET COD_ESTADO_RESERVA = V_COD_ESTADO_EN_PROCESO,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    UPDATE JRGY_HABITACION
    SET COD_USUARIO_OCUPANTE = V_RESERVA.COD_USUARIO,
        COD_ESTADO_HABITACION = V_ESTADO_OCUPADA
    WHERE COD_HABITACION = V_RESERVA.COD_HABITACION;

    INSERT INTO JRGY_EVENTO_RESERVA (COD_RESERVA, TIPO_EVENTO, FECHA_EVENTO, NOTAS, CREATED_BY)
    VALUES (P_RESERVA_ID, 'CHECK-IN', SYSDATE, 'Check-in validado con RUT', P_USER_ID);

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_CHECKOUT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_CHECKOUT" (
    P_RESERVA_ID IN NUMBER,
    P_RUT IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_EMAIL IN VARCHAR2,
    P_USER_ID IN NUMBER
)
IS
    V_COD_ESTADO_FINALIZADA NUMBER;
    V_RESERVA JRGY_RESERVA%ROWTYPE;
    V_NOMBRE_DB VARCHAR2(200);
    V_EMAIL_DB VARCHAR2(200);
    V_RUT_DB NUMBER;
    V_TOTAL_SERV NUMBER := 0;
    V_ESTADO_LIBRE NUMBER;
BEGIN
    IF P_RESERVA_ID IS NULL OR P_RUT IS NULL OR P_NOMBRE IS NULL OR P_EMAIL IS NULL THEN
        RAISE_APPLICATION_ERROR(-20022, 'Datos obligatorios faltantes para check-out');
    END IF;

    BEGIN
        SELECT * INTO V_RESERVA FROM JRGY_RESERVA WHERE COD_RESERVA = P_RESERVA_ID FOR UPDATE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20020, 'Reserva no encontrada');
    END;

    IF V_RESERVA.COD_USUARIO IS NULL THEN
        RAISE_APPLICATION_ERROR(-20021, 'Cliente de la reserva no encontrado');
    END IF;

    SELECT (NOMBRE_USUARIO || ' ' || NVL(APELLIDO1_USUARIO, '') || ' ' || NVL(APELLIDO2_USUARIO, '')) AS NOMBRE_COMPLETO,
           LOWER(TRIM(EMAIL_USUARIO)),
           COD_USUARIO
    INTO V_NOMBRE_DB, V_EMAIL_DB, V_RUT_DB
    FROM JRGY_USUARIO
    WHERE COD_USUARIO = V_RESERVA.COD_USUARIO;

    V_NOMBRE_DB := LOWER(TRIM(REGEXP_REPLACE(V_NOMBRE_DB, '\\s+', ' ')));
    DECLARE
        v_input_name VARCHAR2(200) := LOWER(TRIM(REGEXP_REPLACE(P_NOMBRE, '\\s+', ' ')));
        v_input_first VARCHAR2(100);
        v_db_first VARCHAR2(100);
    BEGIN
        v_input_first := REGEXP_SUBSTR(v_input_name, '^[^ ]+');
        v_db_first := REGEXP_SUBSTR(V_NOMBRE_DB, '^[^ ]+');
        IF V_RUT_DB <> P_RUT THEN
            RAISE_APPLICATION_ERROR(-20022, 'Los datos ingresados no coinciden con el titular de la reserva');
        END IF;
        IF v_input_first IS NOT NULL AND v_db_first IS NOT NULL AND v_input_first <> v_db_first THEN
            RAISE_APPLICATION_ERROR(-20022, 'Los datos ingresados no coinciden con el titular de la reserva');
        END IF;
        IF LOWER(TRIM(P_EMAIL)) <> V_EMAIL_DB THEN
            RAISE_APPLICATION_ERROR(-20022, 'Los datos ingresados no coinciden con el titular de la reserva');
        END IF;
    END;

    SELECT COD_ESTADO_RESERVA INTO V_COD_ESTADO_FINALIZADA
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'FINALIZADA';

    SELECT COD_ESTADO_HABITACION INTO V_ESTADO_LIBRE
    FROM JRGY_CAT_ESTADO_HABITACION
    WHERE UPPER(ESTADO_HABITACION) = 'LIBRE';

    -- Recalcula totales de servicios antes de finalizar
    SELECT NVL(SUM(TOTAL), 0) INTO V_TOTAL_SERV
    FROM JRGY_RESERVA_SERVICIO
    WHERE COD_RESERVA = P_RESERVA_ID
      AND LOWER(NVL(ESTADO, '')) <> 'cancelado';

    UPDATE JRGY_RESERVA
    SET TOTAL_SERVICIOS = V_TOTAL_SERV,
        TOTAL = NVL(TOTAL_HABITACION, 0) + V_TOTAL_SERV
    WHERE COD_RESERVA = P_RESERVA_ID;

    UPDATE JRGY_RESERVA
    SET COD_ESTADO_RESERVA = V_COD_ESTADO_FINALIZADA,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    UPDATE JRGY_HABITACION
    SET COD_USUARIO_OCUPANTE = NULL,
        COD_ESTADO_HABITACION = V_ESTADO_LIBRE
    WHERE COD_HABITACION = V_RESERVA.COD_HABITACION;

    INSERT INTO JRGY_EVENTO_RESERVA (COD_RESERVA, TIPO_EVENTO, FECHA_EVENTO, NOTAS, CREATED_BY)
    VALUES (P_RESERVA_ID, 'CHECK-OUT', SYSDATE, 'Check-out validado con RUT', P_USER_ID);

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_CREAR" (
    P_USER_ID IN NUMBER,
    P_HAB_ID IN NUMBER,
    P_FECHA_INICIO IN DATE,
    P_FECHA_FIN IN DATE,
    P_HUESPEDES IN NUMBER,
    P_ID OUT NUMBER
)
IS
    V_CAPACIDAD NUMBER;
    V_PRECIO_BASE NUMBER;
    V_ESTADO_CREADA NUMBER;
    V_NOCHES NUMBER;
    V_TOTAL NUMBER;
BEGIN
    SELECT CAPACIDAD, PRECIO_BASE INTO V_CAPACIDAD, V_PRECIO_BASE
    FROM JRGY_HABITACION WHERE COD_HABITACION = P_HAB_ID;

    IF P_HUESPEDES > NVL(V_CAPACIDAD, 0) THEN
        RAISE_APPLICATION_ERROR(-20090, 'CAPACIDAD EXCEDIDA');
    END IF;

    SELECT COD_ESTADO_RESERVA INTO V_ESTADO_CREADA
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE UPPER(ESTADO_RESERVA) = 'CREADA';

    V_NOCHES := GREATEST(1, CEIL(P_FECHA_FIN - P_FECHA_INICIO));
    V_TOTAL := V_PRECIO_BASE * V_NOCHES;

    INSERT INTO JRGY_RESERVA(
        COD_USUARIO, COD_HABITACION, FECHA_INICIO, FECHA_FIN,
        HUESPEDES, TOTAL_HABITACION, TOTAL_SERVICIOS, TOTAL, COD_ESTADO_RESERVA, CREATED_AT
    ) VALUES (
        P_USER_ID, P_HAB_ID, P_FECHA_INICIO, P_FECHA_FIN,
        P_HUESPEDES, V_TOTAL, 0, V_TOTAL, V_ESTADO_CREADA, SYSDATE
    )
    RETURNING COD_RESERVA INTO P_ID;

    INSERT INTO JRGY_EVENTO_RESERVA (COD_RESERVA, TIPO_EVENTO, FECHA_EVENTO, NOTAS, CREATED_BY)
    VALUES (P_ID, 'CREADA', SYSDATE, 'Reserva creada', P_USER_ID);

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20091, 'HABITACION NO ENCONTRADA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_LISTAR" (
    P_USER_ID IN NUMBER,
    P_ES_ADMIN IN NUMBER,
    CUR_RESERVAS OUT SYS_REFCURSOR
)
IS
BEGIN
    IF P_ES_ADMIN = 1 THEN
        OPEN CUR_RESERVAS FOR
            SELECT
                r.COD_RESERVA,
                r.COD_USUARIO,
                r.COD_HABITACION,
                r.FECHA_INICIO,
                r.FECHA_FIN,
                r.HUESPEDES,
                r.TOTAL_HABITACION,
                r.TOTAL_SERVICIOS,
                r.TOTAL,
                r.COD_ESTADO_RESERVA,
                h.NRO_HABITACION,
                t.TIPO_HABITACION,
                e.ESTADO_RESERVA,
                u.NOMBRE_USUARIO,
                u.APELLIDO1_USUARIO,
                u.APELLIDO2_USUARIO,
                u.EMAIL_USUARIO
            FROM JRGY_RESERVA r
            LEFT JOIN JRGY_HABITACION h ON h.COD_HABITACION = r.COD_HABITACION
            LEFT JOIN JRGY_CAT_TIPO_HABITACION t ON t.COD_TIPO_HABITACION = h.COD_TIPO_HABITACION
            LEFT JOIN JRGY_CAT_ESTADO_RESERVA e ON e.COD_ESTADO_RESERVA = r.COD_ESTADO_RESERVA
            LEFT JOIN JRGY_USUARIO u ON u.COD_USUARIO = r.COD_USUARIO
            ORDER BY r.FECHA_INICIO DESC;
    ELSE
        OPEN CUR_RESERVAS FOR
            SELECT
                r.COD_RESERVA,
                r.COD_USUARIO,
                r.COD_HABITACION,
                r.FECHA_INICIO,
                r.FECHA_FIN,
                r.HUESPEDES,
                r.TOTAL_HABITACION,
                r.TOTAL_SERVICIOS,
                r.TOTAL,
                r.COD_ESTADO_RESERVA,
                h.NRO_HABITACION,
                t.TIPO_HABITACION,
                e.ESTADO_RESERVA,
                u.NOMBRE_USUARIO,
                u.APELLIDO1_USUARIO,
                u.APELLIDO2_USUARIO,
                u.EMAIL_USUARIO
            FROM JRGY_RESERVA r
            LEFT JOIN JRGY_HABITACION h ON h.COD_HABITACION = r.COD_HABITACION
            LEFT JOIN JRGY_CAT_TIPO_HABITACION t ON t.COD_TIPO_HABITACION = h.COD_TIPO_HABITACION
            LEFT JOIN JRGY_CAT_ESTADO_RESERVA e ON e.COD_ESTADO_RESERVA = r.COD_ESTADO_RESERVA
            LEFT JOIN JRGY_USUARIO u ON u.COD_USUARIO = r.COD_USUARIO
            WHERE r.COD_USUARIO = P_USER_ID
            ORDER BY r.FECHA_INICIO DESC;
    END IF;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_SERVICIO_ADD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_SERVICIO_ADD" (
    P_RESERVA_ID IN NUMBER,
    P_SERVICIO_ID IN NUMBER,
    P_FECHA_SERVICIO IN DATE,
    P_HORA IN NUMBER,
    P_CANTIDAD IN NUMBER,
    P_NOTA IN VARCHAR2,
    P_ID OUT NUMBER
)
IS
    V_PRECIO NUMBER;
    V_ESTADO_SERVICIO VARCHAR2(20);
    V_FI DATE;
    V_FF DATE;
    V_MATCH NUMBER := 0;
    V_TIENE_HORARIOS NUMBER := 0;
    V_TOTAL_SERV NUMBER;
BEGIN
    SELECT PRECIO, ESTADO INTO V_PRECIO, V_ESTADO_SERVICIO
    FROM JRGY_SERVICIO WHERE COD_SERVICIO = P_SERVICIO_ID;

    IF LOWER(V_ESTADO_SERVICIO) <> 'activo' THEN
        RAISE_APPLICATION_ERROR(-20084, 'SERVICIO INACTIVO');
    END IF;

    SELECT FECHA_INICIO, FECHA_FIN INTO V_FI, V_FF
    FROM JRGY_RESERVA WHERE COD_RESERVA = P_RESERVA_ID;

    IF P_FECHA_SERVICIO < V_FI OR P_FECHA_SERVICIO > V_FF THEN
        RAISE_APPLICATION_ERROR(-20085, 'FECHA FUERA DEL RANGO DE LA RESERVA');
    END IF;

    IF P_HORA < 0 OR P_HORA > 23 THEN
        RAISE_APPLICATION_ERROR(-20086, 'HORA INVALIDA');
    END IF;

    SELECT COUNT(*) INTO V_MATCH
    FROM JRGY_SERVICIO_HORARIO
    WHERE COD_SERVICIO = P_SERVICIO_ID
      AND P_HORA BETWEEN HORA_INICIO AND HORA_FIN;

    SELECT COUNT(*) INTO V_TIENE_HORARIOS FROM JRGY_SERVICIO_HORARIO WHERE COD_SERVICIO = P_SERVICIO_ID;

    IF V_TIENE_HORARIOS > 0 AND V_MATCH = 0 THEN
        RAISE_APPLICATION_ERROR(-20087, 'HORA FUERA DEL HORARIO PERMITIDO');
    END IF;

    INSERT INTO JRGY_RESERVA_SERVICIO(
        COD_RESERVA, COD_SERVICIO, FECHA_SERVICIO, HORA, CANTIDAD, PRECIO_UNIT, TOTAL, NOTA, ESTADO, CREATED_AT
    ) VALUES (
        P_RESERVA_ID, P_SERVICIO_ID, P_FECHA_SERVICIO, P_HORA, P_CANTIDAD, V_PRECIO, P_CANTIDAD * V_PRECIO, P_NOTA, 'pendiente', SYSDATE
    )
    RETURNING COD_RESERVA_SERVICIO INTO P_ID;

    SELECT NVL(SUM(TOTAL), 0) INTO V_TOTAL_SERV
    FROM JRGY_RESERVA_SERVICIO
    WHERE COD_RESERVA = P_RESERVA_ID AND LOWER(ESTADO) <> 'cancelado';

    UPDATE JRGY_RESERVA
    SET TOTAL_SERVICIOS = V_TOTAL_SERV,
        TOTAL = NVL(TOTAL_HABITACION, 0) + V_TOTAL_SERV,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20088, 'RESERVA O SERVICIO NO ENCONTRADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_SERVICIO_CANCELAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_SERVICIO_CANCELAR" (
    P_ITEM_ID IN NUMBER,
    P_RESERVA_ID IN NUMBER
)
IS
    V_TOTAL_SERV NUMBER;
BEGIN
    UPDATE JRGY_RESERVA_SERVICIO
    SET ESTADO = 'cancelado',
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA_SERVICIO = P_ITEM_ID
      AND COD_RESERVA = P_RESERVA_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20089, 'SERVICIO DE RESERVA NO ENCONTRADO');
    END IF;

    SELECT NVL(SUM(TOTAL), 0) INTO V_TOTAL_SERV
    FROM JRGY_RESERVA_SERVICIO
    WHERE COD_RESERVA = P_RESERVA_ID AND LOWER(ESTADO) <> 'cancelado';

    UPDATE JRGY_RESERVA
    SET TOTAL_SERVICIOS = V_TOTAL_SERV,
        TOTAL = NVL(TOTAL_HABITACION, 0) + V_TOTAL_SERV,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_SERVICIO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_SERVICIO_LISTAR" (
    P_RESERVA_ID IN NUMBER,
    CUR_SERV OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_SERV FOR
        SELECT
            rs.COD_RESERVA_SERVICIO,
            rs.COD_RESERVA,
            rs.COD_SERVICIO,
            s.NOMBRE,
            s.COD_TIPO_SERVICIO,
            ts.NOMBRE AS TIPO_SERVICIO,
            rs.FECHA_SERVICIO,
            rs.HORA,
            rs.CANTIDAD,
            rs.PRECIO_UNIT,
            rs.TOTAL,
            rs.NOTA,
            rs.ESTADO,
            rs.CREATED_AT,
            rs.UPDATED_AT
        FROM JRGY_RESERVA_SERVICIO rs
        LEFT JOIN JRGY_SERVICIO s ON s.COD_SERVICIO = rs.COD_SERVICIO
        LEFT JOIN JRGY_CAT_TIPO_SERVICIO ts ON ts.COD_TIPO_SERVICIO = s.COD_TIPO_SERVICIO
        WHERE rs.COD_RESERVA = P_RESERVA_ID
        ORDER BY rs.FECHA_SERVICIO, rs.HORA;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_SERVICIO_UPD
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_SERVICIO_UPD" (
    P_ITEM_ID IN NUMBER,
    P_RESERVA_ID IN NUMBER,
    P_FECHA_SERVICIO IN DATE,
    P_HORA IN NUMBER,
    P_CANTIDAD IN NUMBER,
    P_NOTA IN VARCHAR2,
    P_ESTADO IN VARCHAR2
)
IS
    V_SERV_ID NUMBER;
    V_PRECIO NUMBER;
    V_FI DATE;
    V_FF DATE;
    V_MATCH NUMBER := 0;
    V_TIENE_HORARIOS NUMBER := 0;
    V_TOTAL_SERV NUMBER;
BEGIN
    SELECT COD_SERVICIO, PRECIO_UNIT INTO V_SERV_ID, V_PRECIO
    FROM JRGY_RESERVA_SERVICIO
    WHERE COD_RESERVA_SERVICIO = P_ITEM_ID AND COD_RESERVA = P_RESERVA_ID FOR UPDATE;

    SELECT FECHA_INICIO, FECHA_FIN INTO V_FI, V_FF
    FROM JRGY_RESERVA WHERE COD_RESERVA = P_RESERVA_ID;

    IF P_FECHA_SERVICIO < V_FI OR P_FECHA_SERVICIO > V_FF THEN
        RAISE_APPLICATION_ERROR(-20085, 'FECHA FUERA DEL RANGO DE LA RESERVA');
    END IF;

    IF P_HORA < 0 OR P_HORA > 23 THEN
        RAISE_APPLICATION_ERROR(-20086, 'HORA INVALIDA');
    END IF;

    SELECT COUNT(*) INTO V_MATCH
    FROM JRGY_SERVICIO_HORARIO
    WHERE COD_SERVICIO = V_SERV_ID
      AND P_HORA BETWEEN HORA_INICIO AND HORA_FIN;

    SELECT COUNT(*) INTO V_TIENE_HORARIOS FROM JRGY_SERVICIO_HORARIO WHERE COD_SERVICIO = V_SERV_ID;

    IF V_TIENE_HORARIOS > 0 AND V_MATCH = 0 THEN
        RAISE_APPLICATION_ERROR(-20087, 'HORA FUERA DEL HORARIO PERMITIDO');
    END IF;

    UPDATE JRGY_RESERVA_SERVICIO
    SET FECHA_SERVICIO = P_FECHA_SERVICIO,
        HORA = P_HORA,
        CANTIDAD = P_CANTIDAD,
        NOTA = P_NOTA,
        ESTADO = NVL(P_ESTADO, ESTADO),
        TOTAL = P_CANTIDAD * V_PRECIO,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA_SERVICIO = P_ITEM_ID AND COD_RESERVA = P_RESERVA_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20089, 'SERVICIO DE RESERVA NO ENCONTRADO');
    END IF;

    SELECT NVL(SUM(TOTAL), 0) INTO V_TOTAL_SERV
    FROM JRGY_RESERVA_SERVICIO
    WHERE COD_RESERVA = P_RESERVA_ID AND LOWER(ESTADO) <> 'cancelado';

    UPDATE JRGY_RESERVA
    SET TOTAL_SERVICIOS = V_TOTAL_SERV,
        TOTAL = NVL(TOTAL_HABITACION, 0) + V_TOTAL_SERV,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_RESERVA_SOLICITAR_CHECKOUT
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_RESERVA_SOLICITAR_CHECKOUT" (
    P_RESERVA_ID IN NUMBER,
    P_USER_ID IN NUMBER
)
IS
    V_RESERVA JRGY_RESERVA%ROWTYPE;
    V_ESTADO_EN_PROCESO NUMBER;
    V_ESTADO_CHECKOUT_SOL NUMBER;
    V_ESTADO_FINALIZADA NUMBER;
    V_ESTADO_CANCELADA NUMBER;
BEGIN
    IF P_RESERVA_ID IS NULL THEN
        RAISE_APPLICATION_ERROR(-20022, 'Datos obligatorios faltantes para solicitar check-out');
    END IF;

    BEGIN
        SELECT * INTO V_RESERVA FROM JRGY_RESERVA WHERE COD_RESERVA = P_RESERVA_ID FOR UPDATE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20020, 'Reserva no encontrada');
    END;

    SELECT COD_ESTADO_RESERVA INTO V_ESTADO_EN_PROCESO
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'EN PROCESO';

    SELECT COD_ESTADO_RESERVA INTO V_ESTADO_CHECKOUT_SOL
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CHECKOUT SOLICITADO';

    SELECT COD_ESTADO_RESERVA INTO V_ESTADO_FINALIZADA
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'FINALIZADA';

    SELECT COD_ESTADO_RESERVA INTO V_ESTADO_CANCELADA
    FROM JRGY_CAT_ESTADO_RESERVA
    WHERE REPLACE(UPPER(ESTADO_RESERVA), '_', ' ') = 'CANCELADA';

    IF V_RESERVA.COD_ESTADO_RESERVA = V_ESTADO_CHECKOUT_SOL THEN
        RAISE_APPLICATION_ERROR(-20024, 'El check-out ya fue solicitado');
    END IF;

    IF V_RESERVA.COD_ESTADO_RESERVA = V_ESTADO_FINALIZADA OR V_RESERVA.COD_ESTADO_RESERVA = V_ESTADO_CANCELADA THEN
        RAISE_APPLICATION_ERROR(-20023, 'La reserva no permite solicitar check-out');
    END IF;

    IF V_RESERVA.COD_ESTADO_RESERVA <> V_ESTADO_EN_PROCESO THEN
        RAISE_APPLICATION_ERROR(-20023, 'Solo se puede solicitar check-out cuando la reserva estÔøΩÔøΩ en proceso');
    END IF;

    UPDATE JRGY_RESERVA
    SET COD_ESTADO_RESERVA = V_ESTADO_CHECKOUT_SOL,
        UPDATED_AT = SYSDATE
    WHERE COD_RESERVA = P_RESERVA_ID;

    INSERT INTO JRGY_EVENTO_RESERVA (COD_RESERVA, TIPO_EVENTO, FECHA_EVENTO, NOTAS, CREATED_BY)
    VALUES (P_RESERVA_ID, 'CHECK-OUT SOLICITADO', SYSDATE, 'Solicitado por el cliente', P_USER_ID);

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_ROL_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_ROL_CREAR" (
    P_NOMBRE IN VARCHAR2
)
IS
BEGIN
    INSERT INTO JRGY_ROL (NOMBRE_ROL) VALUES (P_NOMBRE);
    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20095, 'ROL DUPLICADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_ROL_ELIMINAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_ROL_ELIMINAR" (
    P_ID IN NUMBER
)
IS
BEGIN
    DELETE FROM JRGY_ROL WHERE COD_ROL = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20020, 'ROL NO ENCONTRADO');
    END IF;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_ROL_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_ROL_LISTAR" (
    CUR_ROL OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_ROL FOR
        SELECT COD_ROL, NOMBRE_ROL FROM JRGY_ROL ORDER BY COD_ROL;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_ROL_SANITIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_ROL_SANITIZAR" (
    P_ALLOWED_JSON IN CLOB DEFAULT '[\"ADMIN\",\"EMPLOYEE\",\"USER\"]'
)
IS
    V_NEXT NUMBER;
    V_CURR NUMBER;
BEGIN
    -- Quita asignaciones a roles no permitidos
    DELETE FROM JRGY_USUARIO_ROL
    WHERE COD_ROL IN (
        SELECT COD_ROL
        FROM JRGY_ROL
        WHERE UPPER(NOMBRE_ROL) NOT IN (
            SELECT UPPER(nombre)
            FROM JSON_TABLE(P_ALLOWED_JSON, '$[*]'
                COLUMNS(nombre VARCHAR2(100) PATH '$')
            )
        )
    );

    -- Borra roles no permitidos
    DELETE FROM JRGY_ROL
    WHERE UPPER(NOMBRE_ROL) NOT IN (
        SELECT UPPER(nombre)
        FROM JSON_TABLE(P_ALLOWED_JSON, '$[*]'
            COLUMNS(nombre VARCHAR2(100) PATH '$')
        )
    );

    -- Inserta roles faltantes
    FOR rec IN (
        SELECT DISTINCT UPPER(nombre) AS NOMBRE
        FROM JSON_TABLE(P_ALLOWED_JSON, '$[*]'
            COLUMNS(nombre VARCHAR2(100) PATH '$')
        )
    ) LOOP
        BEGIN
            INSERT INTO JRGY_ROL (NOMBRE_ROL) VALUES (rec.NOMBRE);
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                NULL;
        END;
    END LOOP;

    -- Deduplica roles permitidos dejando un solo registro por nombre
    DELETE FROM JRGY_USUARIO_ROL
    WHERE COD_ROL IN (
        SELECT COD_ROL
        FROM (
            SELECT COD_ROL, ROW_NUMBER() OVER (PARTITION BY UPPER(NOMBRE_ROL) ORDER BY COD_ROL) AS RN
            FROM JRGY_ROL
        )
        WHERE RN > 1
    );

    DELETE FROM JRGY_ROL
    WHERE COD_ROL IN (
        SELECT COD_ROL
        FROM (
            SELECT COD_ROL, ROW_NUMBER() OVER (PARTITION BY UPPER(NOMBRE_ROL) ORDER BY COD_ROL) AS RN
            FROM JRGY_ROL
        )
        WHERE RN > 1
    );

    -- Ajusta la secuencia al siguiente valor libre
    SELECT NVL(MAX(COD_ROL), 0) + 1 INTO V_NEXT FROM JRGY_ROL;
    BEGIN
        SELECT last_number INTO V_CURR FROM user_sequences WHERE sequence_name = 'SQ_PK_ROL';
        IF V_CURR < V_NEXT THEN
            EXECUTE IMMEDIATE 'ALTER SEQUENCE SQ_PK_ROL INCREMENT BY ' || (V_NEXT - V_CURR);
            EXECUTE IMMEDIATE 'SELECT SQ_PK_ROL.NEXTVAL FROM dual' INTO V_CURR;
            EXECUTE IMMEDIATE 'ALTER SEQUENCE SQ_PK_ROL INCREMENT BY 1';
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
    END;

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_DESCRIPCION IN VARCHAR2,
    P_PRECIO IN NUMBER,
    P_TIPO_ID IN NUMBER,
    P_ESTADO IN VARCHAR2,
    P_DESTACADO IN CHAR,
    P_ORDEN IN NUMBER,
    P_HORARIOS_JSON IN CLOB
)
IS
    V_EXPECTED NUMBER := 0;
    V_INSERTED NUMBER := 0;
BEGIN
    UPDATE JRGY_SERVICIO
    SET NOMBRE = P_NOMBRE,
        DESCRIPCION = P_DESCRIPCION,
        PRECIO = P_PRECIO,
        COD_TIPO_SERVICIO = P_TIPO_ID,
        ESTADO = P_ESTADO,
        ES_DESTACADO = P_DESTACADO,
        ORDEN = P_ORDEN,
        UPDATED_AT = SYSDATE
    WHERE COD_SERVICIO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'SERVICIO NO ENCONTRADO');
    END IF;

    DELETE FROM JRGY_SERVICIO_HORARIO WHERE COD_SERVICIO = P_ID;

    IF P_HORARIOS_JSON IS NOT NULL THEN
        SELECT COUNT(*) INTO V_EXPECTED
        FROM JSON_TABLE(
            P_HORARIOS_JSON,
            '$[*]' COLUMNS(
                HORA_INICIO NUMBER PATH '$.inicio',
                HORA_FIN NUMBER PATH '$.fin'
            )
        );

        INSERT INTO JRGY_SERVICIO_HORARIO (COD_SERVICIO, HORA_INICIO, HORA_FIN)
        SELECT P_ID, HORA_INICIO, HORA_FIN
        FROM JSON_TABLE(
            P_HORARIOS_JSON,
            '$[*]' COLUMNS(
                HORA_INICIO NUMBER PATH '$.inicio',
                HORA_FIN NUMBER PATH '$.fin'
            )
        )
        WHERE HORA_INICIO BETWEEN 0 AND 23.99
          AND HORA_FIN BETWEEN 0 AND 23.99
          AND HORA_FIN >= HORA_INICIO;

        SELECT COUNT(*) INTO V_INSERTED FROM JRGY_SERVICIO_HORARIO WHERE COD_SERVICIO = P_ID;

        IF V_EXPECTED <> V_INSERTED THEN
            RAISE_APPLICATION_ERROR(-20081, 'HORARIO INVALIDO, USE HORAS 0-23 Y FIN >= INICIO');
        END IF;
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_BORRAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_BORRAR" (
    P_ID IN NUMBER
)
IS
    V_COUNT_RES NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO V_COUNT_RES FROM JRGY_RESERVA_SERVICIO WHERE COD_SERVICIO = P_ID;
    IF V_COUNT_RES > 0 THEN
        RAISE_APPLICATION_ERROR(-20098, 'NO SE PUEDE ELIMINAR: SERVICIO TIENE RESERVAS ASOCIADAS');
    END IF;

    DELETE FROM JRGY_SERVICIO_HORARIO WHERE COD_SERVICIO = P_ID;
    DELETE FROM JRGY_SERVICIO WHERE COD_SERVICIO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'SERVICIO NO ENCONTRADO');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_CAMBIAR_ESTADO
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_CAMBIAR_ESTADO" (
    P_ID IN NUMBER,
    P_ESTADO IN VARCHAR2
)
IS
BEGIN
    UPDATE JRGY_SERVICIO
    SET ESTADO = LOWER(P_ESTADO),
        UPDATED_AT = SYSDATE
    WHERE COD_SERVICIO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'SERVICIO NO ENCONTRADO');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_CREAR" (
    P_NOMBRE IN VARCHAR2,
    P_DESCRIPCION IN VARCHAR2,
    P_PRECIO IN NUMBER,
    P_TIPO_ID IN NUMBER,
    P_ESTADO IN VARCHAR2,
    P_DESTACADO IN CHAR,
    P_ORDEN IN NUMBER,
    P_HORARIOS_JSON IN CLOB,
    P_ID OUT NUMBER
)
IS
    V_EXPECTED NUMBER := 0;
    V_INSERTED NUMBER := 0;
BEGIN
    INSERT INTO JRGY_SERVICIO (
        NOMBRE, DESCRIPCION, PRECIO, COD_TIPO_SERVICIO, ESTADO, ES_DESTACADO, ORDEN, CREATED_AT
    ) VALUES (
        P_NOMBRE, P_DESCRIPCION, P_PRECIO, P_TIPO_ID, P_ESTADO, P_DESTACADO, P_ORDEN, SYSDATE
    )
    RETURNING COD_SERVICIO INTO P_ID;

    IF P_HORARIOS_JSON IS NOT NULL THEN
        SELECT COUNT(*) INTO V_EXPECTED
        FROM JSON_TABLE(
            P_HORARIOS_JSON,
            '$[*]' COLUMNS(
                HORA_INICIO NUMBER PATH '$.inicio',
                HORA_FIN NUMBER PATH '$.fin'
            )
        );

        INSERT INTO JRGY_SERVICIO_HORARIO (COD_SERVICIO, HORA_INICIO, HORA_FIN)
        SELECT P_ID, HORA_INICIO, HORA_FIN
        FROM JSON_TABLE(
            P_HORARIOS_JSON,
            '$[*]' COLUMNS(
                HORA_INICIO NUMBER PATH '$.inicio',
                HORA_FIN NUMBER PATH '$.fin'
            )
        )
        WHERE HORA_INICIO BETWEEN 0 AND 23.99
          AND HORA_FIN BETWEEN 0 AND 23.99
          AND HORA_FIN >= HORA_INICIO;

        SELECT COUNT(*) INTO V_INSERTED FROM JRGY_SERVICIO_HORARIO WHERE COD_SERVICIO = P_ID;

        IF V_EXPECTED <> V_INSERTED THEN
            RAISE_APPLICATION_ERROR(-20081, 'HORARIO INVALIDO, USE HORAS 0-23 Y FIN >= INICIO');
        END IF;
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_ELIMINAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_ELIMINAR" (
    P_ID IN NUMBER
)
IS
BEGIN
    UPDATE JRGY_SERVICIO
    SET ESTADO = 'inactivo',
        UPDATED_AT = SYSDATE
    WHERE COD_SERVICIO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20083, 'SERVICIO NO ENCONTRADO');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_HORARIOS_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_HORARIOS_LISTAR" (
    CUR_HOR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_HOR FOR
        SELECT COD_HORARIO, COD_SERVICIO, HORA_INICIO, HORA_FIN
        FROM JRGY_SERVICIO_HORARIO
        ORDER BY COD_SERVICIO, HORA_INICIO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_LISTAR" (
    P_INCLUDE_INACTIVE IN NUMBER,
    CUR_SERVICIOS OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_SERVICIOS FOR
        SELECT
            s.COD_SERVICIO,
            s.NOMBRE,
            s.DESCRIPCION,
            s.PRECIO,
            s.COD_TIPO_SERVICIO,
            ts.NOMBRE AS TIPO_SERVICIO,
            s.ESTADO,
            s.ES_DESTACADO,
            s.ORDEN,
            s.CREATED_AT,
            s.UPDATED_AT
        FROM JRGY_SERVICIO s
        LEFT JOIN JRGY_CAT_TIPO_SERVICIO ts ON ts.COD_TIPO_SERVICIO = s.COD_TIPO_SERVICIO
        WHERE (P_INCLUDE_INACTIVE = 1 OR LOWER(s.ESTADO) = 'activo')
        ORDER BY NVL(s.ES_DESTACADO, 'N') DESC, NVL(s.ORDEN, 9999), s.COD_SERVICIO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_OBTENER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_OBTENER" (
    P_ID IN NUMBER,
    CUR_SERV OUT SYS_REFCURSOR,
    CUR_HOR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_SERV FOR
        SELECT
            s.COD_SERVICIO,
            s.NOMBRE,
            s.DESCRIPCION,
            s.PRECIO,
            s.COD_TIPO_SERVICIO,
            ts.NOMBRE AS TIPO_SERVICIO,
            s.ESTADO,
            s.ES_DESTACADO,
            s.ORDEN,
            s.CREATED_AT,
            s.UPDATED_AT
        FROM JRGY_SERVICIO s
        LEFT JOIN JRGY_CAT_TIPO_SERVICIO ts ON ts.COD_TIPO_SERVICIO = s.COD_TIPO_SERVICIO
        WHERE s.COD_SERVICIO = P_ID;

    OPEN CUR_HOR FOR
        SELECT COD_HORARIO, COD_SERVICIO, HORA_INICIO, HORA_FIN
        FROM JRGY_SERVICIO_HORARIO
        WHERE COD_SERVICIO = P_ID
        ORDER BY HORA_INICIO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_PRODUCTO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_PRODUCTO_LISTAR" (
    P_SERVICIO_ID IN NUMBER,
    CUR OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR FOR
        SELECT
            sp.COD_SERVICIO,
            sp.COD_PRODUCTO,
            p.NOMBRE_PRODUCTO,
            sp.CANTIDAD_BASE,
            sp.PRECIO_EXTRA,
            p.STOCK_PRODUCTO,
            p.UMBRAL_ALERTA,
            CASE WHEN p.UMBRAL_ALERTA IS NOT NULL AND NVL(p.STOCK_PRODUCTO,0) <= p.UMBRAL_ALERTA THEN 1 ELSE 0 END AS ALERTA_ACTIVA
        FROM JRGY_SERVICIO_PRODUCTO sp
        JOIN JRGY_PRODUCTO p ON p.COD_PRODUCTO = sp.COD_PRODUCTO
        WHERE sp.COD_SERVICIO = P_SERVICIO_ID
        ORDER BY p.NOMBRE_PRODUCTO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SERVICIO_PRODUCTO_REEMPLAZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SERVICIO_PRODUCTO_REEMPLAZAR" (
    P_SERVICIO_ID IN NUMBER,
    P_ITEMS_JSON IN CLOB
)
IS
    V_COUNT NUMBER;
BEGIN
    SELECT COUNT(*) INTO V_COUNT FROM JRGY_SERVICIO WHERE COD_SERVICIO = P_SERVICIO_ID;
    IF V_COUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20082, 'SERVICIO NO ENCONTRADO');
    END IF;

    DELETE FROM JRGY_SERVICIO_PRODUCTO WHERE COD_SERVICIO = P_SERVICIO_ID;

    FOR rec IN (
        SELECT
            jt.productoId AS COD_PRODUCTO,
            jt.cantidad AS CANTIDAD_BASE,
            jt.precioExtra AS PRECIO_EXTRA
        FROM JSON_TABLE(P_ITEMS_JSON, '$[*]'
            COLUMNS (
                productoId NUMBER PATH '$.productoId',
                cantidad NUMBER PATH '$.cantidad',
                precioExtra NUMBER PATH '$.precioExtra'
            )
        ) jt
    ) LOOP
        INSERT INTO JRGY_SERVICIO_PRODUCTO (COD_SERVICIO, COD_PRODUCTO, CANTIDAD_BASE, PRECIO_EXTRA)
        VALUES (P_SERVICIO_ID, rec.COD_PRODUCTO, NVL(rec.CANTIDAD_BASE,1), rec.PRECIO_EXTRA);
    END LOOP;

    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SOLICITUD_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SOLICITUD_CREAR" (
    P_USER_ID IN NUMBER,
    P_MOTIVO IN VARCHAR2
)
IS
BEGIN
    INSERT INTO JRGY_SOLICITUD_ADMIN (COD_USUARIO, ESTADO, MOTIVO, FECHA_CREACION)
    VALUES (P_USER_ID, 'pending', P_MOTIVO, SYSDATE);
    COMMIT;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SOLICITUD_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SOLICITUD_LISTAR" (
    CUR_SOL OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_SOL FOR
        SELECT s.COD_SOLICITUD, s.COD_USUARIO, s.ESTADO, s.MOTIVO, s.FECHA_CREACION, s.FECHA_RESOLUCION, s.APROBADO_POR,
               u.NOMBRE_USUARIO, u.EMAIL_USUARIO
        FROM JRGY_SOLICITUD_ADMIN s
        INNER JOIN JRGY_USUARIO u ON u.COD_USUARIO = s.COD_USUARIO
        ORDER BY s.FECHA_CREACION DESC;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_SOLICITUD_RESOLVER
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_SOLICITUD_RESOLVER" (
    P_ID IN NUMBER,
    P_ACCION IN VARCHAR2,
    P_APROBADOR IN NUMBER
)
IS
    V_ESTADO_ACTUAL VARCHAR2(20);
    V_USUARIO NUMBER;
BEGIN
    SELECT ESTADO, COD_USUARIO INTO V_ESTADO_ACTUAL, V_USUARIO
    FROM JRGY_SOLICITUD_ADMIN
    WHERE COD_SOLICITUD = P_ID
    FOR UPDATE;

    IF V_ESTADO_ACTUAL <> 'pending' THEN
        RAISE_APPLICATION_ERROR(-20096, 'SOLICITUD YA RESUELTA');
    END IF;

    UPDATE JRGY_SOLICITUD_ADMIN
    SET ESTADO = P_ACCION,
        APROBADO_POR = P_APROBADOR,
        FECHA_RESOLUCION = SYSDATE
    WHERE COD_SOLICITUD = P_ID;

    IF LOWER(P_ACCION) = 'approved' THEN
        INSERT INTO JRGY_USUARIO_ROL (COD_USUARIO, COD_ROL)
        SELECT V_USUARIO, COD_ROL FROM JRGY_ROL WHERE UPPER(NOMBRE_ROL) = 'ADMIN'
        AND NOT EXISTS (SELECT 1 FROM JRGY_USUARIO_ROL ur WHERE ur.COD_USUARIO = V_USUARIO AND ur.COD_ROL = JRGY_ROL.COD_ROL);
    END IF;

    COMMIT;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20097, 'SOLICITUD NO ENCONTRADA');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_TIPO_HAB_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_TIPO_HAB_CREAR" (
    P_NOMBRE IN VARCHAR2,
    P_ID OUT NUMBER
)
IS
    V_NOMBRE VARCHAR2(50);
BEGIN
    V_NOMBRE := UPPER(TRIM(P_NOMBRE));

    IF V_NOMBRE IS NULL THEN
        RAISE_APPLICATION_ERROR(-20121, 'NOMBRE DE TIPO REQUERIDO');
    END IF;

    BEGIN
        SELECT COD_TIPO_HABITACION INTO P_ID
        FROM JRGY_CAT_TIPO_HABITACION
        WHERE TIPO_HABITACION = V_NOMBRE;
        RETURN;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
    END;

    INSERT INTO JRGY_CAT_TIPO_HABITACION (TIPO_HABITACION)
    VALUES (V_NOMBRE)
    RETURNING COD_TIPO_HABITACION INTO P_ID;

    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        SELECT COD_TIPO_HABITACION INTO P_ID FROM JRGY_CAT_TIPO_HABITACION WHERE TIPO_HABITACION = V_NOMBRE;
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_TIPO_HAB_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_TIPO_HAB_LISTAR" (
    CUR_TIPOS OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_TIPOS FOR
        SELECT
            COD_TIPO_HABITACION AS ID,
            TIPO_HABITACION AS TIPO
        FROM JRGY_CAT_TIPO_HABITACION
        ORDER BY TIPO_HABITACION;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_UPDATE_PEDIDO_TOTAL
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_UPDATE_PEDIDO_TOTAL" (
    COD_PEDIDO_P IN JRGY_PEDIDO.COD_PEDIDO%TYPE
)
IS
    NUEVO_TOTAL JRGY_PEDIDO.VALOR_TOTAL%TYPE;
BEGIN
    SELECT NVL(SUM(PRECIO_TOTAL), 0)
    INTO NUEVO_TOTAL
    FROM JRGY_DETALLE_PEDIDO
    WHERE COD_PEDIDO = COD_PEDIDO_P;

    UPDATE JRGY_PEDIDO
    SET VALOR_TOTAL = NUEVO_TOTAL
    WHERE COD_PEDIDO = COD_PEDIDO_P;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20012, 'Pedido con cÔøΩÔøΩdigo ' || COD_PEDIDO_P || ' no encontrado.');
    END IF;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20013, 'Error al recalcular y actualizar total del pedido: ' || SQLERRM);
END JRGY_PRO_UPDATE_PEDIDO_TOTAL;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_USUARIO_ACTUALIZAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_USUARIO_ACTUALIZAR" (
    P_ID IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_AP1 IN VARCHAR2,
    P_AP2 IN VARCHAR2,
    P_TEL IN VARCHAR2,
    P_EMAIL IN VARCHAR2,
    P_PASS_HASH IN VARCHAR2,
    P_ROLES_JSON IN CLOB
)
IS
    V_ES_CLIENTE NUMBER := 0;
BEGIN
    UPDATE JRGY_USUARIO
    SET NOMBRE_USUARIO = P_NOMBRE,
        APELLIDO1_USUARIO = P_AP1,
        APELLIDO2_USUARIO = P_AP2,
        TELEFONO_USUARIO = P_TEL,
        EMAIL_USUARIO = P_EMAIL,
        CONTRASENA_HASH = NVL(P_PASS_HASH, CONTRASENA_HASH)
    WHERE COD_USUARIO = P_ID;

    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20094, 'USUARIO NO ENCONTRADO');
    END IF;

    DELETE FROM JRGY_USUARIO_ROL WHERE COD_USUARIO = P_ID;

    IF P_ROLES_JSON IS NOT NULL THEN
        SELECT COUNT(*)
        INTO V_ES_CLIENTE
        FROM JSON_TABLE(
            P_ROLES_JSON,
            '$[*]' COLUMNS(
                NOMBRE VARCHAR2(50) PATH '$'
            )
        ) jt
        WHERE UPPER(jt.NOMBRE) = 'USER';

        INSERT INTO JRGY_USUARIO_ROL (COD_USUARIO, COD_ROL)
        SELECT P_ID, r.COD_ROL
        FROM JSON_TABLE(
            P_ROLES_JSON,
            '$[*]' COLUMNS(
                NOMBRE VARCHAR2(50) PATH '$'
            )
        ) jt
        JOIN JRGY_ROL r ON UPPER(r.NOMBRE_ROL) = UPPER(jt.NOMBRE);

        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20092, 'ROLES NO VALIDOS');
        END IF;
    END IF;

    IF V_ES_CLIENTE > 0 THEN
        INSERT INTO JRGY_CLIENTE (COD_USUARIO, FECHA_ALTA)
        SELECT P_ID, SYSDATE FROM DUAL
        WHERE NOT EXISTS (SELECT 1 FROM JRGY_CLIENTE WHERE COD_USUARIO = P_ID);
    ELSE
        DELETE FROM JRGY_CLIENTE WHERE COD_USUARIO = P_ID;
    END IF;

    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        RAISE_APPLICATION_ERROR(-20093, 'EMAIL DUPLICADO');
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_USUARIO_CREAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_USUARIO_CREAR" (
    P_COD_USUARIO IN NUMBER,
    P_NOMBRE IN VARCHAR2,
    P_AP1 IN VARCHAR2,
    P_AP2 IN VARCHAR2,
    P_TEL IN VARCHAR2,
    P_EMAIL IN VARCHAR2,
    P_PASS_HASH IN VARCHAR2,
    P_ROLES_JSON IN CLOB,
    P_ID OUT NUMBER
)
IS
    V_ESTADO_ACTIVO NUMBER := 1;
    V_EXISTE NUMBER;
    V_ES_CLIENTE NUMBER := 0;
BEGIN
    IF P_COD_USUARIO IS NULL THEN
        RAISE_APPLICATION_ERROR(-20010, 'COD_USUARIO requerido (RUT sin autoincremento)');
    END IF;

    SELECT COUNT(*) INTO V_EXISTE FROM JRGY_USUARIO WHERE COD_USUARIO = P_COD_USUARIO;
    IF V_EXISTE > 0 THEN
        RAISE_APPLICATION_ERROR(-20011, 'COD_USUARIO DUPLICADO');
    END IF;

    SELECT COUNT(*) INTO V_EXISTE FROM JRGY_USUARIO WHERE LOWER(EMAIL_USUARIO) = LOWER(P_EMAIL);
    IF V_EXISTE > 0 THEN
        RAISE_APPLICATION_ERROR(-20093, 'EMAIL DUPLICADO');
    END IF;

    INSERT INTO JRGY_USUARIO (COD_USUARIO, NOMBRE_USUARIO, APELLIDO1_USUARIO, APELLIDO2_USUARIO, TELEFONO_USUARIO, EMAIL_USUARIO, CONTRASENA_HASH, COD_ESTADO_USUARIO)
    VALUES (P_COD_USUARIO, P_NOMBRE, P_AP1, P_AP2, P_TEL, P_EMAIL, P_PASS_HASH, V_ESTADO_ACTIVO);
    P_ID := P_COD_USUARIO;

    IF P_ROLES_JSON IS NOT NULL THEN
        SELECT COUNT(*)
        INTO V_ES_CLIENTE
        FROM JSON_TABLE(
            P_ROLES_JSON,
            '$[*]' COLUMNS(
                NOMBRE VARCHAR2(50) PATH '$'
            )
        ) jt
        WHERE UPPER(jt.NOMBRE) = 'USER';

        INSERT INTO JRGY_USUARIO_ROL (COD_USUARIO, COD_ROL)
        SELECT P_ID, r.COD_ROL
        FROM JSON_TABLE(
            P_ROLES_JSON,
            '$[*]' COLUMNS(
                NOMBRE VARCHAR2(50) PATH '$'
            )
        ) jt
        JOIN JRGY_ROL r ON UPPER(r.NOMBRE_ROL) = UPPER(jt.NOMBRE);

        IF SQL%ROWCOUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20092, 'ROLES NO VALIDOS');
        END IF;
    END IF;

    IF V_ES_CLIENTE > 0 THEN
        INSERT INTO JRGY_CLIENTE (COD_USUARIO, FECHA_ALTA)
        SELECT P_ID, SYSDATE FROM DUAL
        WHERE NOT EXISTS (SELECT 1 FROM JRGY_CLIENTE WHERE COD_USUARIO = P_ID);
    END IF;

    COMMIT;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        ROLLBACK;
        IF INSTR(UPPER(SQLERRM), 'PK_JRGY_USUARIO') > 0 THEN
            RAISE_APPLICATION_ERROR(-20011, 'COD_USUARIO DUPLICADO');
        ELSE
            RAISE_APPLICATION_ERROR(-20093, 'EMAIL DUPLICADO');
        END IF;
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_USUARIO_ELIMINAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_USUARIO_ELIMINAR" (
    P_ID IN NUMBER
)
IS
BEGIN
    DELETE FROM JRGY_USUARIO_ROL WHERE COD_USUARIO = P_ID;
    DELETE FROM JRGY_CLIENTE WHERE COD_USUARIO = P_ID;
    DELETE FROM JRGY_USUARIO WHERE COD_USUARIO = P_ID;
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20094, 'USUARIO NO ENCONTRADO');
    END IF;
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_USUARIO_GET
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_USUARIO_GET" (
    P_ID IN NUMBER,
    CUR_USER OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_USER FOR
        SELECT
            u.COD_USUARIO,
            u.NOMBRE_USUARIO,
            u.APELLIDO1_USUARIO,
            u.APELLIDO2_USUARIO,
            u.EMAIL_USUARIO,
            u.TELEFONO_USUARIO,
            LISTAGG(r.NOMBRE_ROL, ',') WITHIN GROUP (ORDER BY r.NOMBRE_ROL) AS ROLES
        FROM JRGY_USUARIO u
        LEFT JOIN JRGY_USUARIO_ROL ur ON ur.COD_USUARIO = u.COD_USUARIO
        LEFT JOIN JRGY_ROL r ON r.COD_ROL = ur.COD_ROL
        WHERE u.COD_USUARIO = P_ID
        GROUP BY u.COD_USUARIO, u.NOMBRE_USUARIO, u.APELLIDO1_USUARIO, u.APELLIDO2_USUARIO, u.EMAIL_USUARIO, u.TELEFONO_USUARIO;
END;

/
--------------------------------------------------------
--  DDL for Procedure JRGY_PRO_USUARIO_LISTAR
--------------------------------------------------------
set define off;

  CREATE OR REPLACE EDITIONABLE PROCEDURE "UCM"."JRGY_PRO_USUARIO_LISTAR" (
    CUR_USERS OUT SYS_REFCURSOR
)
IS
BEGIN
    OPEN CUR_USERS FOR
        SELECT
            u.COD_USUARIO,
            u.NOMBRE_USUARIO,
            u.APELLIDO1_USUARIO,
            u.APELLIDO2_USUARIO,
            u.EMAIL_USUARIO,
            u.TELEFONO_USUARIO,
            LISTAGG(r.NOMBRE_ROL, ',') WITHIN GROUP (ORDER BY r.NOMBRE_ROL) AS ROLES
        FROM JRGY_USUARIO u
        LEFT JOIN JRGY_USUARIO_ROL ur ON ur.COD_USUARIO = u.COD_USUARIO
        LEFT JOIN JRGY_ROL r ON r.COD_ROL = ur.COD_ROL
        GROUP BY u.COD_USUARIO, u.NOMBRE_USUARIO, u.APELLIDO1_USUARIO, u.APELLIDO2_USUARIO, u.EMAIL_USUARIO, u.TELEFONO_USUARIO
        ORDER BY u.COD_USUARIO;
END;

/
--------------------------------------------------------
--  DDL for Package METADATA_ANNOTATIONS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "UCM"."METADATA_ANNOTATIONS" authid current_user is 
          
/* Enumeration of annotation types */
 IDENTIFIER_TABLE                   constant number :=1;
 IDENTIFIER_TABLE_COLUMN            constant number :=2;
 IDENTIFIER_TABLE_PARTITION         constant number :=3;
 IDENTIFIER_TABLE_SUBPARTITION      constant number :=4;
 IDENTIFIER_VIEW                    constant number :=5;
 IDENTIFIER_VIEW_COLUMN             constant number :=6;
 IDENTIFIER_PACKAGE                 constant number :=7;
 IDENTIFIER_PACKAGE_PROCEDURE       constant number :=8;
 IDENTIFIER_PACKAGE_FUNCTION        constant number :=9;
 IDENTIFIER_PROCEDURE               constant number :=10;
 IDENTIFIER_FUNCTION                constant number :=11;
 IDENTIFIER_SCHEMA                  constant number :=12;
 IDENTIFIER_DATABASE                constant number :=13;
 IDENTIFIER_GROUP                   constant number :=14;
 IDENTIFIER_MTRLZD_VIEW             constant number :=15;
 IDENTIFIER_MTRLZD_VIEW_COLUMN      constant number :=16;
 NUM_IDENTIFIER_TYPE                constant number :=16;


/* DESCRIPTION: Public API to add a annotation name, value pair 
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to be added
 *  value               (in)   annotation label value to be added
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.set(label, value, identifier_name, identifier_type) 
 */

procedure set(
          label In varchar2,
          value In varchar2,
          identifier_name in varchar2, 
          identifier_type In varchar2 default 'TABLE'
          );

/* DESCRIPTION: Public API to add a annotation name, value pair 
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to be edited
 *  value               (in)   New annotation label value  
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.set(label, value, identifier_name, identifier_type) 
 */

procedure edit(
          label In varchar2,
          value In varchar2,
          identifier_name in varchar2, 
          identifier_type In varchar2 default 'TABLE'
          );

/* DESCRIPTION: Public API to get value for a particular annotation name
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to look up
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.get(label, identifier_name, identifier_type) 
 */

function get(
          label in varchar2,
          identifier_name in varchar2,
          identifier_type in varchar2 default 'TABLE')
return clob;

/* DESCRIPTION: Public API to delete an annotation
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to delete
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.get(label, identifier_name, identifier_type) 
 */

procedure delete(
          label in varchar2,
          identifier_name in varchar2,
          identifier_type in varchar2 default 'TABLE');

type identifier_components_t is table of varchar2(4000) index by varchar2(100);


Type Identifier Is Record( 
       Identifier_Name Varchar2(4000),
       Identifier_Type Varchar2(4000));

Type Identifier_List Is Table Of Identifier;

type annotation is record(
     label varchar2(4000),
     value varchar2(4000),
     identifier_name varchar2(4000),
     identifier_type varchar2(4000) default 'TABLE');

/* DESCRIPTION: Public API to create a group
 * 
 * PARAMETERS:
 *  group_name              (in)   Name of the group 
 *
 * USAGE:
 *  metadata_annotations.create_group(group_name);
 */

procedure create_group(
     group_name in VARCHAR2);

/* DESCRIPTION: Public API to drop a group
 * 
 * PARAMETERS:
 *  group_name              (in)   Name of the group to drop 
 *
 * USAGE:
 *  metadata_annotations.drop_group(group_name);
 */

procedure drop_group(
     group_name in VARCHAR2);

/* DESCRIPTION: Public API to add an element to a group
 * 
 * PARAMETERS:
 *  group_name              (in)   Name of the group to modify
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *  
 * USAGE:
 *  metadata_annotations.add_to_group(group_name, identifier_name, identifier_type );
 */


procedure add_to_group(
     group_name      in VARCHAR2,
     identifier_name in varchar2,
     identifier_type in varchar2 default 'TABLE');

/* DESCRIPTION: Public API to delete an element from a group
 * 
 * PARAMETERS:
 *  group_name              (in)   Name of the group to modify
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *  
 * USAGE:
 *  metadata_annotations.add_to_group(group_name, identifier_name, identifier_type );
 */


procedure delete_from_group(
     group_name      in VARCHAR2,
     identifier_name in varchar2,
     identifier_type in varchar2 default 'TABLE');

function get_version return varchar2;

end metadata_annotations;

/
--------------------------------------------------------
--  DDL for Package PKG_PEDIDO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "UCM"."PKG_PEDIDO" IS
    TYPE CURSOR_P IS REF CURSOR;
    PROCEDURE JRGY_PRO_GET_PEDIDO_DETALLE (
        COD_PEDIDO_P IN JRGY_PEDIDO.COD_PEDIDO%TYPE,
        CURSOR_P OUT CURSOR_P
    );
END PKG_PEDIDO;

/
--------------------------------------------------------
--  DDL for Package PKG_REPORTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "UCM"."PKG_REPORTES" AS
    TYPE CURSOR_P IS REF CURSOR;
    PROCEDURE REP_TOP_PRODUCTOS_MES (ANIO IN NUMBER, MES IN NUMBER, CURSOR_OUT OUT CURSOR_P);
    PROCEDURE REP_OCUPACION_HABITACIONES (CURSOR_OUT OUT CURSOR_P);
    PROCEDURE REP_COMPRAS_POR_PROVEEDOR (CURSOR_OUT OUT CURSOR_P);
END PKG_REPORTES;

/
--------------------------------------------------------
--  DDL for Package PRVT_ANNOTATIONS_INTERNAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "UCM"."PRVT_ANNOTATIONS_INTERNAL" authid definer
is 

/* 
 * Enumeration of annotation types 
 * Notes: For every annotation this is the value of the column 
 * annotation_type in the table annotations_usage$.
 *
 * Note that we are using the same values in user visible package as well as the 
 * internal helper package
 */

 IDENTIFIER_TABLE                 constant number :=1;
 IDENTIFIER_TABLE_COLUMN          constant number :=2;
 IDENTIFIER_TABLE_PARTITION       constant number :=3;
 IDENTIFIER_TABLE_SUBPARTITION    constant number :=4;
 IDENTIFIER_VIEW                  constant number :=5;
 IDENTIFIER_VIEW_COLUMN           constant number :=6;
 IDENTIFIER_PACKAGE               constant number :=7;
 IDENTIFIER_PACKAGE_PROCEDURE     constant number :=8;
 IDENTIFIER_PACKAGE_FUNCTION      constant number :=9;
 IDENTIFIER_PROCEDURE             constant number :=10;
 IDENTIFIER_FUNCTION              constant number :=11;
 IDENTIFIER_SCHEMA                constant number :=12;
 IDENTIFIER_DATABASE              constant number :=13;
 IDENTIFIER_GROUP                 constant number :=14;
 IDENTIFIER_MTRLZD_VIEW           constant number :=15; 
 IDENTIFIER_MTRLZD_VIEW_COLUMN    constant number :=16;

 NUM_IDENTIFIER_TYPE                   constant number :=16;

procedure set(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_value      in varchar2,
          v_annotation_type_int   In number,
          v_obj#                  in number,
          obj#_owner              in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
;

procedure edit(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_value      in varchar2,
          v_annotation_type_int   In number,
          v_obj#                  in number,
          obj_owner               in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
;

function get(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_type_int   in number,
          v_obj#                  in number,
          v_obj#_owner            in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
return clob
;

procedure delete(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_type_int   In number,
          v_obj#                  in number,
          obj_owner               in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
;

procedure create_group(
     v_group_name in VARCHAR2)
;

procedure drop_group(
     v_group_name in VARCHAR2)
;

procedure add_to_group(
      v_group_name            in VARCHAR2,
      v_object_id             in NUMBER,
      v_object_owner          in NUMBER,
      v_annotation_type_int   in number,
      v_identifier_components in 
      metadata_annotations.identifier_components_t);

procedure delete_from_group(
      v_group_name            in VARCHAR2,
      v_object_id             in NUMBER,
      v_object_owner          in NUMBER,
      v_annotation_type_int   in number,
      v_identifier_components in 
      metadata_annotations.identifier_components_t);

end prvt_annotations_internal;

/
--------------------------------------------------------
--  DDL for Package Body METADATA_ANNOTATIONS
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "UCM"."METADATA_ANNOTATIONS" 
AS

 /* package version */
 VERSION        constant varchar(12) := '1.0';

 type arr_number is 
         varray(PRVT_ANNOTATIONS_INTERNAL.NUM_IDENTIFIER_TYPE) of number;

 identifier_token_len arr_number := arr_number();

 M_IDEN CONSTANT NUMBER :=128; /* Maximum length of SQL identifier */

/* 
 * Opcodes for operations permitted in this pacakge. Used in privilege check 
 * 
 */

 OPCODE_GET     constant number := 1;
 OPCODE_SET     constant number := 2;
 OPCODE_EDIT    constant number := 3;
 OPCODE_DELETE  constant number := 4;

  PROCEDURE log(log_val IN VARCHAR2) IS
  BEGIN
   IF(FALSE) THEN
      DBMS_OUTPUT.PUT_LINE(log_val);
   END IF;
  END;

 procedure init_identifier_token_len
 as 
 begin
  identifier_token_len.extend
         (PRVT_ANNOTATIONS_INTERNAL.NUM_IDENTIFIER_TYPE);

  /* SCHEMA.TABLE */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE) :=2; 

  /*SCHEMA.TABLE.COLUMN */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_COLUMN) :=3; 

  /*SCHEMA.TABLE.PARTITION */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_PARTITION) :=3; 

  /*SCHEMA.TABLE.SUBPARTITION */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_SUBPARTITION) :=3;     

  /* SCHEMA.VIEW */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW) :=2; 

  /* SCHEMA.MATERIALIZED_VIEW */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW) :=2; 

  /*SCHEMA.VIEW.COLUMN */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW_COLUMN) :=3; 

   /*SCHEMA.MATERIALIZED_VIEW.COLUMN */
  identifier_token_len
         (PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW_COLUMN) :=3; 

  /* SCHEMA.PACKAGE */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE) :=2; 

  /*SCHEMA.PACAKGE.PROCEDURE */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_PROCEDURE) :=3; 

  /* SCHEMA.PACKAGE.FUNCTION */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_FUNCTION) :=3; 

  /*SCHEMA.PROCEDURE */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PROCEDURE) :=2;

  /*SCHEMA.FUNCTION */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_FUNCTION) :=2; 

  /*SCHEMA */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_SCHEMA) :=1; 

  /* Identifier name should be null */
  /* The DB being annoted is the current DB */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_DATABASE) :=0;

  /* GROUP */
  identifier_token_len(PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_GROUP) :=1;

 end;

 function check_user_has_access_to_obj(
         identifier_type_int   in number,
         obj#                  in number,
         obj#_owner            in number,
         curr_user_id          in number,
         curr_user_name        in varchar2,
         identifier_components in
          metadata_annotations.identifier_components_t
 )
 return boolean
 as
  privilages_needed       SYS.ODCIVARCHAR2LIST  := SYS.ODCIVARCHAR2LIST();
  privilaged_object_name  varchar2(128);
  access_count            number  := 0;
  user_has_dba_role       boolean := false;
 begin

  -- No access needed for database annotation and group level annotation
  -- TODO : group level annoations checks?
  -- FYI:
  -- For Schema
  -- We will never reach here for Schema, coz , after splitting in the previous
  -- step , we lookup all_users and we won't find it. There itself we will
  -- throw error.
  IF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_DATABASE or
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_GROUP    or
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_SCHEMA
  THEN
    log('No check needed for database and group level annotation');
    RETURN TRUE;
  END IF;

  -- Implict Access via object ownership
  IF curr_user_id = obj#_owner THEN
    log('Current User owns the Object being annotated.');
    RETURN TRUE;
  END IF;

  -- Check if access has been granted to the user
  -- via direct grant or via a role

  IF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE OR
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_COLUMN OR
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW OR
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW_COLUMN OR 
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW OR
     identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW_COLUMN 
  THEN

      privilages_needed.EXTEND(2);
      privilages_needed(1)   := 'READ'; 
      privilages_needed(2)   := 'SELECT'; 
      privilaged_object_name := identifier_components('OBJECT_NAME');

  ELSIF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_PARTITION OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_SUBPARTITION 
  THEN

      privilages_needed.EXTEND(2);
      privilages_needed(1)   := 'READ'; 
      privilages_needed(2)   := 'SELECT'; 
      privilaged_object_name := identifier_components('TABLE');

  ELSIF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_PROCEDURE OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_FUNCTION OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PROCEDURE OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_FUNCTION 
  THEN
      privilages_needed.EXTEND(1);
      privilages_needed(1)   := 'EXECUTE'; 
      privilaged_object_name := identifier_components('OBJECT_NAME');
  END IF;

  log('Checking granted privilages ' ||
       ' curr_user_name '            || curr_user_name         ||
       ' privilaged_object_name '    || privilaged_object_name);

  -- (Even though the column name in the view all_tab_privs is table name, 
  --  it also contains privilege information for packages as well)
  SELECT COUNT(*) into access_count
  FROM SYS.ALL_TAB_PRIVS
  WHERE ( 
          GRANTEE = curr_user_name OR                                /* Access granted to the User directly */
          GRANTEE IN (SELECT GRANTED_ROLE FROM sys.user_role_privs)    /* Access granted to the User via a role */
        )
    AND TABLE_NAME   = privilaged_object_name
    AND TABLE_SCHEMA = identifier_components('SCHEMA')
    AND PRIVILEGE IN (SELECT COLUMN_VALUE FROM TABLE(privilages_needed));

  IF access_count > 0
  then
    log('User has necessary privilages');
    return TRUE;
  else 
    log('User does not have necessary privilages');
    return FALSE;
  END IF;

 end;

/* 
 * Checks if the current user has the privileges to annnotate
 *  Check 1 - See if the User is the owner or has access to the
 *            object being annotated.
 *  Check 2 - (TBD) is the owner of the annotation? Needed?
 *            Issue, Only one user can be annotation owner,
 *            but multiple users can have access to the object.
 */ 
function check_annotation_privilege(
         identifier_type_int   in number,
         identifier_components in identifier_components_t,
         opcode                in number,
         obj#                  in number,
         obj#_owner            in number,
         user_id               in number,
         user_name             in varchar2)
return boolean
as 
  has_privilege boolean := TRUE;
begin
  has_privilege := check_user_has_access_to_obj(identifier_type_int,
                                  obj#,
                                  obj#_owner,
                                  user_id,
                                  user_name,
                                  identifier_components);

  return has_privilege;
end;

procedure split_identifier_name_tokens(
    identifier_name              IN  VARCHAR2,
    identifier_name_split_pieces OUT SYS.ODCIVARCHAR2LIST,  
    split_successful             OUT BOOLEAN
) IS
    pos1_identifier_piece  VARCHAR2(128);
    pos2_identifier_piece  VARCHAR2(128);
    pos3_identifier_piece  VARCHAR2(128);

    identifier_piece_count  PLS_INTEGER := 0;

    dummy_param_1  VARCHAR2(128);
    dummy_param_2  BINARY_INTEGER;

BEGIN

    log('Attempting to split identifier name: ' || identifier_name);

    split_successful             := TRUE;
    identifier_name_split_pieces := SYS.ODCIVARCHAR2LIST();

    IF(identifier_name IS NULL) THEN
     RETURN ;
    END IF;

    BEGIN

      DBMS_UTILITY.NAME_TOKENIZE(identifier_name, 
                                 pos1_identifier_piece, 
                                 pos2_identifier_piece, 
                                 pos3_identifier_piece, 
                                 dummy_param_1, dummy_param_2);

    EXCEPTION
        WHEN OTHERS THEN
          split_successful := FALSE;
          log('Error occurred during NAME_TOKENIZE: ' || SQLERRM);
          RETURN;
    END;

    IF pos1_identifier_piece IS NOT NULL 
    THEN
       identifier_name_split_pieces.EXTEND;
       identifier_piece_count := identifier_piece_count + 1;
       identifier_name_split_pieces(identifier_piece_count) := pos1_identifier_piece;
       log('Identifier at POS 1 ' || pos1_identifier_piece);
    END IF;

    IF pos2_identifier_piece IS NOT NULL
    THEN
       identifier_name_split_pieces.EXTEND;
       identifier_piece_count := identifier_piece_count + 1;
       identifier_name_split_pieces(identifier_piece_count) := pos2_identifier_piece;
       log('Identifier at POS 2 ' || pos2_identifier_piece);
    END IF;

    IF pos3_identifier_piece IS NOT NULL
    THEN
       identifier_name_split_pieces.EXTEND;
       identifier_piece_count := identifier_piece_count + 1;
       identifier_name_split_pieces(identifier_piece_count) := pos3_identifier_piece;
       log('Identifier at POS 3 ' || pos3_identifier_piece);
    END IF;

END; 

/* 
 *Procedure to assign the split identifier name tokens to the 
 * identifier components based on the identifier type
 * Ex: Say the identifier type is TABLE and the tokens are SCOTT and EMP
 * This procedure assigns SCOTT as the schema name and EMP as the table name
 * Assumes that the caller has passed the correct number of tokens 
 */
procedure assign_identifier_components(
    identifier_type_int in number,
    identifier_name_split_tokens in SYS.ODCIVARCHAR2LIST,
    identifier_components in out identifier_components_t)
as
    default_schema varchar2(128);
begin

  default_schema := sys_context('USERENV','CURRENT_SCHEMA');

  case (identifier_type_int)

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_SCHEMA then
      if identifier_name_split_tokens.count < 1 
          or identifier_name_split_tokens(1) is null then
        --raise_application_error(-20001, 'To annotate a Schema, Schema name required');
        identifier_components('SCHEMA') := default_schema;
      else
        identifier_components('SCHEMA') := identifier_name_split_tokens(1);
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE then
      if identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA') := identifier_name_split_tokens(1);
        identifier_components('TABLE')  := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(2);
      elsif identifier_name_split_tokens.count = 1 then
        identifier_components('SCHEMA') := default_schema;
        identifier_components('TABLE')  := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(1);
      else
        raise_application_error(-20002, 'Invalid tokens for TABLE type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_COLUMN then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')      := identifier_name_split_tokens(1);
        identifier_components('TABLE')       := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(2);
        identifier_components('COLUMN_NAME') := identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')      := default_schema;
        identifier_components('TABLE')       := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(1);
        identifier_components('COLUMN_NAME') := identifier_name_split_tokens(2);
      else
        raise_application_error(-20003, 'Invalid tokens for TABLE_COLUMN type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_PARTITION then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')        := identifier_name_split_tokens(1);
        identifier_components('TABLE')         := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')   := identifier_name_split_tokens(3);
        identifier_components('PARTITION_NAME'):= identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')        := default_schema;
        identifier_components('TABLE')         := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')   := identifier_name_split_tokens(2);
        identifier_components('PARTITION_NAME'):= identifier_name_split_tokens(2);
      else
        raise_application_error(-20004, 'Invalid tokens for TABLE_PARTITION type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_SUBPARTITION then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')           := identifier_name_split_tokens(1);
        identifier_components('TABLE')            := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')      := identifier_name_split_tokens(3);
        identifier_components('SUBPARTITION_NAME'):= identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')           := default_schema;
        identifier_components('TABLE')            := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')      := identifier_name_split_tokens(2);
        identifier_components('SUBPARTITION_NAME'):= identifier_name_split_tokens(2);
      else
        raise_application_error(-20005, 'Invalid tokens for TABLE_SUBPARTITION type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW then
      if identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')      := identifier_name_split_tokens(1);
        identifier_components('VIEW')        := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(2);
      elsif identifier_name_split_tokens.count = 1 then
        identifier_components('SCHEMA')      := default_schema;
        identifier_components('VIEW')        := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(1);
      else
        raise_application_error(-20006, 'Invalid tokens for VIEW type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW_COLUMN then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')      := identifier_name_split_tokens(1);
        identifier_components('VIEW')        := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(2);
        identifier_components('COLUMN_NAME') := identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')      := default_schema;
        identifier_components('VIEW')        := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(1);
        identifier_components('COLUMN_NAME') := identifier_name_split_tokens(2);
      else
        raise_application_error(-20007, 'Invalid tokens for VIEW_COLUMN type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE then
      if identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')       := identifier_name_split_tokens(1);
        identifier_components('PACKAGE_NAME') := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')  := identifier_name_split_tokens(2);
      elsif identifier_name_split_tokens.count = 1 then
        identifier_components('SCHEMA')       := default_schema;
        identifier_components('PACKAGE_NAME') := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')  := identifier_name_split_tokens(1);
      else
        raise_application_error(-20008, 'Invalid tokens for PACKAGE type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_PROCEDURE then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')         := identifier_name_split_tokens(1);
        identifier_components('PACKAGE_NAME')   := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(2);
        identifier_components('PROCEDURE_NAME') := identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')         := default_schema;
        identifier_components('PACKAGE_NAME')   := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(1);
        identifier_components('PROCEDURE_NAME') := identifier_name_split_tokens(2);
      else
        raise_application_error(-20009, 'Invalid tokens for PACKAGE_PROCEDURE type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_FUNCTION then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')         := identifier_name_split_tokens(1);
        identifier_components('PACKAGE_NAME')   := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(2);
        identifier_components('FUNCTION_NAME')  := identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')         := default_schema;
        identifier_components('PACKAGE_NAME')   := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(1);
        identifier_components('FUNCTION_NAME')  := identifier_name_split_tokens(2);
      else
        raise_application_error(-20010, 'Invalid tokens for PACKAGE_FUNCTION type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PROCEDURE then
      if identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')         := identifier_name_split_tokens(1);
        identifier_components('PROCEDURE_NAME') := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(2);
      elsif identifier_name_split_tokens.count = 1 then
        identifier_components('SCHEMA')         := default_schema;
        identifier_components('PROCEDURE_NAME') := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(1);
      else
        raise_application_error(-20011, 'Invalid tokens for PROCEDURE type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_FUNCTION then
      if identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')         := identifier_name_split_tokens(1);
        identifier_components('FUNCTION_NAME')  := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(2);
      elsif identifier_name_split_tokens.count = 1 then
        identifier_components('SCHEMA')         := default_schema;
        identifier_components('FUNCTION_NAME')  := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME')    := identifier_name_split_tokens(1);
      else
        raise_application_error(-20012, 'Invalid tokens for FUNCTION type');
      end if;

    /* Nothing to extract for DB Type. As its the current DB being annotated */
    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_DATABASE then
      if identifier_name_split_tokens.count > 0 then
        raise_application_error(-20013, 'Invalid tokens for DATABASE type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW then
      if identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')      := identifier_name_split_tokens(1);
        identifier_components('MATERIALIZED_VIEW')  := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(2);
      elsif identifier_name_split_tokens.count = 1 then
        identifier_components('SCHEMA')      := default_schema;
        identifier_components('MATERIALIZED_VIEW') := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(1);
      else
        raise_application_error(-20014, 'Invalid tokens for MATERIALIZED VIEW type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW_COLUMN then
      if identifier_name_split_tokens.count = 3 then
        identifier_components('SCHEMA')      := identifier_name_split_tokens(1);
        identifier_components('MATERIALIZED_VIEW') := identifier_name_split_tokens(2);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(2);
        identifier_components('COLUMN_NAME') := identifier_name_split_tokens(3);
      elsif identifier_name_split_tokens.count = 2 then
        identifier_components('SCHEMA')      := default_schema;
        identifier_components('MATERIALIZED_VIEW') := identifier_name_split_tokens(1);
        identifier_components('OBJECT_NAME') := identifier_name_split_tokens(1);
        identifier_components('COLUMN_NAME') := identifier_name_split_tokens(2);
      else
        raise_application_error(-20015, 'Invalid tokens for MATERIALIZED_VIEW_COLUMN type');
      end if;

    when PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_GROUP then
      if identifier_name_split_tokens.count = 1 then
        identifier_components('GROUP_NAME')      := identifier_name_split_tokens(1);

      else
        raise_application_error(-20015, 'Invalid tokens for MATERIALIZED_VIEW_COLUMN type');
      end if;

    else
      raise_application_error(-20000, 'Invalid identifier type');

  end case;
end;

/* 
 * Procedure to split the identifier name to 
 * <owner,object_name, subobject_name, annotation_targer>
 */

procedure split_identifier_name(
           identifier_type_int in number,
           identifier_name in varchar2,
           identifier_components in out identifier_components_t)

as 
v_delimiter varchar2(1) := '.';
v_delimiter_pos number;
split_successful boolean;
identifier_name_split_tokens  SYS.ODCIVARCHAR2LIST;
expected_len number;

begin

 split_identifier_name_tokens(identifier_name,
                              identifier_name_split_tokens,
                              split_successful);

 if (split_successful = FALSE) then
   raise_application_error(-20000, 'Invalid identifier_name : Parsing Failed');
 end if;

 expected_len := identifier_token_len(identifier_type_int);

 if    identifier_name_split_tokens.COUNT = expected_len 
    OR identifier_name_split_tokens.COUNT = expected_len - 1 then
      NULL;
 else
   raise_application_error(-20000,
    'Invalid identifier_name : Len mismatch. ' ||
    'Actual : ' || identifier_name_split_tokens.COUNT ||
    ' Expected : (' || (expected_len - 1) || ' or ' || expected_len || ')');
 end if;

 FOR i IN 1 .. identifier_name_split_tokens.COUNT LOOP
    log('Position ' || i || ': ' ||
                         identifier_name_split_tokens(i));
 END LOOP; 

 assign_identifier_components(
         identifier_type_int,
         identifier_name_split_tokens,
         identifier_components);
end;


PROCEDURE check_package_proc_func_exists(
                            p_package_name IN VARCHAR2, 
                            p_procedure_or_function_name IN VARCHAR2) 
IS
  v_count NUMBER;
BEGIN

   /* ALL_PROCEDURES has both procedures and functions */

    SELECT COUNT(*)
      INTO v_count
      FROM SYS.ALL_PROCEDURES
     WHERE OBJECT_TYPE = 'PACKAGE'
       AND OBJECT_NAME = p_package_name
       AND PROCEDURE_NAME = p_procedure_or_function_name;

    IF v_count = 0 THEN
      RAISE_APPLICATION_ERROR(-20002, ' ' || p_procedure_or_function_name || ' does not exist in package ' || p_package_name);
    END IF;
END check_package_proc_func_exists;


PROCEDURE check_view_table_colum_exists(
                            p_view_or_table_name IN VARCHAR2, 
                            p_column_name IN VARCHAR2) 
IS
  v_count NUMBER;
BEGIN

   /* ALL_TAB_COLUMNS has both table and view columns */

    SELECT COUNT(*)
      INTO v_count
      FROM SYS.ALL_TAB_COLUMNS
     WHERE TABLE_NAME = p_view_or_table_name
       AND COLUMN_NAME = p_column_name;

    IF v_count = 0 THEN
      RAISE_APPLICATION_ERROR(-20005, 'Column ' || p_column_name || ' does not exist in ' || p_view_or_table_name);
    END IF;

END check_view_table_colum_exists;

PROCEDURE validate_non_object_existance(
                            v_object_name IN VARCHAR2,
                            identifier_type_int IN NUMBER,
                            identifier_components IN identifier_components_t)
IS
BEGIN

  IF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_PROCEDURE
  THEN
    check_package_proc_func_exists(
          v_object_name,
          identifier_components('PROCEDURE_NAME'));
  ELSIF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_FUNCTION THEN
    check_package_proc_func_exists(
          v_object_name,
          identifier_components('FUNCTION_NAME'));
  ELSIF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_COLUMN OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW_COLUMN OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW_COLUMN
  THEN
    check_view_table_colum_exists(
          v_object_name,
          identifier_components('COLUMN_NAME'));
  END IF;

END validate_non_object_existance;

/* 
 * 1. Sanitize_arguments: 
 *     a. Ensure identifier_type passed is allowed
 *     b. If an annotation already exists, for the same label throw an 
 *        error
 * 
 * 2. Complete the annotation set operation using the database internal 
 *    package
 * 
 */
procedure sanitize_and_get_internal_rep
          (identifier_name       in  varchar2,
           identifier_type       in  varchar2,
           identifier_type_int   out number,
           base_obj_id           out number,  
           base_obj_owner_id     out number,
           identifier_components out identifier_components_t)    
as
   current_user                varchar2(M_IDEN);
   current_user_id             number;
   is_authorized               boolean := FALSE;
   identifier_type_has_baseobj boolean := FALSE;
   object_type_base_obj        varchar2(128);
   v_owner                     varchar2(128);
   v_object_name               varchar2(128);
   v_subobject_name            varchar2(128);
   base_obj_owner_name         varchar2(128);
   idx                         VARCHAR2(100);
begin

identifier_components := identifier_components_t();
/*  1. Sanitize_arguments: 
 *     a. Ensure identifier_type passed is allowed. 
 *     b. Ensure size of annotation_name and annotation_value due to 
 *        exceed limits.
 */

 CASE (identifier_type)
     when 'TABLE' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'TABLE';
     when 'TABLE COLUMN' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_COLUMN;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'TABLE';
     when 'TABLE PARTITION' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_PARTITION;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'TABLE PARTITION';        
     when 'TABLE SUBPARTITION' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_SUBPARTITION;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'TABLE SUBPARTITION';              
     when 'VIEW' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'VIEW';
     when 'VIEW COLUMN' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_VIEW_COLUMN;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'VIEW';        
     when 'MATERIALIZED VIEW' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'MATERIALIZED VIEW';
     when 'MATERIALIZED VIEW COLUMN' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_MTRLZD_VIEW_COLUMN;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'MATERIALIZED VIEW';        
     when 'PACKAGE' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'PACKAGE';
     when 'PACKAGE PROCEDURE' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_PROCEDURE;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'PACKAGE';
     when 'PACKAGE FUNCTION' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PACKAGE_FUNCTION;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'PACKAGE';
     when 'PROCEDURE' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_PROCEDURE;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'PROCEDURE';
     when 'FUNCTION' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_FUNCTION;
        identifier_type_has_baseobj := TRUE;
        object_type_base_obj := 'FUNCTION';
     when 'SCHEMA' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_SCHEMA;
        identifier_type_has_baseobj := FALSE;
     when 'DATABASE' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_DATABASE;
        identifier_type_has_baseobj := FALSE;
     when 'GROUP' then
        identifier_type_int := PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_GROUP;
        identifier_type_has_baseobj := FALSE;
     else 
        raise_application_error(-20000, 'Invalid annotation type');   
 END CASE;

  log ('Identifier internal type ' || identifier_type_int);


 /* 
  * 3. If authorized, add the annotation
  *    a. Get current user
  *    b. Get obj# from arguments
  */

  current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  select user_id into current_user_id
    from sys.all_users
   where username = current_user;

  split_identifier_name(identifier_type_int,
                        identifier_name,
                        identifier_components);

  idx := identifier_components.FIRST;
  WHILE idx IS NOT NULL LOOP
    log(idx || ' = ' || identifier_components(idx));
    idx := identifier_components.NEXT(idx);
  END LOOP;

  log('Current user: ' || current_user || '; Id ' 
                       || current_user_id);


  if(identifier_type_has_baseobj) then 

    BEGIN

      IF(identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_PARTITION OR
        identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_SUBPARTITION)
      THEN

        v_owner          := identifier_components('SCHEMA');
        v_object_name    := identifier_components('TABLE');

        IF (identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_TABLE_PARTITION) THEN
          v_subobject_name := identifier_components('PARTITION_NAME');
        ELSE
          v_subobject_name := identifier_components('SUBPARTITION_NAME');
        END IF;


        select object_id, OWNER into 
              base_obj_id, base_obj_owner_name
          from sys.all_objects 
        where object_name    = v_object_name
          and subobject_name = v_subobject_name
          and owner          = v_owner
          and object_type    = object_type_base_obj; 

        select user_id into base_obj_owner_id
        from   sys.all_users
        where username = base_obj_owner_name;

        log(' v_owner '              || v_owner              || 
            ' v_object_name '        || v_object_name        ||
            ' v_subobject_name '     || v_subobject_name     || 
            ' object_type_base_obj ' || object_type_base_obj ||
            ' base_obj_owner_id '    || base_obj_owner_id);

      ELSE

        v_owner       := identifier_components('SCHEMA');
        v_object_name := identifier_components('OBJECT_NAME');

        /* v_object_name,  v_owner will already be upper case
           as they are extracted from indentifer name which will be
           uppercased at the begining itself */
        select object_id, OWNER into 
              base_obj_id, base_obj_owner_name
          from sys.all_objects 
        where object_name = v_object_name
          and owner       = v_owner
          and object_type        = object_type_base_obj;

        select user_id into base_obj_owner_id
        from   sys.all_users
        where username = base_obj_owner_name;        

        validate_non_object_existance(v_object_name,
                                      identifier_type_int,
                                      identifier_components);   

        log(' v_owner: '             || v_owner              || 
            ' v_object_name '        || v_object_name        ||
            ' v_subobject_name '     || v_subobject_name     ||
            ' object_type_base_obj ' || object_type_base_obj ||
            ' base_obj_owner_id '    || base_obj_owner_id);

      END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
          raise_application_error(-20003, 
                                  'Object does not exist or insufficient privileges');
    END;    
  ELSE

   IF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_SCHEMA
     THEN

      BEGIN
         v_owner       := identifier_components('SCHEMA');
         base_obj_id   := -1;

         select user_id into base_obj_owner_id
         from   sys.all_users
         where username = v_owner;

         log(' v_owner: '              || v_owner               || 
             ' base_obj_owner_id '     || base_obj_owner_id     ||
             ' base_obj_id '           || base_obj_id );

      EXCEPTION
          WHEN NO_DATA_FOUND THEN
                    raise_application_error(-20003, 
                                            'Specified User does not exist or insufficient privileges');
      END; 
     ELSIF identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_DATABASE OR
           identifier_type_int = PRVT_ANNOTATIONS_INTERNAL.IDENTIFIER_GROUP
     THEN

         base_obj_id       := -1;
         base_obj_owner_id := -1;

     END IF;

  end if;

end;

PROCEDURE check_null_and_len_for_label (
                label              IN  VARCHAR2
) IS
BEGIN

  IF label is NULL THEN
    RAISE_APPLICATION_ERROR(-20001, 'Label is mandatory and cannot be null');
  END IF;

  IF LENGTH(label) > 1024 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Label length exceeds 1024 characters limit');
  END IF;

END;

PROCEDURE check_len_for_value (
                value              IN  VARCHAR2
) IS
BEGIN

  IF value IS NOT NULL AND LENGTH(value) > 4000 THEN
      RAISE_APPLICATION_ERROR(-20001, 'Value length exceeds 4000 characters limit');
  END IF;

END;

PROCEDURE check_null_for_identifier(
              identifier_type_in    IN  varchar2,
              identifier_type_out   OUT varchar2,
              identifier_name_in    IN  VARCHAR2) IS
BEGIN

  /* Identifier_type won't be null as it defaults to Table in the caller */
  identifier_type_out := UPPER(identifier_type_in);

  /* For DATABASE, identifier name will be NULL,
     For SCHEMA,   identifier name can be NULL */
  IF identifier_type_out = 'DATABASE' OR identifier_type_out = 'SCHEMA'
  THEN
      NULL;
  ELSE
    IF identifier_name_in is NULL
    THEN
      RAISE_APPLICATION_ERROR(-20001, 'Identifier Name is mandatory and cannot be null ');
    END IF;
  END IF;

END check_null_for_identifier;

PROCEDURE chk_null_annotation_operation(
                  identifier_type_in    IN  varchar2,
                  identifier_type_out   OUT varchar2,
                  identifier_name_in    IN  VARCHAR2,
                  label                 IN  VARCHAR2,
                  value                 IN  VARCHAR2)
 IS
BEGIN
  check_null_and_len_for_label(label);
  check_len_for_value(value);
  check_null_for_identifier(identifier_type_in,
                            identifier_type_out,
                            identifier_name_in);

END;

/* DESCRIPTION: Public API to add a annotation name, value pair 
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to be added
 *  value               (in)   annotation label value to be added
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.set(label, value, identifier_name, identifier_type) 
 */
Procedure set(
          label            in  varchar2,
          value            in  varchar2,
          identifier_name  In Varchar2,
          identifier_type  in varchar2)
as 
   current_user            varchar2(M_IDEN);
   current_user_id         number;
   is_authorized           boolean := FALSE;
   identifier_type_int     number; 
   obj#                    number;  /* Object number of the annotated object */
   obj#_owner              number;  /* OwnerID of the Object being annotated */
   v_owner                 varchar2(128);
   v_object_name           varchar2(128);
   identifier_components   identifier_components_t;
   object_type_base_obj    varchar2(128);
   opcode                  number;
   has_privilege           boolean   := FALSE;
   identifier_type_upper   varchar2(M_IDEN);
begin

   chk_null_annotation_operation(identifier_type,
                                 identifier_type_upper ,
                                 identifier_name,
                                 label,
                                 value);

    /*

      STEPS:
        1. For each annotation <name, value> pair:
        2. call set() procedure 

     */ 
    sanitize_and_get_internal_rep(
             identifier_name,
             identifier_type_upper,
             identifier_type_int,
             obj#,
             obj#_owner,
             identifier_components);

    /* get user information */
    current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
    select user_id into current_user_id
      from sys.all_users
     where username = current_user;

    /* privilege check */    
    opcode := OPCODE_SET; 
    has_privilege := check_annotation_privilege(identifier_type_int,
                                                identifier_components,
                                                opcode, 
                                                obj#,
                                                obj#_owner,
                                                current_user_id,
                                                current_user);

    if (has_privilege <> TRUE) then
      raise_application_error(-20000, 'Insufficient privileges');   
    end if;

   /*
    * Deal with Schema and Database types which do not have obj#
    */
    begin 
      prvt_annotations_internal.set(
            current_user_id,
            label,
            value,
            identifier_type_int,
            obj#,
            obj#_owner,
            identifier_components); 
    exception
      when DUP_VAL_ON_INDEX THEN
        raise_application_error(-20000, 'Annotation already exists. Use edit' 
            || ' procedure to replace value') ;
    end;

end;

/* DESCRIPTION: Public API to modify the value of a particular annotation name
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to be modified
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.edit(label, identifier_name, identifier_type) 
 */
procedure edit(
          label In varchar2,
          value In varchar2,
          identifier_name in varchar2, 
          identifier_type In varchar2 default 'TABLE'
          )
as
   current_user            varchar2(M_IDEN);
   current_user_id         number;
   is_authorized           boolean := FALSE;
   identifier_type_int     number; 
   obj#                    number;  /* Object number of the annotated object */
   obj#_owner              number;  /* OwnerID of the Object being annotated */
   v_owner                 varchar2(128);
   v_object_name           varchar2(128);
   identifier_components   identifier_components_t;
   object_type_base_obj    varchar2(128);
   opcode                  number;
   has_privilege           boolean   := FALSE;
   identifier_type_upper   varchar2(M_IDEN);
begin

   chk_null_annotation_operation(identifier_type,
                                 identifier_type_upper,
                                 identifier_name,
                                 label,
                                 value);      

     sanitize_and_get_internal_rep(
             identifier_name,
             identifier_type_upper,
             identifier_type_int,
             obj#, 
             obj#_owner,
             identifier_components);


    /* get user information */
    current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
    select user_id into current_user_id
      from sys.all_users
     where username = current_user;

    /* privilege check */    
    opcode := OPCODE_EDIT; 
    has_privilege := check_annotation_privilege(identifier_type_int,
                                                identifier_components,
                                                opcode,
                                                obj#,
                                                obj#_owner,
                                                current_user_id,
                                                current_user);

    if (has_privilege) then  
      prvt_annotations_internal.edit(
           current_user_id,
           label,
           value,
           identifier_type_int,
           obj#,
           obj#_owner,
           identifier_components); 
  else
    raise_application_error(-20000, 'Insufficient privileges');   
  end if;

end;

/* DESCRIPTION: Public API to get value for a particular annotation name
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to be looked up
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.get(label, identifier_name, identifier_type) 
 */
function  get(
          label in varchar2,
          identifier_name in varchar2,
          identifier_type in varchar2  default 'TABLE')
return clob
as 
   current_user            varchar2(M_IDEN);
   current_user_id         number;
   is_authorized           boolean := FALSE;
   identifier_type_int     number; 
   obj#                    number;  /* Object number of the annotated object */
   obj#_owner              number;  /* OwnerID of the Object being annotated */
   v_owner                 varchar2(128);
   v_object_name           varchar2(128);
   identifier_components   identifier_components_t;
   object_type_base_obj    varchar2(128);
   v_annotation_clob       clob := NULL;
   opcode                  number;
   has_privilege           boolean   := FALSE;
   identifier_type_upper   varchar2(M_IDEN);
begin

   chk_null_annotation_operation(identifier_type,
                                 identifier_type_upper,
                                 identifier_name,
                                 label,
                                 NULL);

  sanitize_and_get_internal_rep(
           identifier_name,
           identifier_type_upper,
           identifier_type_int,
           obj#, 
           obj#_owner,
           identifier_components);

  /* get user information */
  current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  select user_id into current_user_id
    from sys.all_users
   where username = current_user;

  /* privilege check */    
  opcode := OPCODE_GET; 
  has_privilege := check_annotation_privilege(identifier_type_int,
                                              identifier_components,
                                              opcode,
                                              obj#,
                                              obj#_owner,
                                              current_user_id,
                                              current_user);

  if (has_privilege) then  
    v_annotation_clob :=  prvt_annotations_internal.get(
                                 current_user_id,
                                 label,
                                 identifier_type_int,
                                 obj#,
                                 obj#_owner,
                                 identifier_components);
  else
    raise_application_error(-20000, 'Insufficient privileges');   
  end if;

  return v_annotation_clob;

end;

/* DESCRIPTION: Public API to delete a specified annotation 
 * 
 * PARAMETERS:
 *  label               (in)   annotation label to be deleted
 *  identifier_name     (in)   fully qualified identifier name
 *  identifier_type     (in)   identifier type (defaults to 'TABLE')
 *
 * USAGE:
 *  metadata_annotations.delete(label, identifier_name, identifier_type) 
 */
procedure delete(
          label in varchar2,
          identifier_name in varchar2,
          identifier_type in varchar2 default 'TABLE')
as
  current_user            varchar2(M_IDEN);
  current_user_id         number;
  obj#                    number;
  obj_owner               number;
  identifier_type_int     number;
  identifier_components   identifier_components_t;
  opcode                  number;
  has_privilege           boolean   := FALSE;
  identifier_type_upper   varchar2(M_IDEN);
begin

   chk_null_annotation_operation(identifier_type,
                                 identifier_type_upper,
                                 identifier_name,
                                 label,
                                 NULL);

    sanitize_and_get_internal_rep(
           identifier_name,
           identifier_type_upper,
           identifier_type_int,
           obj#, 
           obj_owner,
           identifier_components);

    /* get user information */
    current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
    select user_id into current_user_id
       from sys.all_users
       where username = current_user;

    /* privilege check */    
    opcode := OPCODE_DELETE; 
    has_privilege := check_annotation_privilege(identifier_type_int,
                                                identifier_components,
                                                opcode,
                                                obj#,
                                                obj_owner,
                                                current_user_id,
                                                current_user);

    if(has_privilege) then
        prvt_annotations_internal.delete(
        current_user_id,
        label,
        identifier_type_int,
        obj#,
        obj_owner,
        identifier_components
        );
    else
        raise_application_error(-20000, 'Insufficient privileges');   
    end if;
end;


procedure chk_null_and_format_grp_name(
            group_name_in  IN  VARCHAR2,
            group_name_out OUT VARCHAR2)
AS
   num_double_quotes NUMBER;
BEGIN

  IF group_name_in is NULL THEN
    RAISE_APPLICATION_ERROR(-20001, 'Group Name is mandatory and cannot be null');
  ELSE

    num_double_quotes := LENGTH(group_name_in) - LENGTH(REPLACE(group_name_in, '"', ''));

    /* If no double quotes, upper case the group name */
    IF num_double_quotes = 0 THEN

      group_name_out := UPPER(group_name_in);

    /* If double quotes, ensure there are two of them.
       one at the begining and one at the end. remove them.*/
    ELSIF (num_double_quotes = 2 AND 
          SUBSTR(group_name_in, 1, 1) = '"' AND 
          SUBSTR(group_name_in, -1, 1) = '"' ) THEN

      group_name_out := REPLACE(group_name_in, '"', '');

    ELSE 
      RAISE_APPLICATION_ERROR(-20001, 'Invalid Group Name. Only two double quotes allowed, one at the begining and one at the end');

    END IF;
  END IF;

END chk_null_and_format_grp_name;

 procedure chk_null_group_operation(
              group_name              IN  VARCHAR2,
              group_name_formatted    OUT VARCHAR2,
              identifier_type         IN  varchar2,
              identifier_type_upper   OUT varchar2,
              identifier_name         IN  VARCHAR2)
  AS
  BEGIN

    chk_null_and_format_grp_name(group_name,
                                         group_name_formatted);

    check_null_for_identifier(identifier_type, 
                                  identifier_type_upper,
                                  identifier_name);

  END chk_null_group_operation;


  procedure create_group(group_name in VARCHAR2)
  as 
    group_name_formatted varchar2(M_IDEN);
  begin

    chk_null_and_format_grp_name(group_name, 
                                         group_name_formatted);

    prvt_annotations_internal.create_group(group_name_formatted);

  end;

  procedure drop_group(group_name in VARCHAR2)
  as 
    group_name_formatted varchar2(M_IDEN);
  begin

    chk_null_and_format_grp_name(group_name, 
                                         group_name_formatted);

    prvt_annotations_internal.drop_group(group_name_formatted);

  end;

procedure add_to_group(group_name in VARCHAR2,
                       identifier_name in varchar2,
                       identifier_type in varchar2 default 'TABLE')
as 
  current_user            varchar2(M_IDEN);
  current_user_id         number;
  obj#                    number;
  obj_owner               number;
  identifier_type_int     number;
  identifier_components   identifier_components_t;
  opcode                  number;
  has_privilege           boolean   := FALSE;
  identifier_type_upper   varchar2(M_IDEN);
  group_name_formatted    varchar2(M_IDEN);
begin

  chk_null_group_operation(group_name,
                           group_name_formatted,
                           identifier_type, 
                           identifier_type_upper,
                           identifier_name);

  sanitize_and_get_internal_rep(
       identifier_name,
       identifier_type_upper,
       identifier_type_int,
       obj#, 
       obj_owner,
       identifier_components);

  /* get user information */
  current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  select user_id into current_user_id
     from sys.all_users
     where username = current_user;

  /* privilege check */    
  opcode := OPCODE_SET; 
  has_privilege := check_annotation_privilege(identifier_type_int,
                                              identifier_components,
                                              opcode,
                                              obj#,
                                              obj_owner,
                                              current_user_id,
                                              current_user);

  if(has_privilege) then
    prvt_annotations_internal.add_to_group(group_name_formatted,
                                           obj#,
                                           obj_owner,
                                           identifier_type_int,
                                           identifier_components);
  else
    raise_application_error(-20000, 'Insufficient privileges');   
  end if;

end;

procedure delete_from_group(group_name      in VARCHAR2,
                            identifier_name in varchar2,
                            identifier_type in varchar2 default 'TABLE')
as 
  current_user            varchar2(M_IDEN);
  current_user_id         number;
  obj#                    number;
  obj_owner               number;
  identifier_type_int     number;
  identifier_components   identifier_components_t;
  opcode                  number;
  has_privilege           boolean   := FALSE;
  identifier_type_upper   varchar2(M_IDEN);
  group_name_formatted    varchar2(M_IDEN);
begin

  chk_null_group_operation(group_name,
                           group_name_formatted,
                           identifier_type,
                           identifier_type_upper,
                           identifier_name);

  sanitize_and_get_internal_rep(
       identifier_name,
       identifier_type_upper,
       identifier_type_int,
       obj#, 
       obj_owner,
       identifier_components);

  /* get user information */
  current_user := SYS_CONTEXT('USERENV', 'CURRENT_USER');
  select user_id into current_user_id
     from sys.all_users
     where username = current_user; 

  /* privilege check */    
  opcode := OPCODE_SET; 
  has_privilege := check_annotation_privilege(identifier_type_int,
                                              identifier_components,
                                              opcode,
                                              obj#,
                                              obj_owner,
                                              current_user_id,
                                              current_user);

  if(has_privilege) then
    prvt_annotations_internal.delete_from_group(group_name_formatted,
                                                obj#,
                                                obj_owner,
                                                identifier_type_int,
                                                identifier_components);
  else
    raise_application_error(-20000, 'Insufficient privileges');   
  end if;

end;

function get_version 
  return varchar2
is
begin
  return VERSION;
end get_version;

/* Initialization */
begin
 init_identifier_token_len;

end metadata_annotations;

/
--------------------------------------------------------
--  DDL for Package Body PKG_PEDIDO
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "UCM"."PKG_PEDIDO" IS
    PROCEDURE JRGY_PRO_GET_PEDIDO_DETALLE (
        COD_PEDIDO_P IN JRGY_PEDIDO.COD_PEDIDO%TYPE,
        CURSOR_P OUT CURSOR_P
    ) IS
    BEGIN
        OPEN CURSOR_P FOR
            SELECT P.COD_PEDIDO,
                   P.FECHA_PEDIDO,
                   P.VALOR_TOTAL AS VALOR_TOTAL_PEDIDO,
                   DP.COD_PROVEEDOR,
                   DP.NOMBRE_PRODUCTO,
                   DP.CANTIDAD_PRODUCTO,
                   DP.PRECIO_COMPRA,
                   DP.PRECIO_TOTAL AS VALOR_TOTAL_DETALLE
            FROM JRGY_PEDIDO P
            JOIN JRGY_DETALLE_PEDIDO DP ON DP.COD_PEDIDO = P.COD_PEDIDO
            WHERE P.COD_PEDIDO = COD_PEDIDO_P;
    END JRGY_PRO_GET_PEDIDO_DETALLE;
END PKG_PEDIDO;

/
--------------------------------------------------------
--  DDL for Package Body PKG_REPORTES
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "UCM"."PKG_REPORTES" AS
    PROCEDURE REP_TOP_PRODUCTOS_MES (ANIO IN NUMBER, MES IN NUMBER, CURSOR_OUT OUT CURSOR_P) IS
    BEGIN
        OPEN CURSOR_OUT FOR
            SELECT dv.COD_PRODUCTO,
                   SUM(dv.CANTIDAD) AS TOTAL_VENDIDO,
                   SUM(dv.PRECIO_TOTAL) AS TOTAL_MONTO
            FROM JRGY_VENTA v
            JOIN JRGY_DETALLE_VENTA dv ON dv.COD_VENTA = v.COD_VENTA
            WHERE EXTRACT(YEAR FROM v.FECHA_VENTA) = ANIO
              AND EXTRACT(MONTH FROM v.FECHA_VENTA) = MES
            GROUP BY dv.COD_PRODUCTO
            ORDER BY TOTAL_VENDIDO DESC;
    END;

    PROCEDURE REP_OCUPACION_HABITACIONES (CURSOR_OUT OUT CURSOR_P) IS
    BEGIN
        OPEN CURSOR_OUT FOR
            SELECT CEH.ESTADO_HABITACION,
                   COUNT(*) AS TOTAL
            FROM JRGY_HABITACION H
            LEFT JOIN JRGY_CAT_ESTADO_HABITACION CEH ON CEH.COD_ESTADO_HABITACION = H.COD_ESTADO_HABITACION
            GROUP BY CEH.ESTADO_HABITACION;
    END;

    PROCEDURE REP_COMPRAS_POR_PROVEEDOR (CURSOR_OUT OUT CURSOR_P) IS
    BEGIN
        OPEN CURSOR_OUT FOR
            SELECT dp.COD_PROVEEDOR,
                   SUM(dp.PRECIO_TOTAL) AS TOTAL_COMPRADO,
                   COUNT(*) AS LINEAS
            FROM JRGY_DETALLE_PEDIDO dp
            GROUP BY dp.COD_PROVEEDOR
            ORDER BY TOTAL_COMPRADO DESC;
    END;
END PKG_REPORTES;

/
--------------------------------------------------------
--  DDL for Package Body PRVT_ANNOTATIONS_INTERNAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE BODY "UCM"."PRVT_ANNOTATIONS_INTERNAL" 
as 

  FUNCTION get_group_id(p_group_name IN VARCHAR2)
    RETURN NUMBER
  IS
    v_group_id NUMBER;
  BEGIN

    SELECT group_id
      INTO v_group_id
      FROM annotations_groups$
    WHERE group_name = p_group_name;

    RETURN v_group_id;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN

      RAISE_APPLICATION_ERROR(-20000, 'Group Name not found.');
    WHEN OTHERS THEN
        RAISE;
  END get_group_id;

/* 
 * 
 * 1. Translate_annotation_type: Translate user specified annotation type to a package defined
 *    constant 
 * 2. Dictionary_update: Insert entry to annotations catalog table
 * 
 * Notes:
 *        Provenance tracking:
 *
 *        Provenance includes 
 *           1. Tracking user who created the annotation. 
 *           2. Time of annotation
 *
 *        Annotation owner is the current user who invoked the 
 *        annotation package, so that tracks one part of the provenance
 *
 *       Concurrency control:
 *           The burden of preventing the object of hte entity being
 *           annotated from being dropped belongs to the invoker of the  
 *           package. This is because, there is nothing prventing the 
 *           drop of the object from the time of invocation to the 
 *           execution of the first statement in the PL/SQL package
 */ 
procedure set(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_value      in varchar2,
          v_annotation_type_int   in number,
          v_obj#                  in number,
          obj#_owner              in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
as
      l_column_name     varchar2(128) := NULL;
      l_procedure_name  varchar2(128) := NULL;
      l_function_name   varchar2(128) := NULL;
      l_obj#            number        := NULL;
      l_obj_owner       number        := NULL;
      l_group_id        number        := NULL;
begin

   -- Handle database-level (no identifier components / null obj#)
   IF (v_identifier_components IS NULL OR v_identifier_components.COUNT = 0) THEN
      -- Only allow this when type is database-level
      IF v_annotation_type_int != IDENTIFIER_DATABASE THEN
         raise_application_error(
           -20002,
           'Only database-level annotations can have NULL identifier components'
         );
      END IF;

      l_obj#      := v_obj#;          --  ( will be -1 for IDENTIFIER_DATABASE)
      l_obj_owner := obj#_owner;      --  ( will be -1 for IDENTIFIER_DATABASE)

   ELSE
      -- Extract from identifier components
      IF v_identifier_components.EXISTS('COLUMN_NAME') THEN
          l_column_name := v_identifier_components('COLUMN_NAME');
      END IF;

      IF v_identifier_components.EXISTS('PROCEDURE_NAME') THEN
          l_procedure_name := v_identifier_components('PROCEDURE_NAME');
      END IF;

      IF v_identifier_components.EXISTS('FUNCTION_NAME') THEN
          l_function_name := v_identifier_components('FUNCTION_NAME');
      END IF;

      IF v_identifier_components.EXISTS('GROUP_NAME') THEN
          l_group_id := get_group_id(v_identifier_components('GROUP_NAME'));
      END IF;

      l_obj#      := v_obj#;
      l_obj_owner := obj#_owner;
   END IF;

   /* Dictionary update with DDL-like semantics */
   COMMIT;

   INSERT INTO annotations_usage$
           (annotation_owner,
            annotation_name,
            annotation_value,
            annotation_type,
            creation_time,
            obj#,
            object_owner,
            column_name,
            procedure_name,
            function_name,
            group_id)
   VALUES (v_annotation_owner,
           v_annotation_name,
           v_annotation_value,
           v_annotation_type_int,
           SYSTIMESTAMP,
           l_obj#,
           l_obj_owner,
           l_column_name,
           l_procedure_name,
           l_function_name,
           l_group_id);

   COMMIT;

exception
   WHEN DUP_VAL_ON_INDEX THEN
       raise_application_error(-20000,
         'Annotation already exists. Use edit procedure to replace value');
   WHEN others THEN
       raise;
end;

procedure edit(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_value      in varchar2,
          v_annotation_type_int   In number,
          v_obj#                  in number,
          obj_owner               in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
as 
  v_rows_updated number;
  l_group_id number;
begin
   commit;   

      CASE 
        /* 
         * Identifier_type represents an object
         */ 
        when v_annotation_type_int in ( IDENTIFIER_TABLE,
                                        IDENTIFIER_TABLE_PARTITION, 
                                        IDENTIFIER_TABLE_SUBPARTITION,
                                        IDENTIFIER_VIEW,
                                        IDENTIFIER_PACKAGE, 
                                        IDENTIFIER_PROCEDURE,
                                        IDENTIFIER_FUNCTION,
                                        IDENTIFIER_MTRLZD_VIEW) 
        then
            update annotations_usage$   
            set annotation_value = v_annotation_value
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name;

       /* 
        * The next few identifier types have a parent object
        */

        when v_annotation_type_int in (IDENTIFIER_TABLE_COLUMN, 
                                       IDENTIFIER_VIEW_COLUMN, 
                                       IDENTIFIER_MTRLZD_VIEW_COLUMN) 
        then 

            update annotations_usage$   
            set annotation_value = v_annotation_value
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and column_name = v_identifier_components('COLUMN_NAME');

        when v_annotation_type_int in (IDENTIFIER_PACKAGE_FUNCTION)
        then

            update annotations_usage$   
            set annotation_value = v_annotation_value
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and function_name = v_identifier_components('FUNCTION_NAME');

        when v_annotation_type_int in (IDENTIFIER_PACKAGE_PROCEDURE)
        then

            update annotations_usage$   
            set annotation_value = v_annotation_value
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and procedure_name = v_identifier_components('PROCEDURE_NAME');

         /* The next few identifier types do not have a parent object */


        when v_annotation_type_int in (IDENTIFIER_SCHEMA)
        then

            update annotations_usage$   
            set annotation_value = v_annotation_value 
             where annotation_type = v_annotation_type_int
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and obj# = -1
               and object_owner = obj_owner;

        when v_annotation_type_int in (IDENTIFIER_DATABASE)
        then

            update annotations_usage$   
            set annotation_value = v_annotation_value
             where annotation_type = v_annotation_type_int
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and obj# = -1
               and object_owner = -1;

        when v_annotation_type_int in (IDENTIFIER_GROUP) 
        then

            l_group_id := get_group_id(v_identifier_components('GROUP_NAME'));

            update annotations_usage$   
            set annotation_value = v_annotation_value
             where annotation_type = v_annotation_type_int
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and obj# = -1
               and object_owner = -1
               and group_id = l_group_id;

      else

        raise_application_error(-20000, 'invalid identifier type');   

      END CASE;

       v_rows_updated := SQL%ROWCOUNT;

   commit;

   if(v_rows_updated = 0) then
      raise_application_error(-20000, 'Annotation does not exist. Use set ' 
            || 'procedure to add annotation') ;
   end if;
end;

/* internal implementation of get annotation */
function get(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_type_int   in number,
          v_obj#                  in number,
          v_obj#_owner            in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
return clob
as 
v_annotations_clob  clob  := NULL;
l_group_id number := NULL;
begin

  begin

    case  
      /* 
       * Identifier_type represents an object
       */ 
      when v_annotation_type_int in ( IDENTIFIER_TABLE,
                                      IDENTIFIER_TABLE_PARTITION, 
                                      IDENTIFIER_TABLE_SUBPARTITION,
                                      IDENTIFIER_VIEW,
                                      IDENTIFIER_PACKAGE, 
                                      IDENTIFIER_PROCEDURE,
                                      IDENTIFIER_FUNCTION,
                                      IDENTIFIER_MTRLZD_VIEW) 
      then
        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = v_obj#
           and object_owner = v_obj#_owner
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name;

     /* 
      * The next few identifier types have a parent object
      */
      when v_annotation_type_int in (IDENTIFIER_TABLE_COLUMN, 
                                     IDENTIFIER_VIEW_COLUMN, 
                                     IDENTIFIER_MTRLZD_VIEW_COLUMN) 
      then 
        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = v_obj#
           and object_owner = v_obj#_owner
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name
           and column_name = v_identifier_components('COLUMN_NAME');

      when v_annotation_type_int in (IDENTIFIER_PACKAGE_FUNCTION)
      then
        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = v_obj#
           and object_owner = v_obj#_owner
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name
           and function_name = v_identifier_components('FUNCTION_NAME');

      when v_annotation_type_int in (IDENTIFIER_PACKAGE_PROCEDURE)
      then
        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = v_obj#
           and object_owner = v_obj#_owner
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name
           and procedure_name = v_identifier_components('PROCEDURE_NAME');

      when v_annotation_type_int in (IDENTIFIER_SCHEMA)
      then
        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = -1
           and object_owner = v_obj#_owner
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name;

      when v_annotation_type_int in (IDENTIFIER_DATABASE)
      then
        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = -1
           and object_owner = -1
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name;

      when v_annotation_type_int in (IDENTIFIER_GROUP) 
      then

        l_group_id := get_group_id(v_identifier_components('GROUP_NAME'));

        select to_clob(annotation_value) into v_annotations_clob
        from annotations_usage$ 
         where annotation_type = v_annotation_type_int
           and obj# = -1
           and object_owner = -1
           and annotation_owner = v_annotation_owner
           and annotation_name = v_annotation_name
           and group_id = l_group_id;

      else
        raise_application_error(-20000, 'invalid identifier type');   
    end case;

  exception
    when NO_DATA_FOUND then
      raise_application_error(-20001, 'Annotation name not found');
    when others then 
      raise;
  end;

  return v_annotations_clob;

end;

procedure delete(
          v_annotation_owner      in number,
          v_annotation_name       in varchar2,
          v_annotation_type_int   In number,
          v_obj#                  in number,
          obj_owner               in number,
          v_identifier_components in
          metadata_annotations.identifier_components_t)
as 
   v_rows_deleted number;
   l_group_id       number;
begin

  commit;
     /* Use different queries for various identifier types. The code would be more 
      * compact if we constructed there clause for different identifier types
      * and issued a dynamic SQL after constructing the delete statement. However,
      * this longer version is more readable, even if verbose.
      */
     CASE
        /* 
         * Identifier_type represents an object
         */ 
        when v_annotation_type_int in ( IDENTIFIER_TABLE,
                                        IDENTIFIER_TABLE_PARTITION, 
                                        IDENTIFIER_TABLE_SUBPARTITION,
                                        IDENTIFIER_VIEW,
                                        IDENTIFIER_PACKAGE, 
                                        IDENTIFIER_PROCEDURE,
                                        IDENTIFIER_FUNCTION,
                                        IDENTIFIER_MTRLZD_VIEW) 
        then
            delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name;

       /* 
        * The next few identifier types have a parent object
        */

        when v_annotation_type_int in (IDENTIFIER_TABLE_COLUMN, 
                                       IDENTIFIER_VIEW_COLUMN, 
                                       IDENTIFIER_MTRLZD_VIEW_COLUMN) 
        then 

            delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and column_name = v_identifier_components('COLUMN_NAME');

        when v_annotation_type_int in (IDENTIFIER_PACKAGE_FUNCTION)
        then

            delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and function_name = v_identifier_components('FUNCTION_NAME');

        when v_annotation_type_int in (IDENTIFIER_PACKAGE_PROCEDURE)
        then

            delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and obj# = v_obj#
               and object_owner = obj_owner
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and procedure_name = v_identifier_components('PROCEDURE_NAME');

         /* The next few identifier types do not have a parent object */


        when v_annotation_type_int in (IDENTIFIER_SCHEMA)
        then

           delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and obj# = -1
               and object_owner = obj_owner;

        when v_annotation_type_int in (IDENTIFIER_DATABASE)
        then

            delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and obj# = -1
               and object_owner = -1;

        when v_annotation_type_int in (IDENTIFIER_GROUP) 
        then

            l_group_id := get_group_id(v_identifier_components('GROUP_NAME'));

            delete annotations_usage$  
             where annotation_type = v_annotation_type_int
               and annotation_owner = v_annotation_owner
               and annotation_name = v_annotation_name
               and obj# = -1
               and object_owner = -1
               and group_id = l_group_id;

      else

        raise_application_error(-20000, 'invalid identifier type');   

      END CASE;

   v_rows_deleted := SQL%ROWCOUNT;

   commit;

   if(v_rows_deleted = 0) then
      raise_application_error(-20000, 'Annotation does not exist.' 
            || ' Nothing to delete') ;
   end if;

end;


procedure create_group(v_group_name in VARCHAR2)
as 
  v_group_id NUMBER;
begin

  SELECT group_id_seq.NEXTVAL INTO v_group_id FROM SYS.DUAL;

  commit;

  INSERT INTO annotations_groups$ (group_id, group_name, creation_time)
  VALUES (v_group_id, v_group_name, SYSTIMESTAMP);

  commit;

  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      RAISE_APPLICATION_ERROR(-20000, 'Group Name already exists.');

end;

procedure drop_group(v_group_name in VARCHAR2)
as 
begin

  commit;

  DELETE FROM annotations_groups$ WHERE group_name = v_group_name;

  IF SQL%ROWCOUNT = 0 THEN
    RAISE_APPLICATION_ERROR(-20000, 'Group Name not found.');
  END IF;

  commit;

end;

procedure add_to_group(
      v_group_name            in VARCHAR2,
      v_object_id             in NUMBER,
      v_object_owner          in NUMBER,
      v_annotation_type_int   in number,
      v_identifier_components in 
      metadata_annotations.identifier_components_t)
as 
  l_group_id        NUMBER;
  l_column_name     varchar2(128) := NULL;
  l_procedure_name  varchar2(128) := NULL;
  l_function_name   varchar2(128) := NULL;
begin

  BEGIN

    SELECT group_id into l_group_id 
    from annotations_groups$ 
    where group_name = v_group_name;

  EXCEPTION

    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20001, 'Group does not exist.');

  END;

  IF v_identifier_components.EXISTS('COLUMN_NAME') THEN
      l_column_name := v_identifier_components('COLUMN_NAME');
  END IF;

  IF v_identifier_components.EXISTS('PROCEDURE_NAME') THEN
      l_procedure_name := v_identifier_components('PROCEDURE_NAME');
  END IF;

  IF v_identifier_components.EXISTS('FUNCTION_NAME') THEN
      l_function_name := v_identifier_components('FUNCTION_NAME');
  END IF;

  commit;

  INSERT INTO annotations_group_members$ 
        (group_id, obj#, object_owner, annotation_type, 
        column_name, function_name, procedure_name)
  VALUES (l_group_id, v_object_id, v_object_owner, v_annotation_type_int,
          l_column_name, l_function_name, l_procedure_name);

  commit;

exception

  WHEN DUP_VAL_ON_INDEX THEN
    RAISE_APPLICATION_ERROR(-20004, 'Object already added to group.');

  WHEN OTHERS THEN
      IF SQLCODE = -2291 THEN /* Parent Key (Group Id) doesn't exit */
          RAISE_APPLICATION_ERROR(-20001, 'Group does not exist');
      ELSE
          RAISE_APPLICATION_ERROR(-20002, 'Error adding member: ' || SQLERRM);
      END IF;

end;

procedure delete_from_group(
      v_group_name            in VARCHAR2,
      v_object_id             in NUMBER,
      v_object_owner          in NUMBER,
      v_annotation_type_int   in number,
      v_identifier_components in 
      metadata_annotations.identifier_components_t)
as 
  v_group_id NUMBER;
  v_rows_deleted number;
begin

  BEGIN

    SELECT group_id into v_group_id 
    from annotations_groups$ 
    where group_name = v_group_name;

  EXCEPTION

    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20001, 'Group does not exist.');

  END;

  commit;

   /* Use different queries for various identifier types. The code would be more 
    * compact if we constructed there clause for different identifier types
    * and issued a dynamic SQL after constructing the delete statement. However,
    * this longer version is more readable, even if verbose.
    */
   CASE
      /* 
       * Identifier_type represents an object
       */ 
      when v_annotation_type_int in ( IDENTIFIER_TABLE,
                                      IDENTIFIER_TABLE_PARTITION, 
                                      IDENTIFIER_TABLE_SUBPARTITION,
                                      IDENTIFIER_VIEW,
                                      IDENTIFIER_PACKAGE, 
                                      IDENTIFIER_PROCEDURE,
                                      IDENTIFIER_FUNCTION,
                                      IDENTIFIER_MTRLZD_VIEW) 
      then
          delete annotations_group_members$  
           where group_id = v_group_id
             and annotation_type = v_annotation_type_int
             and obj# = v_object_id
             and object_owner = v_object_owner;

     /* 
      * The next few identifier types have a parent object
      */

      when v_annotation_type_int in (IDENTIFIER_TABLE_COLUMN, 
                                     IDENTIFIER_VIEW_COLUMN, 
                                     IDENTIFIER_MTRLZD_VIEW_COLUMN) 
      then 

          delete annotations_group_members$  
           where group_id = v_group_id
             and annotation_type = v_annotation_type_int
             and obj# = v_object_id
             and object_owner = v_object_owner
             and column_name = v_identifier_components('COLUMN_NAME');

      when v_annotation_type_int in (IDENTIFIER_PACKAGE_FUNCTION)
      then

          delete annotations_group_members$  
           where group_id = v_group_id
             and annotation_type = v_annotation_type_int
             and obj# = v_object_id
             and object_owner = v_object_owner
             and function_name = v_identifier_components('FUNCTION_NAME');

      when v_annotation_type_int in (IDENTIFIER_PACKAGE_PROCEDURE)
      then

          delete annotations_group_members$  
           where group_id = v_group_id
             and annotation_type = v_annotation_type_int
             and obj# = v_object_id
             and object_owner = v_object_owner
             and procedure_name = v_identifier_components('PROCEDURE_NAME');

       /* The next few identifier types do not have a parent object */


      when v_annotation_type_int in (IDENTIFIER_SCHEMA)
      then


          delete annotations_group_members$  
           where group_id = v_group_id
             and annotation_type = v_annotation_type_int
             and obj# = -1
             and object_owner = v_object_owner;

      when v_annotation_type_int in (IDENTIFIER_DATABASE)
      then

          delete annotations_group_members$  
           where group_id = v_group_id
             and annotation_type = v_annotation_type_int
             and obj# = -1
             and object_owner = -1;


    else

      raise_application_error(-20000, 'invalid identifier type');   

    END CASE;

 v_rows_deleted := SQL%ROWCOUNT;

 commit;

 if(v_rows_deleted = 0) then
    raise_application_error(-20000, 'Object Not found in Group') ;
 end if;

end;

end prvt_annotations_internal;

/
--------------------------------------------------------
--  DDL for Function FN_CALC_COMISION
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "UCM"."FN_CALC_COMISION" (COD_EMPLEADO_P IN NUMBER, MONTO_VENTA IN NUMBER) RETURN NUMBER IS
    PCT NUMBER;
BEGIN
    SELECT NVL(COMISION, 0) INTO PCT FROM JRGY_EMPLEADO WHERE COD_EMPLEADO = COD_EMPLEADO_P;
    RETURN ROUND(MONTO_VENTA * (PCT / 100), 2);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;

/
--------------------------------------------------------
--  DDL for Function FN_CALC_IVA
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "UCM"."FN_CALC_IVA" (MONTO IN NUMBER) RETURN NUMBER IS
BEGIN
    RETURN ROUND(MONTO * 0.19, 2);
END;

/
--------------------------------------------------------
--  DDL for Function FN_STOCK_DISP
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "UCM"."FN_STOCK_DISP" (COD_PRODUCTO_P IN NUMBER) RETURN NUMBER IS
    STK NUMBER;
BEGIN
    SELECT NVL(STOCK_PRODUCTO, 0) INTO STK FROM JRGY_PRODUCTO WHERE COD_PRODUCTO = COD_PRODUCTO_P;
    RETURN STK;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;

/
--------------------------------------------------------
--  DDL for Function FN_RESERVAS_ACTIVAS_HAB
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "UCM"."FN_RESERVAS_ACTIVAS_HAB" (
    P_HABITACION_ID IN NUMBER,
    P_EXCEPT_RESERVA_ID IN NUMBER,
    P_ESTADO_ACTIVO_1 IN NUMBER,
    P_ESTADO_ACTIVO_2 IN NUMBER
  ) RETURN NUMBER
IS
    PRAGMA AUTONOMOUS_TRANSACTION;
    V_COUNT NUMBER := 0;
BEGIN
    IF P_HABITACION_ID IS NULL THEN
        RETURN 0;
    END IF;

    SELECT COUNT(*)
    INTO V_COUNT
    FROM JRGY_RESERVA
    WHERE COD_HABITACION = P_HABITACION_ID
      AND (P_EXCEPT_RESERVA_ID IS NULL OR COD_RESERVA <> P_EXCEPT_RESERVA_ID)
      AND COD_ESTADO_RESERVA IN (P_ESTADO_ACTIVO_1, P_ESTADO_ACTIVO_2);

    RETURN NVL(V_COUNT, 0);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;

/
--------------------------------------------------------
--  DDL for Function JRGY_FUN_DEP_SUELDO_TOTAL
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE FUNCTION "UCM"."JRGY_FUN_DEP_SUELDO_TOTAL" (
    P_DEP_ID IN NUMBER
) RETURN NUMBER
IS
    V_TOTAL NUMBER;
BEGIN
    SELECT NVL(SUM(NVL(SUELDO_BASE, SALARIO)), 0)
    INTO V_TOTAL
    FROM JRGY_EMPLEADO
    WHERE COD_DEPARTAMENTO = P_DEP_ID;

    RETURN V_TOTAL;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
END;

/
--------------------------------------------------------
--  Constraints for Table ANNOTATIONS_GROUP_MEMBERS$
--------------------------------------------------------

  ALTER TABLE "UCM"."ANNOTATIONS_GROUP_MEMBERS$" ADD CONSTRAINT "UNIQUE_GROUP_MEMBER" UNIQUE ("GROUP_ID", "OBJ#", "OBJECT_OWNER", "ANNOTATION_TYPE", "COLUMN_NAME", "FUNCTION_NAME", "PROCEDURE_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ANNOTATIONS_GROUPS$
--------------------------------------------------------

  ALTER TABLE "UCM"."ANNOTATIONS_GROUPS$" ADD PRIMARY KEY ("GROUP_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "UCM"."ANNOTATIONS_GROUPS$" ADD CONSTRAINT "UC_GROUP_MEMBER" UNIQUE ("GROUP_NAME")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ANNOTATIONS_PREBUILT$
--------------------------------------------------------

  ALTER TABLE "UCM"."ANNOTATIONS_PREBUILT$" MODIFY ("ANNOTATION_NAME" NOT NULL ENABLE);
  ALTER TABLE "UCM"."ANNOTATIONS_PREBUILT$" MODIFY ("DESCRIPTION" NOT NULL ENABLE);
  ALTER TABLE "UCM"."ANNOTATIONS_PREBUILT$" MODIFY ("CATEGORY" NOT NULL ENABLE);
  ALTER TABLE "UCM"."ANNOTATIONS_PREBUILT$" ADD CONSTRAINT "UNIQUE_PREBUILT_ANNOTATIONS" UNIQUE ("ANNOTATION_NAME", "CATEGORY")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 125 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table ANNOTATIONS_USAGE$
--------------------------------------------------------

  ALTER TABLE "UCM"."ANNOTATIONS_USAGE$" MODIFY ("ANNOTATION_NAME" NOT NULL ENABLE);
  ALTER TABLE "UCM"."ANNOTATIONS_USAGE$" MODIFY ("OBJ#" NOT NULL ENABLE);
  ALTER TABLE "UCM"."ANNOTATIONS_USAGE$" ADD CONSTRAINT "UNIQUE_ANNOTATION_ENFORCER" UNIQUE ("OBJ#", "OBJECT_OWNER", "ANNOTATION_TYPE", "ANNOTATION_NAME", "COLUMN_NAME", "FUNCTION_NAME", "PROCEDURE_NAME", "GROUP_ID")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CALLE
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CALLE" ADD CONSTRAINT "PK_JRGY_CALLE" PRIMARY KEY ("COD_CALLE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_ESTADO_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_ESTADO_HABITACION" ADD CONSTRAINT "PK_JRGY_CAT_ESTADO_HABITACION" PRIMARY KEY ("COD_ESTADO_HABITACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_ESTADO_LABORAL
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_ESTADO_LABORAL" ADD CONSTRAINT "PK_JRGY_CAT_ESTADO_LABORAL" PRIMARY KEY ("COD_ESTADO_LABORAL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_ESTADO_RESERVA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_ESTADO_RESERVA" ADD CONSTRAINT "PK_JRGY_CAT_ESTADO_RESERVA" PRIMARY KEY ("COD_ESTADO_RESERVA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_ESTADO_USUARIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_ESTADO_USUARIO" ADD CONSTRAINT "PK_JRGY_CAT_ESTADO_USUARIO" PRIMARY KEY ("COD_ESTADO_USUARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_MODO_PAGO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_MODO_PAGO" ADD CONSTRAINT "PK_JRGY_CAT_MODO_PAGO" PRIMARY KEY ("COD_MODO_PAGO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_TIPO_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_TIPO_HABITACION" MODIFY ("TIPO_HABITACION" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_CAT_TIPO_HABITACION" ADD CONSTRAINT "PK_JRGY_CAT_TIPO_HABITACION" PRIMARY KEY ("COD_TIPO_HABITACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "UCM"."JRGY_CAT_TIPO_HABITACION" ADD CONSTRAINT "UQ_JRGY_CAT_TIPO_HABITACION" UNIQUE ("TIPO_HABITACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CAT_TIPO_SERVICIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CAT_TIPO_SERVICIO" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_CAT_TIPO_SERVICIO" ADD CONSTRAINT "PK_JRGY_CAT_TIPO_SERVICIO" PRIMARY KEY ("COD_TIPO_SERVICIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "UCM"."JRGY_CAT_TIPO_SERVICIO" ADD CONSTRAINT "UQ_JRGY_CAT_TIPO_SERVICIO" UNIQUE ("NOMBRE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CIUDAD
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CIUDAD" ADD CONSTRAINT "PK_JRGY_CIUDAD" PRIMARY KEY ("COD_CIUDAD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_CLIENTE
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CLIENTE" ADD CONSTRAINT "PK_JRGY_CLIENTE" PRIMARY KEY ("COD_CLIENTE")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_COMUNA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_COMUNA" ADD CONSTRAINT "PK_JRGY_COMUNA" PRIMARY KEY ("COD_COMUNA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_DEPARTAMENTO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DEPARTAMENTO" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_DEPARTAMENTO" ADD PRIMARY KEY ("COD_DEPARTAMENTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_DEPARTAMENTO_EMPLEADO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DEPARTAMENTO_EMPLEADO" MODIFY ("COD_DEPARTAMENTO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_DEPARTAMENTO_EMPLEADO" MODIFY ("COD_EMPLEADO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_DEPARTAMENTO_EMPLEADO" ADD CONSTRAINT "PK_JRGY_DEP_EMP" PRIMARY KEY ("COD_DEPARTAMENTO", "COD_EMPLEADO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_DETALLE_PAGO_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DETALLE_PAGO_HABITACION" ADD CONSTRAINT "PK_JRGY_DETALLE_PAGO_HABITACION" PRIMARY KEY ("COD_PAGO_HABITACION", "COD_HABITACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_DETALLE_PEDIDO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DETALLE_PEDIDO" ADD CONSTRAINT "PK_JRGY_DETALLE_PEDIDO" PRIMARY KEY ("COD_PEDIDO", "COD_PROVEEDOR", "COD_PRODUCTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_DETALLE_VENTA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DETALLE_VENTA" ADD CONSTRAINT "PK_JRGY_DETALLE_VENTA" PRIMARY KEY ("COD_VENTA", "COD_PRODUCTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_EMPLEADO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EMPLEADO" ADD CONSTRAINT "PK_JRGY_EMPLEADO" PRIMARY KEY ("COD_EMPLEADO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_EMPLEADO_HABILIDAD
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EMPLEADO_HABILIDAD" MODIFY ("COD_EMPLEADO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_EMPLEADO_HABILIDAD" MODIFY ("CATEGORIA" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_EMPLEADO_HABILIDAD" MODIFY ("TIPO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_EMPLEADO_HABILIDAD" ADD CONSTRAINT "PK_JRGY_EMP_HAB" PRIMARY KEY ("COD_EMPLEADO", "CATEGORIA", "TIPO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_EVENTO_RESERVA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EVENTO_RESERVA" MODIFY ("COD_RESERVA" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_EVENTO_RESERVA" ADD CONSTRAINT "PK_JRGY_EVENTO_RESERVA" PRIMARY KEY ("COD_EVENTO_RESERVA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_EXPERIENCIA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EXPERIENCIA" ADD CONSTRAINT "PK_JRGY_EXPERIENCIA" PRIMARY KEY ("COD_EXPERIENCIA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_HABITACION" ADD CONSTRAINT "PK_JRGY_HABITACION" PRIMARY KEY ("COD_HABITACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_MOVIMIENTO_STOCK
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_MOVIMIENTO_STOCK" ADD CONSTRAINT "PK_JRGY_MOVIMIENTO_STOCK" PRIMARY KEY ("COD_MOVIMIENTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_PAGO_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PAGO_HABITACION" ADD CONSTRAINT "PK_JRGY_PAGO_HABITACION" PRIMARY KEY ("COD_PAGO_HABITACION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_PAGO_VENTA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PAGO_VENTA" ADD CONSTRAINT "PK_JRGY_PAGO_VENTA" PRIMARY KEY ("COD_PAGO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_PEDIDO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PEDIDO" ADD CONSTRAINT "PK_JRGY_PEDIDO" PRIMARY KEY ("COD_PEDIDO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_PRODUCTO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PRODUCTO" ADD CONSTRAINT "PK_JRGY_PRODUCTO" PRIMARY KEY ("COD_PRODUCTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_PROVEEDOR
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PROVEEDOR" ADD CONSTRAINT "PK_JRGY_PROVEEDOR" PRIMARY KEY ("COD_PROVEEDOR")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_REGION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_REGION" ADD CONSTRAINT "PK_JRGY_REGION" PRIMARY KEY ("COD_REGION")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_RESERVA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_RESERVA" MODIFY ("COD_USUARIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA" MODIFY ("COD_HABITACION" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA" MODIFY ("FECHA_INICIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA" MODIFY ("FECHA_FIN" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA" ADD CONSTRAINT "CHK_JRGY_RESERVA_FECHAS" CHECK (FECHA_FIN >= FECHA_INICIO) ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA" ADD CONSTRAINT "PK_JRGY_RESERVA" PRIMARY KEY ("COD_RESERVA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_RESERVA_EXP
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_RESERVA_EXP" MODIFY ("COD_RESERVA" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_EXP" MODIFY ("COD_EXPERIENCIA" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_EXP" ADD CONSTRAINT "PK_JRGY_RESERVA_EXP" PRIMARY KEY ("COD_RESERVA_EXP")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_RESERVA_SERVICIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" MODIFY ("COD_RESERVA" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" MODIFY ("COD_SERVICIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" MODIFY ("FECHA_SERVICIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" MODIFY ("HORA" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" MODIFY ("CANTIDAD" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" MODIFY ("PRECIO_UNIT" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" ADD CONSTRAINT "CHK_JRGY_RES_SERV_ESTADO" CHECK (LOWER(ESTADO) IN ('pendiente', 'confirmado', 'cancelado')) ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" ADD CONSTRAINT "CHK_JRGY_RES_SERV_CANT" CHECK (CANTIDAD > 0) ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" ADD CONSTRAINT "CHK_JRGY_RES_SERV_HORA" CHECK (HORA BETWEEN 0 AND 23) ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" ADD CONSTRAINT "PK_JRGY_RESERVA_SERVICIO" PRIMARY KEY ("COD_RESERVA_SERVICIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_ROL
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_ROL" ADD CONSTRAINT "PK_JRGY_ROL" PRIMARY KEY ("COD_ROL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_SERVICIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO" MODIFY ("NOMBRE" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO" MODIFY ("PRECIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO" MODIFY ("ESTADO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO" ADD CONSTRAINT "CHK_JRGY_SERVICIO_ESTADO" CHECK (LOWER(ESTADO) IN ('activo', 'inactivo')) ENABLE;
  ALTER TABLE "UCM"."JRGY_SERVICIO" ADD CONSTRAINT "CHK_JRGY_SERVICIO_DEST" CHECK (ES_DESTACADO IN ('Y', 'N')) ENABLE;
  ALTER TABLE "UCM"."JRGY_SERVICIO" ADD CONSTRAINT "PK_JRGY_SERVICIO" PRIMARY KEY ("COD_SERVICIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_SERVICIO_HORARIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO_HORARIO" MODIFY ("COD_SERVICIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_HORARIO" MODIFY ("HORA_INICIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_HORARIO" MODIFY ("HORA_FIN" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_HORARIO" ADD CONSTRAINT "CHK_JRGY_SERV_HOR_HORAS" CHECK (HORA_INICIO BETWEEN 0 AND 23.99 AND HORA_FIN BETWEEN 0 AND 23.99 AND HORA_FIN >= HORA_INICIO) ENABLE;
  ALTER TABLE "UCM"."JRGY_SERVICIO_HORARIO" ADD CONSTRAINT "PK_JRGY_SERVICIO_HORARIO" PRIMARY KEY ("COD_HORARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_SERVICIO_PAQUETE
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO_PAQUETE" MODIFY ("COD_PAQUETE" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_PAQUETE" MODIFY ("COD_SERVICIO_INCL" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_PAQUETE" ADD CONSTRAINT "PK_JRGY_SERVICIO_PAQUETE" PRIMARY KEY ("COD_PAQUETE", "COD_SERVICIO_INCL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_SERVICIO_PRODUCTO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO_PRODUCTO" MODIFY ("COD_SERVICIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_PRODUCTO" MODIFY ("COD_PRODUCTO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SERVICIO_PRODUCTO" ADD CONSTRAINT "PK_JRGY_SERVICIO_PRODUCTO" PRIMARY KEY ("COD_SERVICIO", "COD_PRODUCTO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_SOLICITUD_ADMIN
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SOLICITUD_ADMIN" MODIFY ("COD_USUARIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SOLICITUD_ADMIN" MODIFY ("ESTADO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_SOLICITUD_ADMIN" ADD CONSTRAINT "CHK_JRGY_SOLICITUD_ESTADO" CHECK (ESTADO IN ('pending', 'approved', 'rejected')) ENABLE;
  ALTER TABLE "UCM"."JRGY_SOLICITUD_ADMIN" ADD CONSTRAINT "PK_JRGY_SOLICITUD_ADMIN" PRIMARY KEY ("COD_SOLICITUD")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_USUARIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_USUARIO" MODIFY ("COD_USUARIO" NOT NULL ENABLE);
  ALTER TABLE "UCM"."JRGY_USUARIO" ADD CONSTRAINT "CHK_JRGY_USUARIO_RUT" CHECK (COD_USUARIO BETWEEN 1000000 AND 99999999) ENABLE;
  ALTER TABLE "UCM"."JRGY_USUARIO" ADD CONSTRAINT "PK_JRGY_USUARIO" PRIMARY KEY ("COD_USUARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
  ALTER TABLE "UCM"."JRGY_USUARIO" ADD CONSTRAINT "UK_JRGY_USUARIO_EMAIL" UNIQUE ("EMAIL_USUARIO")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_USUARIO_ROL
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_USUARIO_ROL" ADD CONSTRAINT "PK_JRGY_USUARIO_ROL" PRIMARY KEY ("COD_USUARIO", "COD_ROL")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table JRGY_VENTA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_VENTA" ADD CONSTRAINT "PK_JRGY_VENTA" PRIMARY KEY ("COD_VENTA")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Constraints for Table TOKENS
--------------------------------------------------------

  ALTER TABLE "UCM"."TOKENS" MODIFY ("USER_ID" NOT NULL ENABLE);
  ALTER TABLE "UCM"."TOKENS" ADD CONSTRAINT "PK_TOKENS" PRIMARY KEY ("TOKEN")
  USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1
  BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT)
  TABLESPACE "USERS"  ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table ANNOTATIONS_GROUP_MEMBERS$
--------------------------------------------------------

  ALTER TABLE "UCM"."ANNOTATIONS_GROUP_MEMBERS$" ADD CONSTRAINT "FK_GROUP" FOREIGN KEY ("GROUP_ID")
	  REFERENCES "UCM"."ANNOTATIONS_GROUPS$" ("GROUP_ID") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_CALLE
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CALLE" ADD CONSTRAINT "FK_JRGY_CALLE_COMUNA" FOREIGN KEY ("COD_COMUNA")
	  REFERENCES "UCM"."JRGY_COMUNA" ("COD_COMUNA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_CIUDAD
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CIUDAD" ADD CONSTRAINT "FK_JRGY_CIUDAD_REGION" FOREIGN KEY ("COD_REGION")
	  REFERENCES "UCM"."JRGY_REGION" ("COD_REGION") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_CLIENTE
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_CLIENTE" ADD CONSTRAINT "FK_JRGY_CLIENTE_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_COMUNA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_COMUNA" ADD CONSTRAINT "FK_JRGY_COMUNA_CIUDAD" FOREIGN KEY ("COD_CIUDAD")
	  REFERENCES "UCM"."JRGY_CIUDAD" ("COD_CIUDAD") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_DEPARTAMENTO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DEPARTAMENTO" ADD CONSTRAINT "FK_JRGY_DEPTO_JEFE" FOREIGN KEY ("JEFE_EMPLEADO_ID")
	  REFERENCES "UCM"."JRGY_EMPLEADO" ("COD_EMPLEADO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_DETALLE_PAGO_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DETALLE_PAGO_HABITACION" ADD CONSTRAINT "FK_JRGY_DETALLE_PAGO_HABITACION_PAGO" FOREIGN KEY ("COD_PAGO_HABITACION")
	  REFERENCES "UCM"."JRGY_PAGO_HABITACION" ("COD_PAGO_HABITACION") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_DETALLE_PAGO_HABITACION" ADD CONSTRAINT "FK_JRGY_DETALLE_PAGO_HABITACION_HAB" FOREIGN KEY ("COD_HABITACION")
	  REFERENCES "UCM"."JRGY_HABITACION" ("COD_HABITACION") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_DETALLE_PEDIDO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DETALLE_PEDIDO" ADD CONSTRAINT "FK_JRGY_DETALLE_PEDIDO_PEDIDO" FOREIGN KEY ("COD_PEDIDO")
	  REFERENCES "UCM"."JRGY_PEDIDO" ("COD_PEDIDO") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_DETALLE_PEDIDO" ADD CONSTRAINT "FK_JRGY_DETALLE_PEDIDO_PROVEEDOR" FOREIGN KEY ("COD_PROVEEDOR")
	  REFERENCES "UCM"."JRGY_PROVEEDOR" ("COD_PROVEEDOR") ENABLE;
  ALTER TABLE "UCM"."JRGY_DETALLE_PEDIDO" ADD CONSTRAINT "FK_JRGY_DETALLE_PEDIDO_PRODUCTO" FOREIGN KEY ("COD_PRODUCTO")
	  REFERENCES "UCM"."JRGY_PRODUCTO" ("COD_PRODUCTO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_DETALLE_VENTA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_DETALLE_VENTA" ADD CONSTRAINT "FK_JRGY_DETALLE_VENTA_VENTA" FOREIGN KEY ("COD_VENTA")
	  REFERENCES "UCM"."JRGY_VENTA" ("COD_VENTA") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_DETALLE_VENTA" ADD CONSTRAINT "FK_JRGY_DETALLE_VENTA_PRODUCTO" FOREIGN KEY ("COD_PRODUCTO")
	  REFERENCES "UCM"."JRGY_PRODUCTO" ("COD_PRODUCTO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_EMPLEADO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EMPLEADO" ADD CONSTRAINT "FK_JRGY_EMPLEADO_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
  ALTER TABLE "UCM"."JRGY_EMPLEADO" ADD CONSTRAINT "FK_JRGY_EMPLEADO_ESTADO" FOREIGN KEY ("COD_ESTADO_LABORAL")
	  REFERENCES "UCM"."JRGY_CAT_ESTADO_LABORAL" ("COD_ESTADO_LABORAL") ENABLE;
  ALTER TABLE "UCM"."JRGY_EMPLEADO" ADD CONSTRAINT "FK_JRGY_EMPLEADO_DEPTO" FOREIGN KEY ("COD_DEPARTAMENTO")
	  REFERENCES "UCM"."JRGY_DEPARTAMENTO" ("COD_DEPARTAMENTO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_EMPLEADO_HABILIDAD
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EMPLEADO_HABILIDAD" ADD CONSTRAINT "FK_JRGY_EMP_HAB_EMP" FOREIGN KEY ("COD_EMPLEADO")
	  REFERENCES "UCM"."JRGY_EMPLEADO" ("COD_EMPLEADO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_EVENTO_RESERVA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_EVENTO_RESERVA" ADD CONSTRAINT "FK_JRGY_EVENTO_RESERVA_RES" FOREIGN KEY ("COD_RESERVA")
	  REFERENCES "UCM"."JRGY_RESERVA" ("COD_RESERVA") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_EVENTO_RESERVA" ADD CONSTRAINT "FK_JRGY_EVENTO_RESERVA_USER" FOREIGN KEY ("CREATED_BY")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_HABITACION" ADD CONSTRAINT "FK_JRGY_HAB_TIPO" FOREIGN KEY ("COD_TIPO_HABITACION")
	  REFERENCES "UCM"."JRGY_CAT_TIPO_HABITACION" ("COD_TIPO_HABITACION") ENABLE;
  ALTER TABLE "UCM"."JRGY_HABITACION" ADD CONSTRAINT "FK_JRGY_HAB_ESTADO" FOREIGN KEY ("COD_ESTADO_HABITACION")
	  REFERENCES "UCM"."JRGY_CAT_ESTADO_HABITACION" ("COD_ESTADO_HABITACION") ENABLE;
  ALTER TABLE "UCM"."JRGY_HABITACION" ADD CONSTRAINT "FK_JRGY_HAB_USUARIO" FOREIGN KEY ("COD_USUARIO_OCUPANTE")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_MOVIMIENTO_STOCK
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_MOVIMIENTO_STOCK" ADD CONSTRAINT "FK_JRGY_MOVIMIENTO_STOCK_PRODUCTO" FOREIGN KEY ("COD_PRODUCTO")
	  REFERENCES "UCM"."JRGY_PRODUCTO" ("COD_PRODUCTO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_PAGO_HABITACION
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PAGO_HABITACION" ADD CONSTRAINT "FK_JRGY_PAGO_HABITACION_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_PAGO_VENTA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PAGO_VENTA" ADD CONSTRAINT "FK_JRGY_PAGO_VENTA_VENTA" FOREIGN KEY ("COD_VENTA")
	  REFERENCES "UCM"."JRGY_VENTA" ("COD_VENTA") ENABLE;
  ALTER TABLE "UCM"."JRGY_PAGO_VENTA" ADD CONSTRAINT "FK_JRGY_PAGO_VENTA_MODO" FOREIGN KEY ("COD_MODO_PAGO")
	  REFERENCES "UCM"."JRGY_CAT_MODO_PAGO" ("COD_MODO_PAGO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_PEDIDO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PEDIDO" ADD CONSTRAINT "FK_JRGY_PEDIDO_EMPLEADO" FOREIGN KEY ("COD_EMPLEADO")
	  REFERENCES "UCM"."JRGY_EMPLEADO" ("COD_EMPLEADO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_PRODUCTO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PRODUCTO" ADD CONSTRAINT "FK_JRGY_PRODUCTO_TIPO" FOREIGN KEY ("COD_TIPO_SERVICIO")
	  REFERENCES "UCM"."JRGY_CAT_TIPO_SERVICIO" ("COD_TIPO_SERVICIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_PROVEEDOR
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_PROVEEDOR" ADD CONSTRAINT "FK_JRGY_PROVEEDOR_REGION" FOREIGN KEY ("COD_REGION")
	  REFERENCES "UCM"."JRGY_REGION" ("COD_REGION") ENABLE;
  ALTER TABLE "UCM"."JRGY_PROVEEDOR" ADD CONSTRAINT "FK_JRGY_PROVEEDOR_CIUDAD" FOREIGN KEY ("COD_CIUDAD")
	  REFERENCES "UCM"."JRGY_CIUDAD" ("COD_CIUDAD") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_RESERVA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_RESERVA" ADD CONSTRAINT "FK_JRGY_RESERVA_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA" ADD CONSTRAINT "FK_JRGY_RESERVA_HAB" FOREIGN KEY ("COD_HABITACION")
	  REFERENCES "UCM"."JRGY_HABITACION" ("COD_HABITACION") ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA" ADD CONSTRAINT "FK_JRGY_RESERVA_ESTADO" FOREIGN KEY ("COD_ESTADO_RESERVA")
	  REFERENCES "UCM"."JRGY_CAT_ESTADO_RESERVA" ("COD_ESTADO_RESERVA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_RESERVA_EXP
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_RESERVA_EXP" ADD CONSTRAINT "FK_JRGY_RES_EXP_RESERVA" FOREIGN KEY ("COD_RESERVA")
	  REFERENCES "UCM"."JRGY_RESERVA" ("COD_RESERVA") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA_EXP" ADD CONSTRAINT "FK_JRGY_RES_EXP_EXP" FOREIGN KEY ("COD_EXPERIENCIA")
	  REFERENCES "UCM"."JRGY_EXPERIENCIA" ("COD_EXPERIENCIA") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_RESERVA_SERVICIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" ADD CONSTRAINT "FK_JRGY_RES_SERV_RES" FOREIGN KEY ("COD_RESERVA")
	  REFERENCES "UCM"."JRGY_RESERVA" ("COD_RESERVA") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_RESERVA_SERVICIO" ADD CONSTRAINT "FK_JRGY_RES_SERV_SERV" FOREIGN KEY ("COD_SERVICIO")
	  REFERENCES "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_SERVICIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO" ADD CONSTRAINT "FK_JRGY_SERVICIO_TIPO" FOREIGN KEY ("COD_TIPO_SERVICIO")
	  REFERENCES "UCM"."JRGY_CAT_TIPO_SERVICIO" ("COD_TIPO_SERVICIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_SERVICIO_HORARIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO_HORARIO" ADD CONSTRAINT "FK_JRGY_SERV_HOR_SERV" FOREIGN KEY ("COD_SERVICIO")
	  REFERENCES "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_SERVICIO_PAQUETE
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO_PAQUETE" ADD CONSTRAINT "FK_JRGY_SERV_PAQ_PQ" FOREIGN KEY ("COD_PAQUETE")
	  REFERENCES "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") ON DELETE CASCADE ENABLE;
  ALTER TABLE "UCM"."JRGY_SERVICIO_PAQUETE" ADD CONSTRAINT "FK_JRGY_SERV_PAQ_SERV" FOREIGN KEY ("COD_SERVICIO_INCL")
	  REFERENCES "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") ON DELETE CASCADE ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_SERVICIO_PRODUCTO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SERVICIO_PRODUCTO" ADD CONSTRAINT "FK_JRGY_SERVICIO_PRODUCTO_SERV" FOREIGN KEY ("COD_SERVICIO")
	  REFERENCES "UCM"."JRGY_SERVICIO" ("COD_SERVICIO") ENABLE;
  ALTER TABLE "UCM"."JRGY_SERVICIO_PRODUCTO" ADD CONSTRAINT "FK_JRGY_SERVICIO_PRODUCTO_PROD" FOREIGN KEY ("COD_PRODUCTO")
	  REFERENCES "UCM"."JRGY_PRODUCTO" ("COD_PRODUCTO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_SOLICITUD_ADMIN
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_SOLICITUD_ADMIN" ADD CONSTRAINT "FK_JRGY_SOLICITUD_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
  ALTER TABLE "UCM"."JRGY_SOLICITUD_ADMIN" ADD CONSTRAINT "FK_JRGY_SOLICITUD_APROBADO" FOREIGN KEY ("APROBADO_POR")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_USUARIO
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_USUARIO" ADD CONSTRAINT "FK_JRGY_USUARIO_ESTADO" FOREIGN KEY ("COD_ESTADO_USUARIO")
	  REFERENCES "UCM"."JRGY_CAT_ESTADO_USUARIO" ("COD_ESTADO_USUARIO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_USUARIO_ROL
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_USUARIO_ROL" ADD CONSTRAINT "FK_JRGY_USUARIO_ROL_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
  ALTER TABLE "UCM"."JRGY_USUARIO_ROL" ADD CONSTRAINT "FK_JRGY_USUARIO_ROL_ROL" FOREIGN KEY ("COD_ROL")
	  REFERENCES "UCM"."JRGY_ROL" ("COD_ROL") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table JRGY_VENTA
--------------------------------------------------------

  ALTER TABLE "UCM"."JRGY_VENTA" ADD CONSTRAINT "FK_JRGY_VENTA_USUARIO" FOREIGN KEY ("COD_USUARIO")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
  ALTER TABLE "UCM"."JRGY_VENTA" ADD CONSTRAINT "FK_JRGY_VENTA_EMPLEADO" FOREIGN KEY ("COD_EMPLEADO")
	  REFERENCES "UCM"."JRGY_EMPLEADO" ("COD_EMPLEADO") ENABLE;
--------------------------------------------------------
--  Ref Constraints for Table TOKENS
--------------------------------------------------------

  ALTER TABLE "UCM"."TOKENS" ADD CONSTRAINT "FK_TOKENS_USUARIO" FOREIGN KEY ("USER_ID")
	  REFERENCES "UCM"."JRGY_USUARIO" ("COD_USUARIO") ENABLE;
